<!DOCTYPE html>
<!--
    School Escape - Action Arcade Game
    Copyright (c) 2025 Ilja Livenson and Mark Livenson
    All rights reserved.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>School Escape - Action Arcade Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 800px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            color: white;
        }

        #score-display {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #combo-display {
            font-size: 18px;
            color: #ff6b6b;
            transition: transform 0.1s;
        }

        #combo-display.pulse {
            transform: scale(1.3);
            color: #ff0000;
        }

        #lives-display {
            display: flex;
            gap: 5px;
        }

        .life-icon {
            width: 25px;
            height: 25px;
            background: #ff6b6b;
            border-radius: 50%;
            border: 2px solid white;
        }

        .life-icon.lost {
            background: #333;
            opacity: 0.5;
        }

        #powerup-display {
            display: flex;
            gap: 10px;
        }

        .powerup-slot {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .powerup-slot.active {
            border-color: #ffd700;
            box-shadow: 0 0 10px #ffd700;
            animation: glow 0.5s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 10px #ffd700; }
            to { box-shadow: 0 0 20px #ffd700; }
        }

        #game-canvas {
            border: 4px solid #4a4a6a;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5), inset 0 0 50px rgba(0, 0, 0, 0.3);
            background: #2a2a4a;
        }

        #game-footer {
            display: flex;
            justify-content: center;
            gap: 20px;
            color: white;
            font-size: 14px;
            opacity: 0.8;
        }

        .key-hint {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .key {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        /* Menu Screens */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            color: white;
        }

        .menu-screen.hidden {
            display: none;
        }

        #main-menu h1 {
            font-size: 48px;
            color: #ffd700;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            margin-bottom: 10px;
        }

        #main-menu h2 {
            font-size: 24px;
            color: #ff6b6b;
            margin-bottom: 40px;
        }

        .menu-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }

        .menu-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .sound-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            font-size: 14px;
            color: white;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .sound-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .settings-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            min-width: 300px;
        }

        .setting-row label {
            font-size: 16px;
        }

        .setting-row select, .setting-row input {
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
        }

        .setting-row input[type="range"] {
            width: 150px;
        }

        /* Game Over / Win Screen */
        #game-over-screen h2 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        #game-over-screen.win h2 {
            color: #4ade80;
        }

        #game-over-screen.lose h2 {
            color: #ff6b6b;
        }

        #final-score {
            font-size: 36px;
            color: #ffd700;
            margin-bottom: 30px;
        }

        /* Level indicator */
        #level-display {
            font-size: 18px;
            color: #4ade80;
        }

        /* Items remaining */
        #items-display {
            font-size: 16px;
            color: #60a5fa;
        }

        /* Pause Screen */
        #pause-screen {
            background: rgba(0, 0, 0, 0.8);
        }

        #pause-screen h2 {
            font-size: 48px;
            color: #ffd700;
            margin-bottom: 30px;
        }

        /* Message popup */
        #message-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 32px;
            font-weight: bold;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #message-popup.show {
            opacity: 1;
        }

        /* Minimap */
        #minimap {
            position: absolute;
            bottom: 60px;
            right: 10px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            opacity: 0.8;
        }

        /* Collapsible settings */
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin-bottom: 0;
            transition: background 0.2s;
        }

        .collapsible-header:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .collapsible-header .header-title {
            font-size: 14px;
            color: #aaa;
        }

        .collapsible-header .toggle-icon {
            font-size: 12px;
            transition: transform 0.3s;
            color: #aaa;
        }

        .collapsible-header.expanded .toggle-icon {
            transform: rotate(180deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0 15px;
        }

        .collapsible-content.expanded {
            max-height: 200px;
            padding: 15px;
        }

        /* Multiplayer Styles */
        .room-code-display {
            font-size: 32px;
            font-family: 'Courier New', monospace;
            letter-spacing: 8px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 30px;
            border-radius: 10px;
            color: #ffd700;
            margin: 15px 0;
            user-select: all;
        }

        .room-code-input {
            font-size: 24px;
            font-family: 'Courier New', monospace;
            letter-spacing: 4px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 20px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            text-align: center;
            width: 200px;
            text-transform: uppercase;
        }

        .room-code-input:focus {
            outline: none;
            border-color: #4ade80;
        }

        .player-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            min-width: 300px;
            max-height: 200px;
            overflow-y: auto;
        }

        .player-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .player-item:last-child {
            margin-bottom: 0;
        }

        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
        }

        .player-name {
            flex: 1;
            color: #fff;
            font-size: 16px;
        }

        .player-host-badge {
            background: #ffd700;
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .player-you-badge {
            background: #4ade80;
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .multiplayer-status {
            color: #aaa;
            font-size: 14px;
            margin: 10px 0;
        }

        .multiplayer-status.connected {
            color: #4ade80;
        }

        .multiplayer-status.connecting {
            color: #fbbf24;
        }

        .multiplayer-status.error {
            color: #ef4444;
        }

        #multiplayer-players-hud {
            position: absolute;
            top: 70px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            padding: 10px;
            display: none;
            z-index: 100;
        }

        .mp-player-hud-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            font-size: 14px;
            color: #fff;
        }

        .mp-player-hud-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .mp-player-hud-lives {
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-header">
            <div id="score-display">Score: 0</div>
            <div id="combo-display">Combo: x1</div>
            <div id="level-display">Level 1</div>
            <div id="items-display">Items: 0/0</div>
            <div id="powerup-display">
                <div class="powerup-slot" id="powerup-1" title="Hall Pass"></div>
                <div class="powerup-slot" id="powerup-2" title="Energy Drink"></div>
                <div class="powerup-slot" id="powerup-3" title="Stink Bomb"></div>
            </div>
            <div id="lives-display"></div>
        </div>

        <canvas id="game-canvas" width="800" height="600"></canvas>
        <canvas id="minimap" width="150" height="112"></canvas>

        <!-- Multiplayer Players HUD -->
        <div id="multiplayer-players-hud"></div>

        <div id="game-footer">
            <div class="key-hint"><span class="key">WASD</span> or <span class="key">Arrows</span> Move</div>
            <div class="key-hint"><span class="key">SPACE</span> Dash</div>
            <div class="key-hint"><span class="key">1-3</span> Use Power-up</div>
            <div class="key-hint"><span class="key">ESC</span> Pause</div>
        </div>

        <!-- Main Menu -->
        <div id="main-menu" class="menu-screen">
            <h1>SCHOOL ESCAPE</h1>
            <h2>Escape the Teachers!</h2>

            <!-- Game Mode Selection -->
            <div style="display: flex; gap: 20px; margin: 20px 0; flex-wrap: wrap; justify-content: center;">
                <button class="menu-button" id="campaign-button" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">üìö CAMPAIGN</button>
                <button class="menu-button" id="freeplay-button" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">üéÆ FREE PLAY</button>
                <button class="menu-button" id="multiplayer-button" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">üë• MULTIPLAYER</button>
            </div>

            <!-- Campaign Progress Display -->
            <div id="campaign-progress-display" class="settings-panel" style="display: none; text-align: center;">
                <div style="color: #ffd700; font-size: 18px; margin-bottom: 10px;" id="current-level-text">Current Level: Grade 1</div>
                <div style="width: 100%; height: 15px; background: rgba(255,255,255,0.2); border-radius: 8px; overflow: hidden;">
                    <div id="menu-progress-bar" style="height: 100%; background: linear-gradient(90deg, #4ade80, #22d3ee); width: 0%; transition: width 0.3s;"></div>
                </div>
                <div style="color: #aaa; margin-top: 5px;" id="menu-progress-text">0/17 completed</div>
            </div>

            <button class="menu-button" id="start-button" style="display: none;">START GAME</button>

            <!-- Free Play Settings (Collapsible) -->
            <div id="freeplay-settings" class="settings-panel" style="display: none; padding: 10px;">
                <div class="collapsible-header expanded" id="freeplay-toggle" onclick="toggleFreeplayPanel()">
                    <span class="header-title" data-translate="freeplaySettings">üéÆ Free Play Settings</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="collapsible-content expanded" id="freeplay-content">
                    <div class="setting-row">
                        <label>School Type:</label>
                        <select id="school-type">
                            <option value="elementary">Elementary (Easy)</option>
                            <option value="middle" selected>Middle School (Medium)</option>
                            <option value="high">High School (Hard)</option>
                            <option value="university">University (Expert)</option>
                        </select>
                    </div>
                    <div class="setting-row">
                        <label>Map Size:</label>
                        <select id="map-size">
                            <option value="small">Small</option>
                            <option value="medium" selected>Medium</option>
                            <option value="large">Large</option>
                        </select>
                    </div>
                    <div class="setting-row">
                        <label>Teachers:</label>
                        <input type="range" id="teacher-count" min="2" max="8" value="4">
                        <span id="teacher-count-display">4</span>
                    </div>
                </div>
            </div>

            <!-- Common Settings (Collapsible) -->
            <div class="settings-panel" style="padding: 10px;">
                <div class="collapsible-header" id="settings-toggle" onclick="toggleSettingsPanel()">
                    <span class="header-title">‚öôÔ∏è Settings</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="collapsible-content" id="settings-content">
                    <div class="setting-row">
                        <label>Language:</label>
                        <select id="language-select" onchange="setLanguage(this.value)">
                            <option value="en">English</option>
                            <option value="et">Eesti</option>
                            <option value="lv">Latvie≈°u</option>
                            <option value="lt">Lietuvi≈≥</option>
                            <option value="ru">–†—É—Å—Å–∫–∏–π</option>
                        </select>
                    </div>
                    <div class="setting-row" style="justify-content: center; gap: 20px;">
                        <button class="sound-btn" id="sound-toggle" onclick="toggleSound()">üîä Sound: ON</button>
                        <button class="sound-btn" id="music-toggle" onclick="toggleMusic()">üéµ Music: ON</button>
                    </div>
                    <div class="setting-row" style="justify-content: center;">
                        <button class="sound-btn" id="events-toggle" onclick="toggleEvents()" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">üé≤ Random Events: OFF</button>
                    </div>
                </div>
            </div>

            <!-- Map Configuration (Collapsible) -->
            <div class="settings-panel" style="padding: 10px;">
                <div class="collapsible-header" id="map-config-toggle" onclick="toggleMapConfigPanel()">
                    <span class="header-title" data-translate="mapConfigTitle">üó∫Ô∏è Map Configuration</span>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="collapsible-content" id="map-config-content">
                    <div class="setting-row">
                        <label data-translate="mapTopology">Map Layout:</label>
                        <select id="map-topology">
                            <option value="grid" data-translate="topologyGrid">Grid (Classic)</option>
                            <option value="labyrinth" data-translate="topologyLabyrinth">Labyrinth (Maze)</option>
                            <option value="corridors" data-translate="topologyCorridors">Many Corridors</option>
                            <option value="openPlan" data-translate="topologyOpenPlan">Open Plan</option>
                        </select>
                    </div>
                    <div class="setting-row">
                        <label data-translate="corridorDensity">Corridor Density:</label>
                        <select id="corridor-density">
                            <option value="low" data-translate="densityLow">Low</option>
                            <option value="medium" selected data-translate="densityMedium">Medium</option>
                            <option value="high" data-translate="densityHigh">High</option>
                        </select>
                    </div>
                    <div class="setting-row">
                        <label data-translate="roomDensity">Room Density:</label>
                        <select id="room-density">
                            <option value="few" data-translate="roomsFew">Few Rooms</option>
                            <option value="normal" selected data-translate="roomsNormal">Normal</option>
                            <option value="many" data-translate="roomsMany">Many Rooms</option>
                        </select>
                    </div>
                </div>
            </div>

            <button class="menu-button" id="how-to-play-button">HOW TO PLAY</button>

            <div style="margin-top: 30px; color: #666; font-size: 12px;">
                ¬© 2025 Ilja Livenson and Mark Livenson
            </div>
        </div>

        <!-- How To Play -->
        <div id="how-to-play-screen" class="menu-screen hidden">
            <h2 style="color: #ffd700; margin-bottom: 30px;">HOW TO PLAY</h2>
            <div class="settings-panel" style="max-width: 500px; text-align: left;">
                <p style="margin-bottom: 15px;"><strong style="color: #4ade80;">OBJECTIVE:</strong> Collect all homework pages and reach the exit without getting caught by teachers!</p>

                <p style="margin-bottom: 15px;"><strong style="color: #60a5fa;">CONTROLS:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>WASD or Arrow Keys - Move</li>
                    <li>SPACE - Dash (quick burst of speed)</li>
                    <li>1, 2, 3 - Use collected power-ups</li>
                    <li>ESC - Pause game</li>
                </ul>

                <p style="margin-bottom: 15px;"><strong style="color: #ffd700;">POWER-UPS:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>üìú Hall Pass - Temporary invincibility</li>
                    <li>‚ö° Energy Drink - Super speed</li>
                    <li>üí® Stink Bomb - Stuns nearby teachers</li>
                    <li>üõπ Skateboard - Fast movement</li>
                </ul>

                <p style="margin-bottom: 15px;"><strong style="color: #ff6b6b;">TEACHERS:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>üßë‚Äçüè´ Patrol Teacher - Follows set routes</li>
                    <li>üë®‚Äçüè´ Hunter Teacher - Actively chases you</li>
                    <li>üë©‚Äçüè´ Fast Teacher - Quick but predictable</li>
                </ul>

                <p style="margin-bottom: 15px;"><strong style="color: #9ca3af;">MAP TILES:</strong></p>
                <ul style="margin-left: 20px;">
                    <li><span style="display: inline-block; width: 16px; height: 16px; background: #4a4a6a; vertical-align: middle; margin-right: 5px; border-radius: 2px;"></span> Floor - Walkable area</li>
                    <li><span style="display: inline-block; width: 16px; height: 16px; background: linear-gradient(#5c4033, #3d2817); vertical-align: middle; margin-right: 5px; border-radius: 2px;"></span> Wall - Cannot pass through</li>
                    <li><span style="display: inline-block; width: 16px; height: 16px; background: #8b4513; vertical-align: middle; margin-right: 5px; border-radius: 2px;"></span> Desk - Classroom obstacle</li>
                    <li><span style="display: inline-block; width: 16px; height: 16px; background: #4a90a4; vertical-align: middle; margin-right: 5px; border-radius: 2px;"></span> Locker - Corridor obstacle</li>
                    <li><span style="display: inline-block; width: 16px; height: 16px; background: rgba(100, 200, 255, 0.5); vertical-align: middle; margin-right: 5px; border-radius: 2px;"></span> Wet Floor - Slippery surface</li>
                    <li><span style="display: inline-block; width: 16px; height: 16px; background: #4ade80; vertical-align: middle; margin-right: 5px; border-radius: 2px;"></span> Exit - Escape here (green when unlocked)</li>
                </ul>
            </div>
            <button class="menu-button" id="back-to-menu-button">BACK TO MENU</button>
        </div>

        <!-- Pause Screen -->
        <div id="pause-screen" class="menu-screen hidden">
            <h2>PAUSED</h2>
            <button class="menu-button" id="resume-button">RESUME</button>
            <button class="menu-button" id="quit-button">QUIT TO MENU</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="menu-screen hidden">
            <h2>GAME OVER</h2>
            <div id="final-score">Score: 0</div>
            <div id="final-stats" style="margin-bottom: 20px; color: #aaa;"></div>
            <div id="multiplayer-scores" style="display: none; margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; max-width: 300px;">
                <div style="font-size: 14px; color: #f59e0b; margin-bottom: 10px; font-weight: bold;">PLAYER SCORES</div>
                <div id="multiplayer-scores-list"></div>
            </div>
            <button class="menu-button" id="retry-button">PLAY AGAIN</button>
            <button class="menu-button" id="menu-button">MAIN MENU</button>
        </div>

        <!-- Level Complete Screen -->
        <div id="level-complete-screen" class="menu-screen hidden">
            <h2 id="level-complete-title" style="color: #4ade80;">LEVEL COMPLETE!</h2>
            <div id="level-name-display" style="font-size: 28px; color: #ffd700; margin: 10px 0;"></div>
            <div id="level-score" style="font-size: 24px; color: #fff; margin: 10px 0;">Score: 0</div>
            <div id="level-multiplayer-scores" style="display: none; margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; max-width: 300px;">
                <div style="font-size: 14px; color: #f59e0b; margin-bottom: 10px; font-weight: bold;">PLAYER SCORES</div>
                <div id="level-multiplayer-scores-list"></div>
            </div>
            <div id="level-progress" style="margin: 20px 0;">
                <div style="color: #aaa; margin-bottom: 10px;">Progress</div>
                <div id="progress-bar-container" style="width: 300px; height: 20px; background: rgba(255,255,255,0.2); border-radius: 10px; overflow: hidden; margin: 0 auto;">
                    <div id="progress-bar" style="height: 100%; background: linear-gradient(90deg, #4ade80, #22d3ee); width: 0%; transition: width 0.5s;"></div>
                </div>
                <div id="progress-text" style="color: #aaa; margin-top: 5px;">1/17</div>
            </div>
            <button class="menu-button" id="next-level-button">NEXT LEVEL</button>
            <button class="menu-button" id="level-menu-button" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);">MAIN MENU</button>
        </div>

        <!-- Graduation Screen -->
        <div id="graduation-screen" class="menu-screen hidden">
            <h2 style="color: #ffd700; font-size: 48px;">üéì GRADUATED! üéì</h2>
            <div id="graduation-message" style="font-size: 20px; color: #fff; margin: 20px 0; max-width: 400px;"></div>
            <div id="total-score" style="font-size: 32px; color: #4ade80; margin: 20px 0;">Total Score: 0</div>
            <button class="menu-button" id="new-game-button">NEW GAME</button>
            <button class="menu-button" id="graduation-menu-button" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);">MAIN MENU</button>
        </div>

        <!-- Multiplayer Menu Screen -->
        <div id="multiplayer-menu-screen" class="menu-screen hidden">
            <h2 style="color: #f59e0b;">üë• MULTIPLAYER</h2>
            <p style="color: #aaa; margin-bottom: 20px;" data-translate="multiplayerDesc">Play with friends online!</p>

            <div style="display: flex; gap: 20px; margin: 20px 0;">
                <button class="menu-button" id="create-room-button" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                    üè† CREATE ROOM
                </button>
                <button class="menu-button" id="join-room-button" style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);">
                    üö™ JOIN ROOM
                </button>
            </div>

            <button class="menu-button" id="mp-back-to-menu" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);">BACK</button>
        </div>

        <!-- Create Room Screen -->
        <div id="create-room-screen" class="menu-screen hidden">
            <h2 style="color: #10b981;">üè† CREATE ROOM</h2>

            <div class="settings-panel" style="text-align: center;">
                <p style="color: #aaa; margin-bottom: 10px;">Your Room Code:</p>
                <div class="room-code-display" id="host-room-code">----</div>
                <p style="color: #888; font-size: 12px;">Share this code with your friends</p>
            </div>

            <div id="mp-connection-status" class="multiplayer-status">Connecting...</div>

            <div class="player-list" id="host-player-list">
                <p style="color: #aaa; text-align: center;">Waiting for players...</p>
            </div>

            <!-- Game Settings for Host -->
            <div class="settings-panel" style="padding: 10px;">
                <div class="setting-row">
                    <label>Map Size:</label>
                    <select id="mp-map-size">
                        <option value="small">Small</option>
                        <option value="medium" selected>Medium</option>
                        <option value="large">Large</option>
                    </select>
                </div>
                <div class="setting-row">
                    <label>Teachers:</label>
                    <input type="range" id="mp-teacher-count" min="2" max="8" value="4">
                    <span id="mp-teacher-count-display">4</span>
                </div>
            </div>

            <div style="display: flex; gap: 15px; margin-top: 15px;">
                <button class="menu-button" id="mp-start-game" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                    ‚ñ∂ START GAME
                </button>
                <button class="menu-button" id="mp-cancel-host" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);">
                    ‚úï CANCEL
                </button>
            </div>
        </div>

        <!-- Join Room Screen -->
        <div id="join-room-screen" class="menu-screen hidden">
            <h2 style="color: #3b82f6;">üö™ JOIN ROOM</h2>

            <div class="settings-panel" style="text-align: center;">
                <p style="color: #aaa; margin-bottom: 15px;">Enter Room Code:</p>
                <input type="text" class="room-code-input" id="join-room-code" maxlength="3" placeholder="XXX" autocomplete="off">
            </div>

            <div id="join-connection-status" class="multiplayer-status"></div>

            <div style="display: flex; gap: 15px; margin-top: 15px;">
                <button class="menu-button" id="mp-join-room" style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);">
                    üö™ JOIN
                </button>
                <button class="menu-button" id="mp-cancel-join" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);">
                    BACK
                </button>
            </div>
        </div>

        <!-- Multiplayer Lobby Screen (for non-host after joining) -->
        <div id="multiplayer-lobby-screen" class="menu-screen hidden">
            <h2 style="color: #f59e0b;">üë• GAME LOBBY</h2>

            <div class="settings-panel" style="text-align: center;">
                <p style="color: #aaa; margin-bottom: 10px;">Room Code:</p>
                <div class="room-code-display" id="lobby-room-code">----</div>
            </div>

            <div class="player-list" id="lobby-player-list">
                <p style="color: #aaa; text-align: center;">Loading players...</p>
            </div>

            <p style="color: #aaa; margin: 15px 0;">Waiting for host to start the game...</p>

            <button class="menu-button" id="mp-leave-lobby" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);">
                ‚úï LEAVE
            </button>
        </div>

        <!-- Message Popup -->
        <div id="message-popup"></div>
    </div>

    <script>
        // ============================================
        // SCHOOL ESCAPE - Action Arcade Game
        // ============================================

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        // Game constants
        const TILE_SIZE = 32;
        const PLAYER_SIZE = 24;
        const TEACHER_SIZE = 28;

        // Tile types
        const TILES = {
            FLOOR: 0,
            WALL: 1,
            DESK: 2,
            LOCKER: 3,
            WET_FLOOR: 4,
            EXIT: 5,
            DOOR: 6
        };

        // Game state
        let gameState = {
            running: false,
            paused: false,
            score: 0,
            combo: 1,
            comboTimer: 0,
            lives: 3,
            level: 1,
            map: [],
            mapWidth: 0,
            mapHeight: 0,
            collectibles: [],
            powerups: [],
            activePowerups: [],
            playerPowerups: [null, null, null],
            particles: [],
            screenShake: 0,
            camera: { x: 0, y: 0 },
            reportedPlayerLocation: null  // Patrol teachers report player location here
        };

        // Player object
        let player = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            speed: 4,
            dashCooldown: 0,
            isDashing: false,
            dashTimer: 0,
            invincible: false,
            invincibleTimer: 0,
            speedBoost: false,
            speedBoostTimer: 0,
            direction: 0, // 0: right, 1: down, 2: left, 3: up
            animFrame: 0
        };

        // Teachers array
        let teachers = [];

        // Input state
        const keys = {};

        // Settings
        let settings = {
            schoolType: 'middle',
            mapSize: 'medium',
            teacherCount: 4,
            soundEnabled: true,
            musicEnabled: false,
            language: 'en',
            eventsEnabled: false,
            // Map generation settings
            mapTopology: 'grid',           // grid, labyrinth, corridors, openPlan
            corridorDensity: 'medium',     // low, medium, high
            roomDensity: 'normal'          // few, normal, many
        };

        // Random Events System
        const RANDOM_EVENTS = [
            { id: 'ufo', name: 'ufoAbduction', duration: 6, minInterval: 30, icon: 'üõ∏' },
            { id: 'dinosaur', name: 'dinosaurStampede', duration: 8, minInterval: 45, icon: 'ü¶ñ' },
            { id: 'parents', name: 'parentsVisiting', duration: 15, minInterval: 40, icon: 'üë®‚Äçüë©‚Äçüëß' },
            { id: 'fireDrill', name: 'fireDrill', duration: 12, minInterval: 50, icon: 'üö®' },
            { id: 'principal', name: 'principalInspection', duration: 10, minInterval: 35, icon: 'üé©' },
            { id: 'powerOutage', name: 'powerOutage', duration: 12, minInterval: 40, icon: 'üí°' },
            { id: 'foodFight', name: 'foodFight', duration: 8, minInterval: 35, icon: 'üçï' },
            { id: 'superhero', name: 'superheroStudent', duration: 6, minInterval: 45, icon: 'ü¶∏' },
            { id: 'ghost', name: 'ghostJanitor', duration: 10, minInterval: 40, icon: 'üëª' },
            { id: 'timeFreeze', name: 'timeFreeze', duration: 5, minInterval: 50, icon: '‚è±Ô∏è' },
            { id: 'earthquake', name: 'earthquake', duration: 3, minInterval: 60, icon: 'üåã' },
            { id: 'pizza', name: 'pizzaDelivery', duration: 8, minInterval: 35, icon: 'üçï' }
        ];

        let currentEvent = null;
        let eventTimer = 0;
        let nextEventTime = 15; // First event after 15 seconds
        let eventEntities = []; // For UFOs, dinosaurs, etc.

        // Level configuration (17 levels total)
        const LEVELS = [
            // Grades 1-9 (Elementary & Middle School)
            { id: 1,  name: 'grade1',     mapSize: { w: 20, h: 15 }, teachers: 2, speed: 0.6, collectibles: 8,  schoolType: 'elementary' },
            { id: 2,  name: 'grade2',     mapSize: { w: 22, h: 16 }, teachers: 2, speed: 0.65, collectibles: 10, schoolType: 'elementary' },
            { id: 3,  name: 'grade3',     mapSize: { w: 24, h: 17 }, teachers: 3, speed: 0.7, collectibles: 12, schoolType: 'elementary' },
            { id: 4,  name: 'grade4',     mapSize: { w: 26, h: 18 }, teachers: 3, speed: 0.75, collectibles: 14, schoolType: 'elementary' },
            { id: 5,  name: 'grade5',     mapSize: { w: 28, h: 19 }, teachers: 3, speed: 0.8, collectibles: 15, schoolType: 'middle' },
            { id: 6,  name: 'grade6',     mapSize: { w: 30, h: 20 }, teachers: 4, speed: 0.85, collectibles: 16, schoolType: 'middle' },
            { id: 7,  name: 'grade7',     mapSize: { w: 32, h: 22 }, teachers: 4, speed: 0.9, collectibles: 18, schoolType: 'middle' },
            { id: 8,  name: 'grade8',     mapSize: { w: 34, h: 24 }, teachers: 4, speed: 0.95, collectibles: 20, schoolType: 'middle' },
            { id: 9,  name: 'grade9',     mapSize: { w: 36, h: 25 }, teachers: 5, speed: 1.0, collectibles: 22, schoolType: 'middle' },
            // Gymnasium (3 years)
            { id: 10, name: 'gymnasium1', mapSize: { w: 38, h: 26 }, teachers: 5, speed: 1.05, collectibles: 24, schoolType: 'high' },
            { id: 11, name: 'gymnasium2', mapSize: { w: 40, h: 28 }, teachers: 5, speed: 1.1, collectibles: 26, schoolType: 'high' },
            { id: 12, name: 'gymnasium3', mapSize: { w: 42, h: 30 }, teachers: 6, speed: 1.15, collectibles: 28, schoolType: 'high' },
            // Bachelor (3 years)
            { id: 13, name: 'bachelor1',  mapSize: { w: 44, h: 32 }, teachers: 6, speed: 1.2, collectibles: 30, schoolType: 'university' },
            { id: 14, name: 'bachelor2',  mapSize: { w: 46, h: 34 }, teachers: 6, speed: 1.25, collectibles: 32, schoolType: 'university' },
            { id: 15, name: 'bachelor3',  mapSize: { w: 48, h: 36 }, teachers: 7, speed: 1.3, collectibles: 34, schoolType: 'university' },
            // Master (2 years)
            { id: 16, name: 'master1',    mapSize: { w: 50, h: 38 }, teachers: 7, speed: 1.35, collectibles: 36, schoolType: 'university' },
            { id: 17, name: 'master2',    mapSize: { w: 55, h: 40 }, teachers: 8, speed: 1.4, collectibles: 40, schoolType: 'university' }
        ];

        // Game mode
        let gameMode = 'freeplay'; // 'freeplay' or 'campaign' or 'multiplayer'
        let currentLevel = 0; // 0-indexed
        let totalCampaignScore = 0; // Total score across all levels in campaign

        // ============================================
        // MULTIPLAYER SYSTEM (Liveblocks)
        // ============================================

        // Multiplayer state
        let mpState = {
            active: false,
            isHost: false,
            roomCode: null,
            room: null,
            leaveRoom: null,
            myConnectionId: null,
            hostConnectionId: null,
            playerName: 'Player',
            playerColor: '#ff6b6b',
            otherPlayers: new Map(), // connectionId -> player data
            mapSeed: null,
            gameSettings: { mapSize: 'medium', teacherCount: 4 },
            lastPresenceUpdate: 0
        };

        // Player colors for multiplayer
        const PLAYER_COLORS = [
            '#ff6b6b', '#4ade80', '#60a5fa', '#fbbf24',
            '#a78bfa', '#f472b6', '#34d399', '#fb923c'
        ];

        // Liveblocks client
        let liveblocksClient = null;
        let liveblocksModule = null;
        let liveblocksLoading = null;

        // Initialize Liveblocks client (async - loads module from CDN)
        async function initLiveblocks() {
            if (liveblocksClient) return true;

            // If already loading, wait for it
            if (liveblocksLoading) {
                return liveblocksLoading;
            }

            liveblocksLoading = (async () => {
                try {
                    // Dynamically import Liveblocks from esm.sh CDN
                    liveblocksModule = await import('https://esm.sh/@liveblocks/client@2.15.0');

                    liveblocksClient = liveblocksModule.createClient({
                        publicApiKey: "pk_dev_7IfGTE86kE-WZ2BCeeK1dG0dNKHgPkbZsiCN0tOGMEiByC_gNuubIGBWxl4UCJsx",
                    });
                    console.log('Liveblocks client initialized');
                    return true;
                } catch (e) {
                    console.error('Failed to initialize Liveblocks:', e);
                    liveblocksLoading = null;
                    return false;
                }
            })();

            return liveblocksLoading;
        }

        // Generate a random room code
        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 3; i++) {
                code += chars[Math.floor(Math.random() * chars.length)];
            }
            return code;
        }

        // Generate a random funny player name based on current language
        function generatePlayerName() {
            const funnyNames = {
                en: {
                    adjectives: ['Homework-Eating', 'Chalk-Dusted', 'Detention-Dodging', 'Cafeteria-Lurking', 'Tardy', 'Sleepy', 'Snack-Hoarding', 'Doodling', 'Note-Passing', 'Backpack-Dragging'],
                    nouns: ['Troublemaker', 'Prankster', 'Napper', 'Daydreamer', 'Scribbler', 'Snacker', 'Wanderer', 'Doodler', 'Whisperer', 'Yawner']
                },
                et: {
                    adjectives: ['Kodut√∂√∂-S√∂√∂v', 'Kriidine', 'Hilinev', 'Unine', 'N√§ksiv', 'Joonistav', 'Sosistav', 'Haigutav', 'Sohisev', 'Pabistav'],
                    nouns: ['Pahandustegija', 'Naljahambas', 'Uinuja', 'Unistaja', 'Kritseldaja', 'N√§ksija', 'Uitaja', 'Sosistaja', 'Haigutaja', 'Pomiseja']
                },
                lv: {
                    adjectives: ['MƒÅjasdarbu-ƒído≈°s', 'Krƒ´tains', 'Kavƒìjo≈°s', 'Miegains', 'Uzkodas-KrƒÅjo≈°s', 'Zƒ´mƒìjo≈°s', 'ƒåuksto≈°s', '≈ΩƒÅvƒÅjo≈°s', 'Sap≈Üojo≈°s', 'Slinkojo≈°s'],
                    nouns: ['NerƒÅtnis', 'Jokdaris', 'Snaudƒìjs', 'Sap≈ÜotƒÅjs', 'SkricelƒìtƒÅjs', 'Na≈°ƒ∑otƒÅjs', 'Klai≈ÜotƒÅjs', 'ƒåukstƒìtƒÅjs', '≈ΩƒÅvƒÅtƒÅjs', 'MurmulƒìtƒÅjs']
                },
                lt: {
                    adjectives: ['Nam≈≥-Darb≈≥-Valgantis', 'Kreidos', 'Vƒóluojantis', 'Mieguistas', 'U≈ækand≈æi≈≥-Kaupiantis', 'Pie≈°iantis', '≈†nib≈ædantis', '≈Ωiovuojantis', 'Svajojantis', 'Tingintis'],
                    nouns: ['I≈°dykƒólis', 'Pok≈°tininkas', 'Sn≈´duriuotojas', 'Svajotojas', 'Rai≈æytojas', 'U≈ækand≈æiautojas', 'Bast≈´nas', '≈†nib≈ædƒótojas', '≈Ωiovuliukas', 'Murmƒótojas']
                },
                ru: {
                    adjectives: ['–î–æ–º–∞—à–∫—É-–ñ—É—é—â–∏–π', '–ú–µ–ª–æ–º-–ò—Å–ø–∞—á–∫–∞–Ω–Ω—ã–π', '–í–µ—á–Ω–æ-–û–ø–∞–∑–¥—ã–≤–∞—é—â–∏–π', '–°–æ–Ω–Ω—ã–π', '–°–Ω–µ–∫–∏-–ü—Ä—è—á—É—â–∏–π', '–†–∏—Å—É—é—â–∏–π', '–®–µ–ø—á—É—â–∏–π', '–ó–µ–≤–∞—é—â–∏–π', '–ú–µ—á—Ç–∞—é—â–∏–π', '–õ–µ–Ω–∏–≤—ã–π'],
                    nouns: ['–•—É–ª–∏–≥–∞–Ω', '–®—É—Ç–Ω–∏–∫', '–°–æ–Ω—è', '–ú–µ—á—Ç–∞—Ç–µ–ª—å', '–ö–∞—Ä–∞–∫—É–ª–∏—Å—Ç', '–û–±–∂–æ—Ä–∞', '–ë—Ä–æ–¥—è–≥–∞', '–®–µ–ø—Ç—É–Ω', '–ó–µ–≤–∞–∫–∞', '–ë–æ—Ä–º–æ—Ç—É–Ω']
                }
            };

            const lang = settings.language || 'en';
            const names = funnyNames[lang] || funnyNames.en;
            const adjective = names.adjectives[Math.floor(Math.random() * names.adjectives.length)];
            const noun = names.nouns[Math.floor(Math.random() * names.nouns.length)];

            // For languages with compound adjectives (hyphenated), use space; otherwise concatenate
            if (adjective.includes('-') || lang !== 'en') {
                return adjective + ' ' + noun;
            }
            return adjective + noun;
        }

        // Create a multiplayer room (host)
        async function createMultiplayerRoom() {
            updateConnectionStatus('mp-connection-status', 'connecting', t('connecting'));

            const success = await initLiveblocks();
            if (!success || !liveblocksClient) {
                updateConnectionStatus('mp-connection-status', 'error', t('connectionError'));
                return;
            }

            mpState.roomCode = generateRoomCode();
            mpState.isHost = true;
            mpState.playerName = generatePlayerName();
            mpState.playerColor = PLAYER_COLORS[0];
            mpState.mapSeed = Math.floor(Math.random() * 1000000);

            document.getElementById('host-room-code').textContent = mpState.roomCode;
            updateConnectionStatus('mp-connection-status', 'connecting', t('connecting'));

            try {
                const roomId = `school-escape-${mpState.roomCode.toLowerCase()}`;
                const { room, leave } = liveblocksClient.enterRoom(roomId, {
                    initialPresence: {
                        name: mpState.playerName,
                        color: mpState.playerColor,
                        x: 0, y: 0,
                        vx: 0, vy: 0,
                        direction: 0,
                        isDashing: false,
                        invincible: false,
                        lives: 3,
                        isAlive: true,
                        isHost: true,
                        ready: false
                    }
                });

                mpState.room = room;
                mpState.leaveRoom = leave;

                // Wait for connection
                room.subscribe('status', (status) => {
                    console.log('Room status:', status);
                    if (status === 'connected') {
                        const self = room.getSelf();
                        mpState.myConnectionId = self?.connectionId;
                        mpState.hostConnectionId = self?.connectionId;
                        updateConnectionStatus('mp-connection-status', 'connected', t('connected'));
                        updateHostPlayerList();
                    } else if (status === 'reconnecting') {
                        updateConnectionStatus('mp-connection-status', 'connecting', t('connecting'));
                    }
                });

                // Subscribe to others joining/leaving
                room.subscribe('others', (others, event) => {
                    console.log('Others update:', others.length, event);
                    updateHostPlayerList();

                    if (event?.type === 'enter') {
                        playSound('collect');
                    } else if (event?.type === 'leave') {
                        playSound('menu_click');
                    }
                });

                // Subscribe to broadcast events
                room.subscribe('event', handleMultiplayerEvent);

                mpState.active = true;

            } catch (e) {
                console.error('Failed to create room:', e);
                updateConnectionStatus('mp-connection-status', 'error', t('connectionError'));
            }
        }

        // Join a multiplayer room
        async function joinMultiplayerRoom(code) {
            updateConnectionStatus('join-connection-status', 'connecting', t('connecting'));

            const success = await initLiveblocks();
            if (!success || !liveblocksClient) {
                updateConnectionStatus('join-connection-status', 'error', t('connectionError'));
                return false;
            }

            mpState.roomCode = code.toUpperCase();
            mpState.isHost = false;
            mpState.playerName = generatePlayerName();
            mpState.playerColor = PLAYER_COLORS[Math.floor(Math.random() * PLAYER_COLORS.length)];

            try {
                const roomId = `school-escape-${mpState.roomCode.toLowerCase()}`;
                const { room, leave } = liveblocksClient.enterRoom(roomId, {
                    initialPresence: {
                        name: mpState.playerName,
                        color: mpState.playerColor,
                        x: 0, y: 0,
                        vx: 0, vy: 0,
                        direction: 0,
                        isDashing: false,
                        invincible: false,
                        lives: 3,
                        isAlive: true,
                        isHost: false,
                        ready: false
                    }
                });

                mpState.room = room;
                mpState.leaveRoom = leave;

                // Subscribe to broadcast events IMMEDIATELY
                room.subscribe('event', (eventData) => {
                    console.log('Guest received event:', eventData);
                    handleMultiplayerEvent(eventData);
                });

                // Subscribe to others for player list updates
                room.subscribe('others', () => {
                    if (mpState.active) {
                        updateLobbyPlayerList();
                    }
                });

                // Wait for connection and find host
                return new Promise((resolve) => {
                    let connectionTimeout = setTimeout(() => {
                        updateConnectionStatus('join-connection-status', 'error', 'Room not found');
                        leaveMultiplayerRoom();
                        resolve(false);
                    }, 5000);

                    room.subscribe('status', (status) => {
                        console.log('Guest room status:', status);
                        if (status === 'connected') {
                            const self = room.getSelf();
                            mpState.myConnectionId = self?.connectionId;
                            mpState.active = true;

                            // Check if there's a host
                            const checkForHost = () => {
                                const others = room.getOthers();
                                console.log('Looking for host, others:', others.length);
                                const host = others.find(o => o.presence?.isHost);
                                if (host) {
                                    mpState.hostConnectionId = host.connectionId;
                                    clearTimeout(connectionTimeout);
                                    updateConnectionStatus('join-connection-status', 'connected', t('connected'));
                                    document.getElementById('lobby-room-code').textContent = mpState.roomCode;
                                    showMenu('multiplayer-lobby-screen');
                                    updateLobbyPlayerList();
                                    resolve(true);
                                    return true;
                                }
                                return false;
                            };

                            // Try immediately, then retry after a delay
                            if (!checkForHost()) {
                                setTimeout(() => {
                                    if (!checkForHost()) {
                                        // Keep waiting - host might join later
                                        console.log('No host yet, waiting...');
                                    }
                                }, 1000);
                            }
                        }
                    });
                });

            } catch (e) {
                console.error('Failed to join room:', e);
                updateConnectionStatus('join-connection-status', 'error', t('connectionError'));
                return false;
            }
        }

        // Leave the multiplayer room
        function leaveMultiplayerRoom() {
            if (mpState.leaveRoom) {
                mpState.leaveRoom();
            }
            mpState.active = false;
            mpState.room = null;
            mpState.leaveRoom = null;
            mpState.isHost = false;
            mpState.roomCode = null;
            mpState.hostConnectionId = null;
            mpState.otherPlayers.clear();

            // Hide multiplayer HUD
            document.getElementById('multiplayer-players-hud').style.display = 'none';
        }

        // Handle broadcast events from other players
        function handleMultiplayerEvent({ event, user, connectionId }) {
            console.log('handleMultiplayerEvent called:', event);

            if (!event || !event.type) {
                console.warn('Invalid event received:', event);
                return;
            }

            switch (event.type) {
                case 'GAME_START':
                    console.log('GAME_START received! isHost:', mpState.isHost);
                    // Only guests should respond to this - receive map from host
                    if (!mpState.isHost && event.mapData) {
                        console.log('Guest receiving map data from host');
                        mpState.gameSettings = event.settings;
                        startMultiplayerGameAsGuest(event.mapData);
                    }
                    break;

                case 'COLLECTIBLE_PICKED':
                    // Someone collected an item
                    if (connectionId !== mpState.myConnectionId) {
                        const item = gameState.collectibles.find(c => c.id === event.itemId);
                        if (item && !item.collected) {
                            item.collected = true;
                            updateUI();
                            playSound('collect');
                        }
                    }
                    break;

                case 'POWERUP_COLLECTED':
                    // Someone collected a powerup
                    if (connectionId !== mpState.myConnectionId) {
                        const powerup = gameState.powerups.find(p => p.id === event.powerupId);
                        if (powerup && !powerup.collected) {
                            powerup.collected = true;
                        }
                    }
                    break;

                case 'STINK_BOMB':
                    // Stink bomb used - stun teachers
                    stunAllTeachers();
                    showMessage(t('stinkBombMsg'));
                    playSound('stinkbomb');
                    break;

                case 'TEACHER_POSITIONS':
                    // Host is broadcasting teacher positions
                    if (!mpState.isHost && event.teachers) {
                        updateTeachersFromHost(event.teachers);
                    }
                    break;

                case 'LEVEL_COMPLETE':
                    // Level completed - show with multiplayer scores
                    if (!mpState.isHost) {
                        showLevelCompleteScreen(event.scores);
                    }
                    break;

                case 'GAME_OVER':
                    // Game over - show with multiplayer scores
                    if (!mpState.isHost) {
                        showMultiplayerGameOverScreen(event.won, event.scores);
                    }
                    break;
            }
        }

        // Update teachers from host broadcast
        function updateTeachersFromHost(teacherData) {
            for (const data of teacherData) {
                const teacher = teachers.find(t => t.id === data.id);
                if (teacher) {
                    teacher.x = data.x;
                    teacher.y = data.y;
                    teacher.direction = data.direction;
                    teacher.seesPlayer = data.seesPlayer;
                    teacher.stunned = data.stunned;
                }
            }
        }

        // Stun all teachers (for stink bomb)
        function stunAllTeachers() {
            for (const teacher of teachers) {
                teacher.stunned = true;
                teacher.stunnedTimer = 4;
            }
        }

        // Update connection status display
        function updateConnectionStatus(elementId, status, text) {
            const el = document.getElementById(elementId);
            if (el) {
                el.textContent = text;
                el.className = 'multiplayer-status ' + status;
            }
        }

        // Update host's player list
        function updateHostPlayerList() {
            if (!mpState.room) return;

            const container = document.getElementById('host-player-list');
            const self = mpState.room.getSelf();
            const others = mpState.room.getOthers();

            let html = '';

            // Add self (host)
            if (self) {
                html += createPlayerListItem(self.presence, true, true);
            }

            // Add others
            for (const other of others) {
                if (other.presence) {
                    html += createPlayerListItem(other.presence, false, false);
                }
            }

            container.innerHTML = html || `<p style="color: #aaa; text-align: center;">${t('waitingForPlayers')}</p>`;
        }

        // Update lobby player list (for non-host)
        function updateLobbyPlayerList() {
            if (!mpState.room) return;

            const container = document.getElementById('lobby-player-list');
            const self = mpState.room.getSelf();
            const others = mpState.room.getOthers();

            let html = '';

            // Add host first (find in others)
            const host = others.find(o => o.presence?.isHost);
            if (host) {
                html += createPlayerListItem(host.presence, false, true);
            }

            // Add self
            if (self) {
                html += createPlayerListItem(self.presence, true, false);
            }

            // Add other non-host players
            for (const other of others) {
                if (other.presence && !other.presence.isHost) {
                    html += createPlayerListItem(other.presence, false, false);
                }
            }

            container.innerHTML = html;
        }

        // Create HTML for a player list item
        function createPlayerListItem(presence, isYou, isHost) {
            return `
                <div class="player-item">
                    <div class="player-color" style="background: ${presence.color}"></div>
                    <span class="player-name">${presence.name}</span>
                    ${isHost ? `<span class="player-host-badge">${t('host')}</span>` : ''}
                    ${isYou ? `<span class="player-you-badge">${t('you')}</span>` : ''}
                </div>
            `;
        }

        // Start multiplayer game as guest (receives map from host)
        function startMultiplayerGameAsGuest(mapData) {
            gameMode = 'multiplayer';

            // Apply game settings
            settings.mapSize = mpState.gameSettings.mapSize;
            settings.teacherCount = mpState.gameSettings.teacherCount;

            // Start the game (will generate a temporary map)
            hideAllMenus();
            startGame();

            // Apply the map data received from host (overwrites generated map)
            applyMapData(mapData);

            // Show multiplayer HUD
            document.getElementById('multiplayer-players-hud').style.display = 'block';
            updateMultiplayerHUD();
        }

        // Host broadcasts game start
        function hostStartGame() {
            if (!mpState.room || !mpState.isHost) return;

            mpState.gameSettings = {
                mapSize: document.getElementById('mp-map-size').value,
                teacherCount: parseInt(document.getElementById('mp-teacher-count').value)
            };

            console.log('Host starting game and generating map...');

            // Start game for host first (this generates the map)
            startMultiplayerGameAsHost();

            // Small delay to ensure map is generated, then broadcast map data to all clients
            setTimeout(() => {
                const mapData = serializeMapData();
                console.log('Host broadcasting GAME_START with map data to guests');

                mpState.room.broadcastEvent({
                    type: 'GAME_START',
                    mapData: mapData,
                    settings: mpState.gameSettings
                });
            }, 100);
        }

        // Start multiplayer game as host (generates map)
        function startMultiplayerGameAsHost() {
            gameMode = 'multiplayer';

            // Apply game settings
            settings.mapSize = mpState.gameSettings.mapSize;
            settings.teacherCount = mpState.gameSettings.teacherCount;

            // Start the game (generates map)
            hideAllMenus();
            startGame();

            // Show multiplayer HUD
            document.getElementById('multiplayer-players-hud').style.display = 'block';
            updateMultiplayerHUD();
        }

        // Update my presence (called in game loop)
        function updateMyPresence() {
            if (!mpState.active || !mpState.room) return;

            // Throttle presence updates to ~30fps
            const now = Date.now();
            if (now - mpState.lastPresenceUpdate < 33) return;
            mpState.lastPresenceUpdate = now;

            mpState.room.updatePresence({
                x: player.x,
                y: player.y,
                vx: player.vx,
                vy: player.vy,
                direction: player.direction,
                isDashing: player.isDashing,
                invincible: player.invincible,
                lives: gameState.lives,
                isAlive: gameState.lives > 0,
                score: gameState.score
            });
        }

        // Host broadcasts teacher positions
        function broadcastTeacherPositions() {
            if (!mpState.active || !mpState.room || !mpState.isHost) return;

            const teacherData = teachers.map(t => ({
                id: t.id,
                x: t.x,
                y: t.y,
                direction: t.direction,
                seesPlayer: t.seesPlayer,
                stunned: t.stunned
            }));

            mpState.room.broadcastEvent({
                type: 'TEACHER_POSITIONS',
                teachers: teacherData
            });
        }

        // Broadcast collectible pickup
        function broadcastCollectiblePickup(itemId) {
            if (!mpState.active || !mpState.room) return;

            mpState.room.broadcastEvent({
                type: 'COLLECTIBLE_PICKED',
                itemId: itemId
            });
        }

        // Broadcast powerup pickup
        function broadcastPowerupPickup(powerupId) {
            if (!mpState.active || !mpState.room) return;

            mpState.room.broadcastEvent({
                type: 'POWERUP_COLLECTED',
                powerupId: powerupId
            });
        }

        // Broadcast stink bomb
        function broadcastStinkBomb() {
            if (!mpState.active || !mpState.room) return;

            mpState.room.broadcastEvent({
                type: 'STINK_BOMB'
            });
        }

        // Serialize map data for sharing
        function serializeMapData() {
            return {
                map: gameState.map,
                mapWidth: gameState.mapWidth,
                mapHeight: gameState.mapHeight,
                collectibles: gameState.collectibles.map(c => ({
                    id: c.id,
                    x: c.x,
                    y: c.y,
                    gridX: c.gridX,
                    gridY: c.gridY,
                    collected: c.collected,
                    animOffset: c.animOffset
                })),
                powerups: gameState.powerups.map(p => ({
                    id: p.id,
                    x: p.x,
                    y: p.y,
                    gridX: p.gridX,
                    gridY: p.gridY,
                    type: p.type,
                    collected: p.collected,
                    animOffset: p.animOffset
                })),
                player: {
                    x: player.x,
                    y: player.y,
                    gridX: player.gridX,
                    gridY: player.gridY
                },
                teachers: teachers.map(t => ({
                    id: t.id,
                    x: t.x,
                    y: t.y,
                    type: t.type,
                    direction: t.direction,
                    speed: t.speed,
                    patrolPath: t.patrolPath
                }))
            };
        }

        // Apply received map data from host
        function applyMapData(mapData) {
            console.log('Applying map data from host:', mapData);

            // Apply map
            gameState.map = mapData.map;
            gameState.mapWidth = mapData.mapWidth;
            gameState.mapHeight = mapData.mapHeight;

            // Apply collectibles
            gameState.collectibles = mapData.collectibles.map(c => ({
                ...c,
                collected: false,
                animOffset: c.animOffset ?? Math.random() * Math.PI * 2
            }));

            // Apply powerups
            gameState.powerups = mapData.powerups.map(p => ({
                ...p,
                collected: false,
                animOffset: p.animOffset ?? Math.random() * Math.PI * 2
            }));

            // Apply player position
            player.x = mapData.player.x;
            player.y = mapData.player.y;
            player.gridX = mapData.player.gridX;
            player.gridY = mapData.player.gridY;

            // Apply teachers - create full teacher objects with all required fields
            teachers.length = 0;
            mapData.teachers.forEach(t => {
                teachers.push({
                    id: t.id,
                    x: t.x,
                    y: t.y,
                    vx: 0,
                    vy: 0,
                    speed: t.speed,
                    type: t.type,
                    direction: t.direction,
                    patrolTimer: 0,
                    chaseTimer: 0,
                    stunned: false,
                    stunnedTimer: 0,
                    seesPlayer: false,
                    animFrame: 0,
                    patrolPath: t.patrolPath || []
                });
            });

            console.log('Map data applied successfully, teachers:', teachers.length);
        }

        // Get all player scores (self and others)
        function getAllPlayerScores() {
            if (!mpState.active || !mpState.room) return [];

            const scores = [];
            const self = mpState.room.getSelf();
            const others = mpState.room.getOthers();

            // Add self
            if (self?.presence) {
                scores.push({
                    name: self.presence.name,
                    color: self.presence.color,
                    score: gameState.score, // Use current gameState score for self
                    isSelf: true
                });
            }

            // Add others
            for (const other of others) {
                if (other.presence) {
                    scores.push({
                        name: other.presence.name,
                        color: other.presence.color,
                        score: other.presence.score || 0,
                        isSelf: false
                    });
                }
            }

            // Sort by score descending
            scores.sort((a, b) => b.score - a.score);
            return scores;
        }

        // Broadcast game over event with scores
        function broadcastGameOver(won, scores) {
            if (!mpState.active || !mpState.room) return;

            mpState.room.broadcastEvent({
                type: 'GAME_OVER',
                won: won,
                scores: scores
            });
        }

        // Broadcast level complete event with scores
        function broadcastLevelComplete(scores) {
            if (!mpState.active || !mpState.room) return;

            mpState.room.broadcastEvent({
                type: 'LEVEL_COMPLETE',
                scores: scores
            });
        }

        // Update multiplayer HUD during game
        function updateMultiplayerHUD() {
            if (!mpState.active || !mpState.room) return;

            const container = document.getElementById('multiplayer-players-hud');
            const self = mpState.room.getSelf();
            const others = mpState.room.getOthers();

            let html = `<div style="font-size: 12px; color: #aaa; margin-bottom: 5px;">${t('players')}</div>`;

            // Add self
            if (self?.presence) {
                html += `
                    <div class="mp-player-hud-item">
                        <div class="mp-player-hud-color" style="background: ${self.presence.color}"></div>
                        <span>${self.presence.name}</span>
                        <span class="mp-player-hud-lives">‚ù§${gameState.lives}</span>
                    </div>
                `;
            }

            // Add others
            for (const other of others) {
                if (other.presence) {
                    html += `
                        <div class="mp-player-hud-item">
                            <div class="mp-player-hud-color" style="background: ${other.presence.color}"></div>
                            <span>${other.presence.name}</span>
                            <span class="mp-player-hud-lives">‚ù§${other.presence.lives || 0}</span>
                        </div>
                    `;
                }
            }

            container.innerHTML = html;
        }

        // Draw other players on the canvas
        function drawOtherPlayers() {
            if (!mpState.active || !mpState.room) return;

            const others = mpState.room.getOthers();

            for (const other of others) {
                if (!other.presence || !other.presence.isAlive) continue;

                const p = other.presence;

                // Use presence position directly (world coordinates)
                // Camera transform is already applied via ctx.translate in render()
                const worldX = p.x;
                const worldY = p.y;

                // Skip if off screen
                const viewX = worldX - gameState.camera.x;
                const viewY = worldY - gameState.camera.y;
                if (viewX < -50 || viewX > canvas.width + 50 ||
                    viewY < -50 || viewY > canvas.height + 50) continue;

                ctx.save();
                ctx.translate(worldX, worldY);

                // Draw dash trail
                if (p.isDashing) {
                    ctx.fillStyle = p.color + '40';
                    ctx.beginPath();
                    ctx.arc(-5, 0, 15, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Invincibility effect
                if (p.invincible) {
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.3;
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 15;
                }

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(0, PLAYER_SIZE / 2 - 5, PLAYER_SIZE / 2, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Body (colored circle)
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(0, 0, PLAYER_SIZE / 2, 0, Math.PI * 2);
                ctx.fill();

                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Eyes
                const eyeOffsetX = p.direction === 0 ? 4 : (p.direction === 2 ? -4 : 0);
                const eyeOffsetY = p.direction === 1 ? 4 : (p.direction === 3 ? -4 : 0);

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-4 + eyeOffsetX, -3 + eyeOffsetY, 4, 0, Math.PI * 2);
                ctx.arc(4 + eyeOffsetX, -3 + eyeOffsetY, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(-4 + eyeOffsetX * 1.5, -3 + eyeOffsetY * 1.5, 2, 0, Math.PI * 2);
                ctx.arc(4 + eyeOffsetX * 1.5, -3 + eyeOffsetY * 1.5, 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // Draw name above player
                ctx.save();
                ctx.fillStyle = p.color;
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(p.name, worldX, worldY - PLAYER_SIZE / 2 - 8);
                ctx.restore();
            }
        }

        // ============================================
        // TRANSLATIONS
        // ============================================

        const translations = {
            en: {
                // Main Menu
                title: 'SCHOOL ESCAPE',
                subtitle: 'Escape the Teachers!',
                startGame: 'START GAME',
                howToPlay: 'HOW TO PLAY',
                backToMenu: 'BACK TO MENU',

                // Settings
                schoolType: 'School Type:',
                elementary: 'Elementary (Easy)',
                middleSchool: 'Middle School (Medium)',
                highSchool: 'High School (Hard)',
                university: 'University (Expert)',
                mapSize: 'Map Size:',
                small: 'Small',
                medium: 'Medium',
                large: 'Large',
                teachers: 'Teachers:',
                language: 'Language:',
                soundOn: 'üîä Sound: ON',
                soundOff: 'üîá Sound: OFF',
                musicOn: 'üéµ Music: ON',
                musicOff: 'üéµ Music: OFF',

                // Game UI
                score: 'Score',
                combo: 'Combo',
                level: 'Level',
                items: 'Items',
                move: 'Move',
                dash: 'Dash',
                usePowerup: 'Use Power-up',
                pause: 'Pause',

                // Power-ups
                hallPass: 'Hall Pass',
                energyDrink: 'Energy Drink',
                stinkBomb: 'Stink Bomb',
                skateboard: 'Skateboard',

                // How To Play
                objective: 'OBJECTIVE:',
                objectiveText: 'Collect all homework pages and reach the exit without getting caught by teachers!',
                controls: 'CONTROLS:',
                controlMove: 'WASD or Arrow Keys - Move',
                controlDash: 'SPACE - Dash (quick burst of speed)',
                controlPowerup: '1, 2, 3 - Use collected power-ups',
                controlPause: 'ESC - Pause game',
                powerups: 'POWER-UPS:',
                hallPassDesc: 'Hall Pass - Temporary invincibility',
                energyDrinkDesc: 'Energy Drink - Super speed',
                stinkBombDesc: 'Stink Bomb - Stuns nearby teachers',
                skateboardDesc: 'Skateboard - Fast movement',
                teachersTitle: 'TEACHERS:',
                patrolDesc: 'Patrol Teacher - Follows set routes',
                hunterDesc: 'Hunter Teacher - Actively chases you',
                fastDesc: 'Fast Teacher - Quick but predictable',
                mapTiles: 'MAP TILES:',
                floorDesc: 'Floor - Walkable area',
                wallDesc: 'Wall - Cannot pass through',
                deskDesc: 'Desk - Classroom obstacle',
                lockerDesc: 'Locker - Corridor obstacle',
                wetFloorDesc: 'Wet Floor - Slippery surface',
                exitDesc: 'Exit - Escape here (green when unlocked)',

                // Teacher labels
                patrol: 'PATROL',
                hunter: 'HUNTER',
                fast: 'FAST',

                // Pause Screen
                paused: 'PAUSED',
                resume: 'RESUME',
                quitToMenu: 'QUIT TO MENU',

                // Game Over
                escaped: 'ESCAPED!',
                caught: 'CAUGHT!',
                gameOver: 'GAME OVER',
                playAgain: 'PLAY AGAIN',
                mainMenu: 'MAIN MENU',
                itemsCollected: 'Items',
                livesRemaining: 'Lives remaining',

                // In-game messages
                escape: 'ESCAPE!',
                invincible: 'INVINCIBLE!',
                speedBoost: 'SPEED BOOST!',
                stinkBombMsg: 'STINK BOMB!',
                skateboardMsg: 'SKATEBOARD!',
                caughtMsg: 'CAUGHT!',
                livesLeft: 'lives left',
                got: 'Got',

                // Game modes
                freePlay: 'FREE PLAY',
                freeplaySettings: 'Free Play Settings',
                campaign: 'CAMPAIGN',
                selectMode: 'Select Mode',
                continueGame: 'CONTINUE',
                newGame: 'NEW GAME',

                // Level names
                grade1: 'Grade 1',
                grade2: 'Grade 2',
                grade3: 'Grade 3',
                grade4: 'Grade 4',
                grade5: 'Grade 5',
                grade6: 'Grade 6',
                grade7: 'Grade 7',
                grade8: 'Grade 8',
                grade9: 'Grade 9',
                gymnasium1: 'Gymnasium I',
                gymnasium2: 'Gymnasium II',
                gymnasium3: 'Gymnasium III',
                bachelor1: 'Bachelor Year 1',
                bachelor2: 'Bachelor Year 2',
                bachelor3: 'Bachelor Year 3',
                master1: 'Master Year 1',
                master2: 'Master Year 2',

                // Level complete
                levelComplete: 'LEVEL COMPLETE!',
                nextLevel: 'NEXT LEVEL',
                graduated: 'GRADUATED!',
                graduatedMsg: 'Congratulations! You have completed all levels!',
                levelProgress: 'Progress',
                currentLevel: 'Current Level',
                completed: 'completed',
                totalScore: 'Total Score',
                campaign: 'CAMPAIGN',
                freePlay: 'FREE PLAY',

                // Random Events
                eventsOn: 'üé≤ Events: ON',
                eventsOff: 'üé≤ Events: OFF',
                eventEnded: 'Event ended',
                ufoAbduction: 'UFO Abduction',
                dinosaurStampede: 'Dinosaur Stampede',
                parentsVisiting: 'Parents Visiting',
                fireDrill: 'Fire Drill',
                principalInspection: 'Principal Inspection',
                powerOutage: 'Power Outage',
                foodFight: 'Food Fight',
                superheroStudent: 'Superhero Mode',
                ghostJanitor: 'Ghost Janitor',
                timeFreeze: 'Time Freeze',
                earthquake: 'Earthquake',
                pizzaDelivery: 'Pizza Delivery',

                // Map Generation Settings
                mapConfigTitle: 'Map Configuration',
                mapTopology: 'Map Layout:',
                topologyGrid: 'Grid (Classic)',
                topologyLabyrinth: 'Labyrinth (Maze)',
                topologyCorridors: 'Many Corridors',
                topologyOpenPlan: 'Open Plan',
                corridorDensity: 'Corridor Density:',
                densityLow: 'Low',
                densityMedium: 'Medium',
                densityHigh: 'High',
                roomDensity: 'Room Density:',
                roomsFew: 'Few Rooms',
                roomsNormal: 'Normal',
                roomsMany: 'Many Rooms',

                // Multiplayer
                multiplayer: 'MULTIPLAYER',
                multiplayerDesc: 'Play with friends online!',
                createRoom: 'CREATE ROOM',
                joinRoom: 'JOIN ROOM',
                roomCode: 'Room Code',
                yourRoomCode: 'Your Room Code:',
                enterRoomCode: 'Enter Room Code:',
                shareCode: 'Share this code with your friends',
                waitingForPlayers: 'Waiting for players...',
                waitingForHost: 'Waiting for host to start the game...',
                host: 'HOST',
                you: 'YOU',
                startGameMp: 'START GAME',
                leaveRoom: 'LEAVE',
                cancel: 'CANCEL',
                back: 'BACK',
                join: 'JOIN',
                connecting: 'Connecting...',
                connected: 'Connected!',
                connectionError: 'Connection error',
                playerJoined: 'joined the game',
                playerLeft: 'left the game',
                gameLobby: 'GAME LOBBY',
                players: 'Players'
            },

            et: {
                // Main Menu
                title: 'KOOLIST P√ïGENEMINE',
                subtitle: 'P√µgene √µpetajate eest!',
                startGame: 'ALUSTA M√ÑNGU',
                howToPlay: 'KUIDAS M√ÑNGIDA',
                backToMenu: 'TAGASI MEN√ú√úSSE',

                // Settings
                schoolType: 'Kooli t√º√ºp:',
                elementary: 'Algkool (Lihtne)',
                middleSchool: 'P√µhikool (Keskmine)',
                highSchool: 'G√ºmnaasium (Raske)',
                university: '√úlikool (Ekspert)',
                mapSize: 'Kaardi suurus:',
                small: 'V√§ike',
                medium: 'Keskmine',
                large: 'Suur',
                teachers: '√ïpetajad:',
                language: 'Keel:',
                soundOn: 'üîä Heli: SEES',
                soundOff: 'üîá Heli: V√ÑLJAS',
                musicOn: 'üéµ Muusika: SEES',
                musicOff: 'üéµ Muusika: V√ÑLJAS',

                // Game UI
                score: 'Skoor',
                combo: 'Kombo',
                level: 'Tase',
                items: 'Esemed',
                move: 'Liigu',
                dash: 'Spurdi',
                usePowerup: 'Kasuta v√µimendust',
                pause: 'Paus',

                // Power-ups
                hallPass: 'Koridoriluba',
                energyDrink: 'Energiajook',
                stinkBomb: 'Haisupomm',
                skateboard: 'Rula',

                // How To Play
                objective: 'EESM√ÑRK:',
                objectiveText: 'Kogu k√µik kodut√∂√∂ lehed ja j√µua v√§ljap√§√§suni ilma √µpetajate k√§tte j√§√§mata!',
                controls: 'JUHTIMINE:',
                controlMove: 'WASD v√µi Nooleklahvid - Liigu',
                controlDash: 'T√úHIK - Spurdi (kiire kiirendus)',
                controlPowerup: '1, 2, 3 - Kasuta kogutud v√µimendusi',
                controlPause: 'ESC - Peata m√§ng',
                powerups: 'V√ïIMENDUSED:',
                hallPassDesc: 'Koridoriluba - Ajutine puutumatus',
                energyDrinkDesc: 'Energiajook - Superkiirus',
                stinkBombDesc: 'Haisupomm - Uimastab l√§hedal olevad √µpetajad',
                skateboardDesc: 'Rula - Kiire liikumine',
                teachersTitle: '√ïPETAJAD:',
                patrolDesc: 'Patrull√µpetaja - J√§rgib kindlaid marsruute',
                hunterDesc: 'Jahtija-√µpetaja - J√§litab sind aktiivselt',
                fastDesc: 'Kiire √µpetaja - Kiire, kuid etteaimatav',
                mapTiles: 'KAARDI PLOKID:',
                floorDesc: 'P√µrand - K√µnnitav ala',
                wallDesc: 'Sein - Ei saa l√§bi minna',
                deskDesc: 'Laud - Klassiruumi takistus',
                lockerDesc: 'Kapp - Koridori takistus',
                wetFloorDesc: 'M√§rg p√µrand - Libe pind',
                exitDesc: 'V√§ljap√§√§s - P√µgene siit (roheline kui avatud)',

                // Teacher labels
                patrol: 'PATRULL',
                hunter: 'JAHTIJA',
                fast: 'KIIRE',

                // Pause Screen
                paused: 'PEATATUD',
                resume: 'J√ÑTKA',
                quitToMenu: 'TAGASI MEN√ú√úSSE',

                // Game Over
                escaped: 'P√ïGENESID!',
                caught: 'TABATUD!',
                gameOver: 'M√ÑNG L√ÑBI',
                playAgain: 'M√ÑNGI UUESTI',
                mainMenu: 'PEAMEN√ú√ú',
                itemsCollected: 'Esemed',
                livesRemaining: 'Elusid j√§√§nud',

                // In-game messages
                escape: 'P√ïGENE!',
                invincible: 'PUUTUMATU!',
                speedBoost: 'KIIRUSE T√ïUS!',
                stinkBombMsg: 'HAISUPOMM!',
                skateboardMsg: 'RULA!',
                caughtMsg: 'TABATUD!',
                livesLeft: 'elu j√§√§nud',
                got: 'Said',

                // Game modes
                freePlay: 'VABAM√ÑNG',
                freeplaySettings: 'Vabam√§ngu seaded',
                campaign: 'KAMPAANIA',
                selectMode: 'Vali re≈æiim',
                continueGame: 'J√ÑTKA',
                newGame: 'UUS M√ÑNG',

                // Level names
                grade1: '1. klass',
                grade2: '2. klass',
                grade3: '3. klass',
                grade4: '4. klass',
                grade5: '5. klass',
                grade6: '6. klass',
                grade7: '7. klass',
                grade8: '8. klass',
                grade9: '9. klass',
                gymnasium1: 'G√ºmnaasium I',
                gymnasium2: 'G√ºmnaasium II',
                gymnasium3: 'G√ºmnaasium III',
                bachelor1: 'Bakalaureus 1. aasta',
                bachelor2: 'Bakalaureus 2. aasta',
                bachelor3: 'Bakalaureus 3. aasta',
                master1: 'Magister 1. aasta',
                master2: 'Magister 2. aasta',

                // Level complete
                levelComplete: 'TASE L√ÑBITUD!',
                nextLevel: 'J√ÑRGMINE TASE',
                graduated: 'L√ïPETASID!',
                graduatedMsg: 'Palju √µnne! Oled l√§binud k√µik tasemed!',
                levelProgress: 'Edenemine',
                currentLevel: 'Praegune tase',
                completed: 'l√§bitud',
                totalScore: 'Koguskoor',
                campaign: 'KAMPAANIA',
                freePlay: 'VABAM√ÑNG',

                // Random Events
                eventsOn: 'üé≤ S√ºndmused: SEES',
                eventsOff: 'üé≤ S√ºndmused: V√ÑLJAS',
                eventEnded: 'S√ºndmus l√µppes',
                ufoAbduction: 'UFO r√∂√∂vimine',
                dinosaurStampede: 'Dinosauruste tormakas',
                parentsVisiting: 'Vanemad k√ºlastavad',
                fireDrill: 'Tule√µppus',
                principalInspection: 'Direktori kontroll',
                powerOutage: 'Elektrikatkestus',
                foodFight: 'Toidulahing',
                superheroStudent: 'Superkangelase re≈æiim',
                ghostJanitor: 'Kummituskoristaja',
                timeFreeze: 'Aja peatumine',
                earthquake: 'Maav√§rin',
                pizzaDelivery: 'Pitsakuller',

                // Map Generation Settings
                mapConfigTitle: 'Kaardi seadistus',
                mapTopology: 'Kaardi paigutus:',
                topologyGrid: 'Ruudustik (Klassikaline)',
                topologyLabyrinth: 'Lab√ºrint (Eksitav)',
                topologyCorridors: 'Palju koridore',
                topologyOpenPlan: 'Avatud plaan',
                corridorDensity: 'Koridoride tihedus:',
                densityLow: 'Madal',
                densityMedium: 'Keskmine',
                densityHigh: 'K√µrge',
                roomDensity: 'Tubade tihedus:',
                roomsFew: 'V√§he tube',
                roomsNormal: 'Tavaline',
                roomsMany: 'Palju tube',

                // Multiplayer
                multiplayer: 'MITMIKM√ÑNG',
                multiplayerDesc: 'M√§ngi s√µpradega v√µrgus!',
                createRoom: 'LOO TUBA',
                joinRoom: 'LIITU TOAGA',
                roomCode: 'Toa kood',
                yourRoomCode: 'Sinu toa kood:',
                enterRoomCode: 'Sisesta toa kood:',
                shareCode: 'Jaga seda koodi s√µpradega',
                waitingForPlayers: 'Ootan m√§ngijaid...',
                waitingForHost: 'Ootan, kuni peremees alustab m√§ngu...',
                host: 'PEREMEES',
                you: 'SINA',
                startGameMp: 'ALUSTA M√ÑNGU',
                leaveRoom: 'LAHKU',
                cancel: 'T√úHISTA',
                back: 'TAGASI',
                join: 'LIITU',
                connecting: '√úhendan...',
                connected: '√úhendatud!',
                connectionError: '√úhenduse viga',
                playerJoined: 'liitus m√§nguga',
                playerLeft: 'lahkus m√§ngust',
                gameLobby: 'M√ÑNGU FUAJEE',
                players: 'M√§ngijad'
            },

            lv: {
                // Main Menu
                title: 'BƒíG≈†ANA NO SKOLAS',
                subtitle: 'Izbƒìdz no skolotƒÅjiem!',
                startGame: 'SƒÄKT SPƒíLI',
                howToPlay: 'KƒÄ SPƒíLƒíT',
                backToMenu: 'ATPAKAƒª UZ IZVƒíLNI',

                // Settings
                schoolType: 'Skolas tips:',
                elementary: 'Pamatskola (Viegli)',
                middleSchool: 'Vidusskola (Vidƒìji)',
                highSchool: 'ƒ¢imnƒÅzija (Gr≈´ti)',
                university: 'UniversitƒÅte (Eksperts)',
                mapSize: 'Kartes izmƒìrs:',
                small: 'Mazs',
                medium: 'Vidƒìjs',
                large: 'Liels',
                teachers: 'SkolotƒÅji:',
                language: 'Valoda:',
                soundOn: 'üîä Ska≈Üa: IESLƒíGTA',
                soundOff: 'üîá Ska≈Üa: IZSLƒíGTA',
                musicOn: 'üéµ M≈´zika: IESLƒíGTA',
                musicOff: 'üéµ M≈´zika: IZSLƒíGTA',

                // Game UI
                score: 'Punkti',
                combo: 'Kombo',
                level: 'Lƒ´menis',
                items: 'Priek≈°meti',
                move: 'Kustƒìties',
                dash: 'Sprints',
                usePowerup: 'Lietot bonusu',
                pause: 'Pauze',

                // Power-ups
                hallPass: 'Koridora caurlaide',
                energyDrink: 'Enerƒ£ijas dzƒìriens',
                stinkBomb: 'Smirdƒ´gƒÅ bumba',
                skateboard: 'Skrituƒºdƒìlis',

                // How To Play
                objective: 'MƒíRƒ∂IS:',
                objectiveText: 'SavƒÅc visas mƒÅjasdarbu lapas un aizsniedz izeju, neiekƒº≈´stot skolotƒÅju rokƒÅs!',
                controls: 'VADƒ™BA:',
                controlMove: 'WASD vai Bulti≈Üas - Kustƒìties',
                controlDash: 'ATSTARPE - Sprints (ƒÅtrs ƒÅtruma uzpl≈´ds)',
                controlPowerup: '1, 2, 3 - Lietot savƒÅktos bonusus',
                controlPause: 'ESC - Pauze',
                powerups: 'BONUSI:',
                hallPassDesc: 'Koridora caurlaide - ƒ™slaicƒ´ga neaizskaramƒ´ba',
                energyDrinkDesc: 'Enerƒ£ijas dzƒìriens - Super ƒÅtrums',
                stinkBombDesc: 'Smirdƒ´gƒÅ bumba - Apdullina tuvumƒÅ eso≈°os skolotƒÅjus',
                skateboardDesc: 'Skrituƒºdƒìlis - ƒÄtra pƒÅrvieto≈°anƒÅs',
                teachersTitle: 'SKOLOTƒÄJI:',
                patrolDesc: 'Patruƒºas skolotƒÅjs - Seko noteiktiem mar≈°rutiem',
                hunterDesc: 'Mednieka skolotƒÅjs - Aktƒ´vi tevi vajƒÅ',
                fastDesc: 'ƒÄtrais skolotƒÅjs - ƒÄtrs, bet paredzams',
                mapTiles: 'KARTES ELEMENTI:',
                floorDesc: 'Grƒ´da - StaigƒÅjama zona',
                wallDesc: 'Siena - Nevar iziet cauri',
                deskDesc: 'Galds - Klases ≈°ƒ∑ƒìrslis',
                lockerDesc: 'Skapƒ´tis - Koridora ≈°ƒ∑ƒìrslis',
                wetFloorDesc: 'Slapja grƒ´da - Slidena virsma',
                exitDesc: 'Izeja - Bƒìdz ≈°eit (zaƒºa, kad atvƒìrta)',

                // Teacher labels
                patrol: 'PATRULA',
                hunter: 'MEDNIEKS',
                fast: 'ƒÄTRAIS',

                // Pause Screen
                paused: 'PAUZE',
                resume: 'TURPINƒÄT',
                quitToMenu: 'UZ IZVƒíLNI',

                // Game Over
                escaped: 'IZBƒíGI!',
                caught: 'NOƒ∂ERTS!',
                gameOver: 'SPƒíLE BEIGUSIES',
                playAgain: 'SPƒíLƒíT VƒíLREIZ',
                mainMenu: 'GALVENƒÄ IZVƒíLNE',
                itemsCollected: 'Priek≈°meti',
                livesRemaining: 'Atliku≈°ƒÅs dzƒ´vƒ´bas',

                // In-game messages
                escape: 'BƒíDZ!',
                invincible: 'NEAIZSKARAMS!',
                speedBoost: 'ƒÄTRUMA PALIELINƒÄJUMS!',
                stinkBombMsg: 'SMIRDƒ™GƒÄ BUMBA!',
                skateboardMsg: 'SKRITUƒªDƒíLIS!',
                caughtMsg: 'NOƒ∂ERTS!',
                livesLeft: 'dzƒ´vƒ´bas atliku≈°as',
                got: 'Ieguvi',

                // Game modes
                freePlay: 'BRƒ™VƒÄ SPƒíLE',
                freeplaySettings: 'Brƒ´vƒÅs spƒìles iestatƒ´jumi',
                campaign: 'KAMPA≈ÖA',
                selectMode: 'Izvƒìlies re≈æƒ´mu',
                continueGame: 'TURPINƒÄT',
                newGame: 'JAUNA SPƒíLE',

                // Level names
                grade1: '1. klase',
                grade2: '2. klase',
                grade3: '3. klase',
                grade4: '4. klase',
                grade5: '5. klase',
                grade6: '6. klase',
                grade7: '7. klase',
                grade8: '8. klase',
                grade9: '9. klase',
                gymnasium1: 'ƒ¢imnƒÅzija I',
                gymnasium2: 'ƒ¢imnƒÅzija II',
                gymnasium3: 'ƒ¢imnƒÅzija III',
                bachelor1: 'Bakalaurs 1. gads',
                bachelor2: 'Bakalaurs 2. gads',
                bachelor3: 'Bakalaurs 3. gads',
                master1: 'Maƒ£istrs 1. gads',
                master2: 'Maƒ£istrs 2. gads',

                // Level complete
                levelComplete: 'Lƒ™MENIS PABEIGTS!',
                nextLevel: 'NƒÄKAMAIS Lƒ™MENIS',
                graduated: 'ABSOLVƒíJI!',
                graduatedMsg: 'Apsveicam! Tu esi pabeidzis visus lƒ´me≈Üus!',
                levelProgress: 'Progress',
                currentLevel: 'Pa≈°reizƒìjais lƒ´menis',
                completed: 'pabeigts',
                totalScore: 'Kopƒìjie punkti',
                campaign: 'KAMPA≈ÖA',
                freePlay: 'BRƒ™VƒÄ SPƒíLE',

                // Random Events
                eventsOn: 'üé≤ Notikumi: IESL',
                eventsOff: 'üé≤ Notikumi: IZSL',
                eventEnded: 'Notikums beidzƒÅs',
                ufoAbduction: 'NLO nolaupƒ´≈°ana',
                dinosaurStampede: 'Dinozauru stampƒìde',
                parentsVisiting: 'VecƒÅku vizƒ´te',
                fireDrill: 'Ugunsdzƒìsƒ´bas mƒÅcƒ´bas',
                principalInspection: 'Direktora pƒÅrbaude',
                powerOutage: 'Elektrƒ´bas pƒÅrtraukums',
                foodFight: 'ƒídiena kauja',
                superheroStudent: 'Supervaro≈Üa re≈æƒ´ms',
                ghostJanitor: 'Spoku sƒìtnieks',
                timeFreeze: 'Laika apstƒÅ≈°anƒÅs',
                earthquake: 'Zemestrƒ´ce',
                pizzaDelivery: 'Picas piegƒÅde',

                // Map Generation Settings
                mapConfigTitle: 'Kartes konfigurƒÅcija',
                mapTopology: 'Kartes izkƒÅrtojums:',
                topologyGrid: 'Re≈æƒ£is (Klasiskais)',
                topologyLabyrinth: 'Labirints (Maldƒ´gs)',
                topologyCorridors: 'Daudz koridoru',
                topologyOpenPlan: 'Atvƒìrts plƒÅns',
                corridorDensity: 'Koridoru blƒ´vums:',
                densityLow: 'Zems',
                densityMedium: 'Vidƒìjs',
                densityHigh: 'Augsts',
                roomDensity: 'Istabu blƒ´vums:',
                roomsFew: 'Maz istabu',
                roomsNormal: 'NormƒÅls',
                roomsMany: 'Daudz istabu',

                // Multiplayer
                multiplayer: 'DAUDZSPƒíLƒíTƒÄJU',
                multiplayerDesc: 'Spƒìlƒì ar draugiem tie≈°saistƒì!',
                createRoom: 'IZVEIDOT ISTABU',
                joinRoom: 'PIEVIENOTIES ISTABAI',
                roomCode: 'Istabas kods',
                yourRoomCode: 'Tava istabas kods:',
                enterRoomCode: 'Ievadi istabas kodu:',
                shareCode: 'Dalies ar ≈°o kodu ar draugiem',
                waitingForPlayers: 'Gaidu spƒìlƒìtƒÅjus...',
                waitingForHost: 'Gaidu, kamƒìr saimnieks sƒÅks spƒìli...',
                host: 'SAIMNIEKS',
                you: 'TU',
                startGameMp: 'SƒÄKT SPƒíLI',
                leaveRoom: 'IZIET',
                cancel: 'ATCELT',
                back: 'ATPAKAƒª',
                join: 'PIEVIENOTIES',
                connecting: 'Savienojos...',
                connected: 'Savienots!',
                connectionError: 'Savienojuma kƒº≈´da',
                playerJoined: 'pievienojƒÅs spƒìlei',
                playerLeft: 'pameta spƒìli',
                gameLobby: 'SPƒíLES VESTIBILS',
                players: 'SpƒìlƒìtƒÅji'
            },

            lt: {
                // Main Menu
                title: 'PABƒñGIMAS I≈† MOKYKLOS',
                subtitle: 'Pabƒók nuo mokytoj≈≥!',
                startGame: 'PRADƒñTI ≈ΩAIDIMƒÑ',
                howToPlay: 'KAIP ≈ΩAISTI',
                backToMenu: 'GRƒÆ≈ΩTI ƒÆ MENIU',

                // Settings
                schoolType: 'Mokyklos tipas:',
                elementary: 'Pradinƒó (Lengva)',
                middleSchool: 'Pagrindinƒó (Vidutinƒó)',
                highSchool: 'Gimnazija (Sunki)',
                university: 'Universitetas (Ekspertas)',
                mapSize: '≈Ωemƒólapio dydis:',
                small: 'Ma≈æas',
                medium: 'Vidutinis',
                large: 'Didelis',
                teachers: 'Mokytojai:',
                language: 'Kalba:',
                soundOn: 'üîä Garsas: ƒÆJUNGTAS',
                soundOff: 'üîá Garsas: I≈†JUNGTAS',
                musicOn: 'üéµ Muzika: ƒÆJUNGTA',
                musicOff: 'üéµ Muzika: I≈†JUNGTA',

                // Game UI
                score: 'Ta≈°kai',
                combo: 'Kombo',
                level: 'Lygis',
                items: 'Daiktai',
                move: 'Judƒóti',
                dash: 'Sprintas',
                usePowerup: 'Naudoti galiƒÖ',
                pause: 'Pauzƒó',

                // Power-ups
                hallPass: 'Koridoriaus leidimas',
                energyDrink: 'Energinis gƒórimas',
                stinkBomb: 'Smirdanti bomba',
                skateboard: 'Riedlentƒó',

                // How To Play
                objective: 'TIKSLAS:',
                objectiveText: 'Surink visus nam≈≥ darb≈≥ lapus ir pasiek i≈°ƒójimƒÖ nepakliuvƒôs mokytojams!',
                controls: 'VALDYMAS:',
                controlMove: 'WASD arba Rodyklƒós - Judƒóti',
                controlDash: 'TARPAS - Sprintas (greitas pagreitis)',
                controlPowerup: '1, 2, 3 - Naudoti surinktus gali≈≥ stiprintuvus',
                controlPause: 'ESC - Pauzƒó',
                powerups: 'GALI≈≤ STIPRINTUVAI:',
                hallPassDesc: 'Koridoriaus leidimas - Laikinas nelieƒçiamumas',
                energyDrinkDesc: 'Energinis gƒórimas - Super greitis',
                stinkBombDesc: 'Smirdanti bomba - Apsvaigia netoliese esanƒçius mokytojus',
                skateboardDesc: 'Riedlentƒó - Greitas judƒójimas',
                teachersTitle: 'MOKYTOJAI:',
                patrolDesc: 'Patruliuojantis mokytojas - Seka nustatytus mar≈°rutus',
                hunterDesc: 'Med≈æiotojas mokytojas - Aktyviai tave vejasi',
                fastDesc: 'Greitas mokytojas - Greitas, bet nuspƒójamas',
                mapTiles: '≈ΩEMƒñLAPIO ELEMENTAI:',
                floorDesc: 'Grindys - Vaik≈°ƒçiojama zona',
                wallDesc: 'Siena - Nepraeinamas',
                deskDesc: 'Suolas - Klasƒós kli≈´tis',
                lockerDesc: 'Spintelƒó - Koridoriaus kli≈´tis',
                wetFloorDesc: '≈†lapios grindys - Slidus pavir≈°ius',
                exitDesc: 'I≈°ƒójimas - Pabƒók ƒçia (≈æalias kai atrakintas)',

                // Teacher labels
                patrol: 'PATRULƒñ',
                hunter: 'MED≈ΩIOT.',
                fast: 'GREITAS',

                // Pause Screen
                paused: 'PAUZƒñ',
                resume: 'TƒòSTI',
                quitToMenu: 'ƒÆ MENIU',

                // Game Over
                escaped: 'PABƒñGAI!',
                caught: 'PAGAUTAS!',
                gameOver: '≈ΩAIDIMAS BAIGTAS',
                playAgain: '≈ΩAISTI DAR KARTƒÑ',
                mainMenu: 'PAGRINDINIS MENIU',
                itemsCollected: 'Daiktai',
                livesRemaining: 'Likusios gyvybƒós',

                // In-game messages
                escape: 'BƒñKK!',
                invincible: 'NELIEƒåIAMAS!',
                speedBoost: 'GREIƒåIO PADIDINIMAS!',
                stinkBombMsg: 'SMIRDANTI BOMBA!',
                skateboardMsg: 'RIEDLENTƒñ!',
                caughtMsg: 'PAGAUTAS!',
                livesLeft: 'gyvybƒós liko',
                got: 'Gavai',

                // Game modes
                freePlay: 'LAISVAS ≈ΩAIDIMAS',
                freeplaySettings: 'Laisvo ≈æaidimo nustatymai',
                campaign: 'KAMPANIJA',
                selectMode: 'Pasirink re≈æimƒÖ',
                continueGame: 'TƒòSTI',
                newGame: 'NAUJAS ≈ΩAIDIMAS',

                // Level names
                grade1: '1 klasƒó',
                grade2: '2 klasƒó',
                grade3: '3 klasƒó',
                grade4: '4 klasƒó',
                grade5: '5 klasƒó',
                grade6: '6 klasƒó',
                grade7: '7 klasƒó',
                grade8: '8 klasƒó',
                grade9: '9 klasƒó',
                gymnasium1: 'Gimnazija I',
                gymnasium2: 'Gimnazija II',
                gymnasium3: 'Gimnazija III',
                bachelor1: 'Bakalauras 1 metai',
                bachelor2: 'Bakalauras 2 metai',
                bachelor3: 'Bakalauras 3 metai',
                master1: 'Magistras 1 metai',
                master2: 'Magistras 2 metai',

                // Level complete
                levelComplete: 'LYGIS BAIGTAS!',
                nextLevel: 'KITAS LYGIS',
                graduated: 'BAIGEI!',
                graduatedMsg: 'Sveikiname! Baigei visus lygius!',
                levelProgress: 'Progresas',
                currentLevel: 'Dabartinis lygis',
                completed: 'baigta',
                totalScore: 'Bendras rezultatas',
                campaign: 'KAMPANIJA',
                freePlay: 'LAISVAS ≈ΩAIDIMAS',

                // Random Events
                eventsOn: 'üé≤ ƒÆvykiai: ƒÆJ',
                eventsOff: 'üé≤ ƒÆvykiai: I≈†J',
                eventEnded: 'ƒÆvykis baigƒósi',
                ufoAbduction: 'NSO pagrobimas',
                dinosaurStampede: 'Dinozaur≈≥ antpl≈´dis',
                parentsVisiting: 'Tƒóv≈≥ vizitas',
                fireDrill: 'Gaisrinƒó treniruotƒó',
                principalInspection: 'Direktoriaus patikra',
                powerOutage: 'Elektros dingimas',
                foodFight: 'Maisto m≈´≈°is',
                superheroStudent: 'Superherojaus re≈æimas',
                ghostJanitor: 'Vaiduoklis sargas',
                timeFreeze: 'Laiko sustabdymas',
                earthquake: '≈Ωemƒós drebƒójimas',
                pizzaDelivery: 'Picos pristatymas',

                // Map Generation Settings
                mapConfigTitle: '≈Ωemƒólapio konfig≈´racija',
                mapTopology: '≈Ωemƒólapio i≈°dƒóstymas:',
                topologyGrid: 'Tinklelis (Klasikinis)',
                topologyLabyrinth: 'Labirintas (Klaidinantis)',
                topologyCorridors: 'Daug koridori≈≥',
                topologyOpenPlan: 'Atviras planas',
                corridorDensity: 'Koridori≈≥ tankis:',
                densityLow: '≈Ωemas',
                densityMedium: 'Vidutinis',
                densityHigh: 'Auk≈°tas',
                roomDensity: 'Kambari≈≥ tankis:',
                roomsFew: 'Ma≈æai kambari≈≥',
                roomsNormal: 'Normalus',
                roomsMany: 'Daug kambari≈≥',

                // Multiplayer
                multiplayer: 'DAUGELIO ≈ΩAIDƒñJ≈≤',
                multiplayerDesc: '≈Ωaisk su draugais internete!',
                createRoom: 'SUKURTI KAMBARƒÆ',
                joinRoom: 'PRISIJUNGTI PRIE KAMBARIO',
                roomCode: 'Kambario kodas',
                yourRoomCode: 'Tavo kambario kodas:',
                enterRoomCode: 'ƒÆvesk kambario kodƒÖ:',
                shareCode: 'Pasidalink ≈°iuo kodu su draugais',
                waitingForPlayers: 'Laukiama ≈æaidƒój≈≥...',
                waitingForHost: 'Laukiama, kol ≈°eimininkas pradƒós ≈æaidimƒÖ...',
                host: '≈†EIMININKAS',
                you: 'TU',
                startGameMp: 'PRADƒñTI ≈ΩAIDIMƒÑ',
                leaveRoom: 'I≈†EITI',
                cancel: 'AT≈†AUKTI',
                back: 'ATGAL',
                join: 'PRISIJUNGTI',
                connecting: 'Jungiamasi...',
                connected: 'Prisijungta!',
                connectionError: 'Ry≈°io klaida',
                playerJoined: 'prisijungƒó prie ≈æaidimo',
                playerLeft: 'paliko ≈æaidimƒÖ',
                gameLobby: '≈ΩAIDIMO LAUKIAMASIS',
                players: '≈Ωaidƒójai'
            },

            ru: {
                // Main Menu
                title: '–ü–û–ë–ï–ì –ò–ó –®–ö–û–õ–´',
                subtitle: '–£–±–µ–≥–∏ –æ—Ç —É—á–∏—Ç–µ–ª–µ–π!',
                startGame: '–ù–ê–ß–ê–¢–¨ –ò–ì–†–£',
                howToPlay: '–ö–ê–ö –ò–ì–†–ê–¢–¨',
                backToMenu: '–ù–ê–ó–ê–î –í –ú–ï–ù–Æ',

                // Settings
                schoolType: '–¢–∏–ø —à–∫–æ–ª—ã:',
                elementary: '–ù–∞—á–∞–ª—å–Ω–∞—è (–õ–µ–≥–∫–æ)',
                middleSchool: '–°—Ä–µ–¥–Ω—è—è (–ù–æ—Ä–º–∞–ª—å–Ω–æ)',
                highSchool: '–ì–∏–º–Ω–∞–∑–∏—è (–°–ª–æ–∂–Ω–æ)',
                university: '–£–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç (–≠–∫—Å–ø–µ—Ä—Ç)',
                mapSize: '–†–∞–∑–º–µ—Ä –∫–∞—Ä—Ç—ã:',
                small: '–ú–∞–ª–µ–Ω—å–∫–∏–π',
                medium: '–°—Ä–µ–¥–Ω–∏–π',
                large: '–ë–æ–ª—å—à–æ–π',
                teachers: '–£—á–∏—Ç–µ–ª—è:',
                language: '–Ø–∑—ã–∫:',
                soundOn: 'üîä –ó–≤—É–∫: –í–ö–õ',
                soundOff: 'üîá –ó–≤—É–∫: –í–´–ö–õ',
                musicOn: 'üéµ –ú—É–∑—ã–∫–∞: –í–ö–õ',
                musicOff: 'üéµ –ú—É–∑—ã–∫–∞: –í–´–ö–õ',

                // Game UI
                score: '–û—á–∫–∏',
                combo: '–ö–æ–º–±–æ',
                level: '–£—Ä–æ–≤–µ–Ω—å',
                items: '–ü—Ä–µ–¥–º–µ—Ç—ã',

                // How to Play
                objective: '–¶–ï–õ–¨:',
                objectiveText: '–°–æ–±–µ—Ä–∏ –≤—Å–µ –¥–æ–º–∞—à–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è –∏ –¥–æ–±–µ—Ä–∏—Å—å –¥–æ –≤—ã—Ö–æ–¥–∞, –Ω–µ –ø–æ–ø–∞–≤—à–∏—Å—å —É—á–∏—Ç–µ–ª—è–º!',
                controls: '–£–ü–†–ê–í–õ–ï–ù–ò–ï:',
                moveKeys: 'WASD –∏–ª–∏ –°—Ç—Ä–µ–ª–∫–∏ - –î–≤–∏–∂–µ–Ω–∏–µ',
                dashKey: '–ü–†–û–ë–ï–õ - –†—ã–≤–æ–∫',
                powerupKeys: '1, 2, 3 - –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ–Ω—É—Å',
                pauseKey: 'ESC - –ü–∞—É–∑–∞',
                powerups: '–ë–û–ù–£–°–´:',
                hallPass: '–ü—Ä–æ–ø—É—Å–∫ - –í—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç—å',
                energyDrink: '–≠–Ω–µ—Ä–≥–µ—Ç–∏–∫ - –°—É–ø–µ—Ä —Å–∫–æ—Ä–æ—Å—Ç—å',
                stinkBomb: '–í–æ–Ω—é—á–∞—è –±–æ–º–±–∞ - –û–≥–ª—É—à–∞–µ—Ç —É—á–∏—Ç–µ–ª–µ–π',
                skateboard: '–°–∫–µ–π—Ç–±–æ—Ä–¥ - –ë—ã—Å—Ç—Ä–æ–µ –ø–µ—Ä–µ–¥–≤–∏–∂–µ–Ω–∏–µ',
                teacherTypes: '–£–ß–ò–¢–ï–õ–Ø:',
                patrolTeacher: '–ü–∞—Ç—Ä—É–ª—å–Ω—ã–π - –•–æ–¥–∏—Ç –ø–æ –º–∞—Ä—à—Ä—É—Ç—É',
                hunterTeacher: '–û—Ö–æ—Ç–Ω–∏–∫ - –ê–∫—Ç–∏–≤–Ω–æ –ø—Ä–µ—Å–ª–µ–¥—É–µ—Ç',
                fastTeacher: '–ë—ã—Å—Ç—Ä—ã–π - –°–∫–æ—Ä–æ—Å—Ç–Ω–æ–π, –Ω–æ –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã–π',
                mapTiles: '–≠–õ–ï–ú–ï–ù–¢–´ –ö–ê–†–¢–´:',
                floorDesc: '–ü–æ–ª - –ü—Ä–æ—Ö–æ–¥–∏–º–∞—è –∑–æ–Ω–∞',
                wallDesc: '–°—Ç–µ–Ω–∞ - –ù–µ–ø—Ä–æ—Ö–æ–¥–∏–º–æ',
                deskDesc: '–ü–∞—Ä—Ç–∞ - –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ –≤ –∫–ª–∞—Å—Å–µ',
                lockerDesc: '–®–∫–∞—Ñ—á–∏–∫ - –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ –≤ –∫–æ—Ä–∏–¥–æ—Ä–µ',
                wetFloorDesc: '–ú–æ–∫—Ä—ã–π –ø–æ–ª - –°–∫–æ–ª—å–∑–∫–∞—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å',
                exitDesc: '–í—ã—Ö–æ–¥ - –ë–µ–≥–∏ —Å—é–¥–∞ (–∑–µ–ª—ë–Ω—ã–π –∫–æ–≥–¥–∞ –æ—Ç–∫—Ä—ã—Ç)',

                // Game Over
                escaped: '–°–ë–ï–ñ–ê–õ!',
                caught: '–ü–û–ô–ú–ê–ù!',
                playAgain: '–ò–ì–†–ê–¢–¨ –°–ù–û–í–ê',
                mainMenu: '–ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ',
                itemsCollected: '–°–æ–±—Ä–∞–Ω–æ –ø—Ä–µ–¥–º–µ—Ç–æ–≤',
                livesRemaining: '–û—Å—Ç–∞–ª–æ—Å—å –∂–∏–∑–Ω–µ–π',

                // In-game messages
                escape: '–ë–µ–≥–∏ –∫ –≤—ã—Ö–æ–¥—É!',
                paused: '–ü–ê–£–ó–ê',
                resume: '–ü–†–û–î–û–õ–ñ–ò–¢–¨',
                quit: '–í–´–ô–¢–ò –í –ú–ï–ù–Æ',
                newGame: '–ù–û–í–ê–Ø –ò–ì–†–ê',

                // Level names
                grade1: '1 –ö–ª–∞—Å—Å',
                grade2: '2 –ö–ª–∞—Å—Å',
                grade3: '3 –ö–ª–∞—Å—Å',
                grade4: '4 –ö–ª–∞—Å—Å',
                grade5: '5 –ö–ª–∞—Å—Å',
                grade6: '6 –ö–ª–∞—Å—Å',
                grade7: '7 –ö–ª–∞—Å—Å',
                grade8: '8 –ö–ª–∞—Å—Å',
                grade9: '9 –ö–ª–∞—Å—Å',
                gymnasium1: '–ì–∏–º–Ω–∞–∑–∏—è I',
                gymnasium2: '–ì–∏–º–Ω–∞–∑–∏—è II',
                gymnasium3: '–ì–∏–º–Ω–∞–∑–∏—è III',
                bachelor1: '–ë–∞–∫–∞–ª–∞–≤—Ä 1 –≥–æ–¥',
                bachelor2: '–ë–∞–∫–∞–ª–∞–≤—Ä 2 –≥–æ–¥',
                bachelor3: '–ë–∞–∫–∞–ª–∞–≤—Ä 3 –≥–æ–¥',
                master1: '–ú–∞–≥–∏—Å—Ç—Ä 1 –≥–æ–¥',
                master2: '–ú–∞–≥–∏—Å—Ç—Ä 2 –≥–æ–¥',

                // Level complete
                levelComplete: '–£–†–û–í–ï–ù–¨ –ü–†–û–ô–î–ï–ù!',
                nextLevel: '–°–õ–ï–î–£–Æ–©–ò–ô –£–†–û–í–ï–ù–¨',
                graduated: '–í–´–ü–£–°–ö–ù–ò–ö!',
                graduatedMsg: '–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –ø—Ä–æ—à–ª–∏ –≤—Å–µ —É—Ä–æ–≤–Ω–∏!',
                levelProgress: '–ü—Ä–æ–≥—Ä–µ—Å—Å',
                currentLevel: '–¢–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å',
                completed: '–ø—Ä–æ–π–¥–µ–Ω–æ',
                totalScore: '–û–±—â–∏–π —Å—á—ë—Ç',
                campaign: '–ö–ê–ú–ü–ê–ù–ò–Ø',
                freePlay: '–°–í–û–ë–û–î–ù–ê–Ø –ò–ì–†–ê',
                freeplaySettings: '–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–≤–æ–±–æ–¥–Ω–æ–π –∏–≥—Ä—ã',

                // Random Events
                eventsOn: 'üé≤ –°–æ–±—ã—Ç–∏—è: –í–ö–õ',
                eventsOff: 'üé≤ –°–æ–±—ã—Ç–∏—è: –í–´–ö–õ',
                eventEnded: '–°–æ–±—ã—Ç–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ',
                ufoAbduction: '–ü–æ—Ö–∏—â–µ–Ω–∏–µ –ù–õ–û',
                dinosaurStampede: '–ù–∞—à–µ—Å—Ç–≤–∏–µ –¥–∏–Ω–æ–∑–∞–≤—Ä–æ–≤',
                parentsVisiting: '–í–∏–∑–∏—Ç —Ä–æ–¥–∏—Ç–µ–ª–µ–π',
                fireDrill: '–ü–æ–∂–∞—Ä–Ω–∞—è —Ç—Ä–µ–≤–æ–≥–∞',
                principalInspection: '–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∞',
                powerOutage: '–û—Ç–∫–ª—é—á–µ–Ω–∏–µ —Å–≤–µ—Ç–∞',
                foodFight: '–ë–∏—Ç–≤–∞ –µ–¥–æ–π',
                superheroStudent: '–†–µ–∂–∏–º —Å—É–ø–µ—Ä–≥–µ—Ä–æ—è',
                ghostJanitor: '–ü—Ä–∏–∑—Ä–∞–∫ —É–±–æ—Ä—â–∏–∫–∞',
                timeFreeze: '–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Ä–µ–º–µ–Ω–∏',
                earthquake: '–ó–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏–µ',
                pizzaDelivery: '–î–æ—Å—Ç–∞–≤–∫–∞ –ø–∏—Ü—Ü—ã',

                // Map Generation Settings
                mapConfigTitle: '–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞—Ä—Ç—ã',
                mapTopology: '–ü–ª–∞–Ω–∏—Ä–æ–≤–∫–∞ –∫–∞—Ä—Ç—ã:',
                topologyGrid: '–°–µ—Ç–∫–∞ (–ö–ª–∞—Å—Å–∏–∫–∞)',
                topologyLabyrinth: '–õ–∞–±–∏—Ä–∏–Ω—Ç (–ó–∞–ø—É—Ç–∞–Ω–Ω—ã–π)',
                topologyCorridors: '–ú–Ω–æ–≥–æ –∫–æ—Ä–∏–¥–æ—Ä–æ–≤',
                topologyOpenPlan: '–û—Ç–∫—Ä—ã—Ç–∞—è –ø–ª–∞–Ω–∏—Ä–æ–≤–∫–∞',
                corridorDensity: '–ü–ª–æ—Ç–Ω–æ—Å—Ç—å –∫–æ—Ä–∏–¥–æ—Ä–æ–≤:',
                densityLow: '–ù–∏–∑–∫–∞—è',
                densityMedium: '–°—Ä–µ–¥–Ω—è—è',
                densityHigh: '–í—ã—Å–æ–∫–∞—è',
                roomDensity: '–ü–ª–æ—Ç–Ω–æ—Å—Ç—å –∫–æ–º–Ω–∞—Ç:',
                roomsFew: '–ú–∞–ª–æ –∫–æ–º–Ω–∞—Ç',
                roomsNormal: '–ù–æ—Ä–º–∞–ª—å–Ω–∞—è',
                roomsMany: '–ú–Ω–æ–≥–æ –∫–æ–º–Ω–∞—Ç',

                // Multiplayer
                multiplayer: '–ú–£–õ–¨–¢–ò–ü–õ–ï–ï–†',
                multiplayerDesc: '–ò–≥—Ä–∞–π —Å –¥—Ä—É–∑—å—è–º–∏ –æ–Ω–ª–∞–π–Ω!',
                createRoom: '–°–û–ó–î–ê–¢–¨ –ö–û–ú–ù–ê–¢–£',
                joinRoom: '–ü–†–ò–°–û–ï–î–ò–ù–ò–¢–¨–°–Ø',
                roomCode: '–ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã',
                yourRoomCode: '–¢–≤–æ–π –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã:',
                enterRoomCode: '–í–≤–µ–¥–∏ –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã:',
                shareCode: '–ü–æ–¥–µ–ª–∏—Å—å —ç—Ç–∏–º –∫–æ–¥–æ–º —Å –¥—Ä—É–∑—å—è–º–∏',
                waitingForPlayers: '–û–∂–∏–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–≤...',
                waitingForHost: '–û–∂–∏–¥–∞–Ω–∏–µ –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã –æ—Ç —Ö–æ—Å—Ç–∞...',
                host: '–•–û–°–¢',
                you: '–¢–´',
                startGameMp: '–ù–ê–ß–ê–¢–¨ –ò–ì–†–£',
                leaveRoom: '–í–´–ô–¢–ò',
                cancel: '–û–¢–ú–ï–ù–ê',
                back: '–ù–ê–ó–ê–î',
                join: '–í–û–ô–¢–ò',
                connecting: '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...',
                connected: '–ü–æ–¥–∫–ª—é—á–µ–Ω–æ!',
                connectionError: '–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è',
                playerJoined: '–ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –∏–≥—Ä–µ',
                playerLeft: '–ø–æ–∫–∏–Ω—É–ª –∏–≥—Ä—É',
                gameLobby: '–õ–û–ë–ë–ò –ò–ì–†–´',
                players: '–ò–≥—Ä–æ–∫–∏'
            }
        };

        function t(key) {
            return translations[settings.language][key] || translations.en[key] || key;
        }

        function updateLanguage() {
            // Update main menu
            document.querySelector('#main-menu h1').textContent = t('title');
            document.querySelector('#main-menu h2').textContent = t('subtitle');
            document.getElementById('start-button').textContent = t('startGame');
            document.getElementById('how-to-play-button').textContent = t('howToPlay');

            // Update settings labels
            const settingLabels = document.querySelectorAll('.setting-row label');
            if (settingLabels[0]) settingLabels[0].textContent = t('schoolType');
            if (settingLabels[1]) settingLabels[1].textContent = t('mapSize');
            if (settingLabels[2]) settingLabels[2].textContent = t('teachers');
            if (settingLabels[3]) settingLabels[3].textContent = t('language');

            // Update school type options
            const schoolTypeSelect = document.getElementById('school-type');
            schoolTypeSelect.options[0].textContent = t('elementary');
            schoolTypeSelect.options[1].textContent = t('middleSchool');
            schoolTypeSelect.options[2].textContent = t('highSchool');
            schoolTypeSelect.options[3].textContent = t('university');

            // Update map size options
            const mapSizeSelect = document.getElementById('map-size');
            mapSizeSelect.options[0].textContent = t('small');
            mapSizeSelect.options[1].textContent = t('medium');
            mapSizeSelect.options[2].textContent = t('large');

            // Update sound buttons
            updateSoundButtons();

            // Update campaign/freeplay/multiplayer buttons
            document.getElementById('campaign-button').innerHTML = `üìö ${t('campaign')}`;
            document.getElementById('freeplay-button').innerHTML = `üéÆ ${t('freePlay')}`;
            document.getElementById('multiplayer-button').innerHTML = `üë• ${t('multiplayer')}`;

            // Update How To Play screen
            document.querySelector('#how-to-play-screen h2').textContent = t('howToPlay');
            document.getElementById('back-to-menu-button').textContent = t('backToMenu');

            // Update how to play content
            const howToPlayContent = document.querySelector('#how-to-play-screen .settings-panel');
            howToPlayContent.innerHTML = `
                <p style="margin-bottom: 15px;"><strong style="color: #4ade80;">${t('objective')}</strong> ${t('objectiveText')}</p>
                <p style="margin-bottom: 15px;"><strong style="color: #60a5fa;">${t('controls')}</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>${t('controlMove')}</li>
                    <li>${t('controlDash')}</li>
                    <li>${t('controlPowerup')}</li>
                    <li>${t('controlPause')}</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #ffd700;">${t('powerups')}</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>üìú ${t('hallPassDesc')}</li>
                    <li>‚ö° ${t('energyDrinkDesc')}</li>
                    <li>üí® ${t('stinkBombDesc')}</li>
                    <li>üõπ ${t('skateboardDesc')}</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #ff6b6b;">${t('teachersTitle')}</strong></p>
                <ul style="margin-left: 20px;">
                    <li><span style="display:inline-block;width:16px;height:16px;background:#4a90a4;border-radius:50%;vertical-align:middle;margin-right:5px;"></span> ${t('patrolDesc')}</li>
                    <li><span style="display:inline-block;width:16px;height:16px;background:#c0392b;border-radius:3px;vertical-align:middle;margin-right:5px;"></span> ${t('hunterDesc')}</li>
                    <li><span style="display:inline-block;width:16px;height:12px;background:#9b59b6;border-radius:50%;vertical-align:middle;margin-right:5px;"></span> ${t('fastDesc')}</li>
                </ul>
            `;

            // Update Pause screen
            document.querySelector('#pause-screen h2').textContent = t('paused');
            document.getElementById('resume-button').textContent = t('resume');
            document.getElementById('quit-button').textContent = t('quitToMenu');

            // Update Game Over screen
            document.getElementById('retry-button').textContent = t('playAgain');
            document.getElementById('menu-button').textContent = t('mainMenu');

            // Update footer hints
            const footerHints = document.querySelectorAll('#game-footer .key-hint');
            if (footerHints[0]) footerHints[0].innerHTML = `<span class="key">WASD</span> / <span class="key">‚Üê‚Üë‚Üì‚Üí</span> ${t('move')}`;
            if (footerHints[1]) footerHints[1].innerHTML = `<span class="key">SPACE</span> ${t('dash')}`;
            if (footerHints[2]) footerHints[2].innerHTML = `<span class="key">1-3</span> ${t('usePowerup')}`;
            if (footerHints[3]) footerHints[3].innerHTML = `<span class="key">ESC</span> ${t('pause')}`;

            // Update power-up slot titles
            document.getElementById('powerup-1').title = t('hallPass');
            document.getElementById('powerup-2').title = t('energyDrink');
            document.getElementById('powerup-3').title = t('stinkBomb');

            // Update UI displays
            updateUI();
        }

        function setLanguage(lang) {
            settings.language = lang;
            updateLanguage();
            playSound('menu_click');
        }

        // ============================================
        // SOUND SYSTEM
        // ============================================

        let audioCtx = null;
        let musicOscillators = [];
        let musicGain = null;

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(type, options = {}) {
            if (!settings.soundEnabled || !audioCtx) return;

            // Resume audio context if suspended (browser autoplay policy)
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            const time = audioCtx.currentTime;

            switch (type) {
                case 'collect':
                    // Cheerful ascending ding
                    playTone(880 + (options.combo || 1) * 50, 0.1, 'sine', 0.3);
                    playTone(1100 + (options.combo || 1) * 50, 0.1, 'sine', 0.25, 0.05);
                    break;

                case 'powerup':
                    // Magical ascending arpeggio
                    playTone(400, 0.15, 'sine', 0.3);
                    playTone(500, 0.15, 'sine', 0.25, 0.08);
                    playTone(600, 0.15, 'sine', 0.2, 0.16);
                    playTone(800, 0.2, 'sine', 0.3, 0.24);
                    break;

                case 'powerup_use':
                    // Activation whoosh
                    playSweep(200, 800, 0.3, 'sawtooth', 0.2);
                    break;

                case 'dash':
                    // Quick whoosh
                    playSweep(300, 150, 0.15, 'sawtooth', 0.15);
                    break;

                case 'caught':
                    // Alarming descending sound
                    playTone(600, 0.15, 'square', 0.3);
                    playTone(400, 0.15, 'square', 0.25, 0.1);
                    playTone(200, 0.3, 'square', 0.2, 0.2);
                    break;

                case 'alert':
                    // Teacher spotted you - quick alarm beep
                    playTone(800, 0.08, 'square', 0.15);
                    playTone(1000, 0.08, 'square', 0.12, 0.1);
                    break;

                case 'stun':
                    // Stink bomb - bubbly explosion
                    playNoise(0.3, 0.4);
                    playSweep(400, 100, 0.4, 'sawtooth', 0.2);
                    break;

                case 'win':
                    // Victory fanfare
                    const notes = [523, 659, 784, 1047]; // C E G C
                    notes.forEach((freq, i) => {
                        playTone(freq, 0.3, 'sine', 0.3, i * 0.15);
                        playTone(freq * 1.5, 0.3, 'sine', 0.15, i * 0.15);
                    });
                    break;

                case 'lose':
                    // Game over descending
                    playTone(400, 0.3, 'sawtooth', 0.25);
                    playTone(350, 0.3, 'sawtooth', 0.2, 0.25);
                    playTone(300, 0.5, 'sawtooth', 0.15, 0.5);
                    break;

                case 'footstep':
                    // Soft footstep
                    playNoise(0.03, 0.05);
                    break;

                case 'slide':
                    // Wet floor sliding
                    playSweep(200, 400, 0.1, 'sine', 0.1);
                    break;

                case 'menu_click':
                    // UI click
                    playTone(600, 0.05, 'sine', 0.2);
                    break;

                case 'menu_hover':
                    // UI hover
                    playTone(400, 0.03, 'sine', 0.1);
                    break;
            }
        }

        function playTone(frequency, duration, waveType = 'sine', volume = 0.3, delay = 0) {
            if (!audioCtx) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = waveType;
            oscillator.frequency.value = frequency;

            const startTime = audioCtx.currentTime + delay;
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(volume, startTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

            oscillator.start(startTime);
            oscillator.stop(startTime + duration + 0.1);
        }

        function playSweep(startFreq, endFreq, duration, waveType = 'sine', volume = 0.3) {
            if (!audioCtx) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = waveType;
            oscillator.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(endFreq, audioCtx.currentTime + duration);

            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + duration + 0.1);
        }

        function playNoise(duration, volume = 0.3) {
            if (!audioCtx) return;

            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * volume;
            }

            const noise = audioCtx.createBufferSource();
            const gainNode = audioCtx.createGain();

            noise.buffer = buffer;
            noise.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);

            noise.start();
        }

        // Background music using simple procedural generation
        function startMusic() {
            if (!settings.musicEnabled || !audioCtx) return;
            stopMusic();

            // Resume AudioContext if suspended (browser autoplay policy)
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    actuallyStartMusic();
                });
            } else {
                actuallyStartMusic();
            }
        }

        function actuallyStartMusic() {
            if (!audioCtx || musicOscillators.length > 0) return;

            musicGain = audioCtx.createGain();
            musicGain.gain.value = 0.25; // Increased from 0.08
            musicGain.connect(audioCtx.destination);

            // Create a simple bass line
            const bassNotes = [130.81, 146.83, 164.81, 146.83]; // C3, D3, E3, D3
            let noteIndex = 0;

            function playNextNote() {
                if (!settings.musicEnabled || musicOscillators.length === 0 || !audioCtx) return;

                const osc = audioCtx.createOscillator();
                const noteGain = audioCtx.createGain();

                osc.connect(noteGain);
                noteGain.connect(musicGain);

                osc.type = 'triangle';
                osc.frequency.value = bassNotes[noteIndex];

                noteGain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                noteGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);

                osc.start();
                osc.stop(audioCtx.currentTime + 0.5);

                noteIndex = (noteIndex + 1) % bassNotes.length;
            }

            // Start the loop
            const musicInterval = setInterval(() => {
                if (settings.musicEnabled && gameState.running && !gameState.paused && musicOscillators.length > 0) {
                    playNextNote();
                }
            }, 500);

            musicOscillators.push({ interval: musicInterval });

            // Add ambient pad
            const padOsc = audioCtx.createOscillator();
            const padGain = audioCtx.createGain();
            const padFilter = audioCtx.createBiquadFilter();

            padOsc.connect(padFilter);
            padFilter.connect(padGain);
            padGain.connect(musicGain);

            padOsc.type = 'sawtooth';
            padOsc.frequency.value = 65.41; // C2
            padFilter.type = 'lowpass';
            padFilter.frequency.value = 300; // Increased from 200 for more presence
            padGain.gain.value = 0.3; // Increased from 0.15

            padOsc.start();
            musicOscillators.push({ osc: padOsc, gain: padGain });
        }

        function stopMusic() {
            musicOscillators.forEach(item => {
                if (item.interval) clearInterval(item.interval);
                if (item.osc) {
                    try {
                        item.osc.stop();
                    } catch (e) {}
                }
            });
            musicOscillators = [];
        }

        function toggleSound() {
            settings.soundEnabled = !settings.soundEnabled;
            updateSoundButtons();
            if (settings.soundEnabled) {
                playSound('menu_click');
            }
        }

        function toggleMusic() {
            settings.musicEnabled = !settings.musicEnabled;
            updateSoundButtons();
            if (settings.musicEnabled && gameState.running) {
                startMusic();
            } else {
                stopMusic();
            }
        }

        function toggleEvents() {
            settings.eventsEnabled = !settings.eventsEnabled;
            updateSoundButtons();
            playSound('menu_click');
        }

        function toggleSettingsPanel() {
            const header = document.getElementById('settings-toggle');
            const content = document.getElementById('settings-content');
            if (header && content) {
                header.classList.toggle('expanded');
                content.classList.toggle('expanded');
                playSound('menu_click');
            }
        }

        function toggleMapConfigPanel() {
            const header = document.getElementById('map-config-toggle');
            const content = document.getElementById('map-config-content');
            if (header && content) {
                header.classList.toggle('expanded');
                content.classList.toggle('expanded');
                playSound('menu_click');
            }
        }

        function toggleFreeplayPanel() {
            const header = document.getElementById('freeplay-toggle');
            const content = document.getElementById('freeplay-content');
            if (header && content) {
                header.classList.toggle('expanded');
                content.classList.toggle('expanded');
                playSound('menu_click');
            }
        }

        function updateSoundButtons() {
            const soundBtn = document.getElementById('sound-toggle');
            const musicBtn = document.getElementById('music-toggle');
            const eventsBtn = document.getElementById('events-toggle');
            if (soundBtn) soundBtn.textContent = settings.soundEnabled ? t('soundOn') : t('soundOff');
            if (musicBtn) musicBtn.textContent = settings.musicEnabled ? t('musicOn') : t('musicOff');
            if (eventsBtn) eventsBtn.textContent = settings.eventsEnabled ? t('eventsOn') : t('eventsOff');
        }

        // ============================================
        // RANDOM EVENTS SYSTEM
        // ============================================

        function updateEvents(deltaTime) {
            if (!settings.eventsEnabled || !gameState.running || gameState.paused) return;

            // Update current event
            if (currentEvent) {
                eventTimer -= deltaTime;
                updateCurrentEvent(deltaTime);
                if (eventTimer <= 0) {
                    endCurrentEvent();
                }
            } else {
                // Check if it's time for a new event
                nextEventTime -= deltaTime;
                if (nextEventTime <= 0) {
                    triggerRandomEvent();
                }
            }

            // Update event entities
            updateEventEntities(deltaTime);
        }

        function triggerRandomEvent() {
            const event = RANDOM_EVENTS[Math.floor(Math.random() * RANDOM_EVENTS.length)];
            currentEvent = { ...event };
            eventTimer = event.duration;
            nextEventTime = event.minInterval + Math.random() * 20;

            // Show event announcement
            showMessage(`${event.icon} ${t(event.name)}!`);
            playSound('powerup');

            // Initialize event-specific state
            initEventState(event.id);
        }

        function initEventState(eventId) {
            eventEntities = [];

            switch (eventId) {
                case 'ufo':
                    // Create UFO that moves across the map
                    eventEntities.push({
                        type: 'ufo',
                        x: -100,
                        y: Math.random() * gameState.mapHeight * TILE_SIZE,
                        targetY: Math.random() * gameState.mapHeight * TILE_SIZE,
                        speed: 150,
                        beamActive: false,
                        beamTimer: 0
                    });
                    break;

                case 'dinosaur':
                    // Create dinosaurs running through
                    const numDinos = 3 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < numDinos; i++) {
                        eventEntities.push({
                            type: 'dinosaur',
                            x: -50 - i * 80,
                            y: (Math.random() * 0.6 + 0.2) * gameState.mapHeight * TILE_SIZE,
                            speed: 200 + Math.random() * 100,
                            variant: Math.random() < 0.3 ? 'trex' : 'raptor'
                        });
                    }
                    break;

                case 'parents':
                    // Spawn parent figures around the map
                    for (let i = 0; i < 4; i++) {
                        const pos = getRandomFloorPosition();
                        eventEntities.push({
                            type: 'parent',
                            x: pos.x,
                            y: pos.y,
                            wanderAngle: Math.random() * Math.PI * 2
                        });
                    }
                    break;

                case 'fireDrill':
                    // Find exit position for all characters to move toward
                    gameState.fireDrillActive = true;
                    break;

                case 'principal':
                    // Spawn principal
                    const principalPos = getRandomFloorPosition();
                    eventEntities.push({
                        type: 'principal',
                        x: principalPos.x,
                        y: principalPos.y,
                        patrolAngle: 0
                    });
                    // Freeze all teachers
                    teachers.forEach(t => t.frozen = true);
                    break;

                case 'powerOutage':
                    gameState.powerOutage = true;
                    break;

                case 'foodFight':
                    // Spawn flying food projectiles periodically
                    gameState.foodFightActive = true;
                    break;

                case 'superhero':
                    // Give player temporary powers
                    player.superhero = true;
                    player.canFly = true;
                    break;

                case 'ghost':
                    // Spawn ghost janitor
                    const ghostPos = getRandomFloorPosition();
                    eventEntities.push({
                        type: 'ghost',
                        x: ghostPos.x,
                        y: ghostPos.y,
                        targetX: ghostPos.x,
                        targetY: ghostPos.y,
                        alpha: 0.7
                    });
                    break;

                case 'timeFreeze':
                    gameState.timeFreeze = true;
                    teachers.forEach(t => t.frozen = true);
                    break;

                case 'earthquake':
                    gameState.earthquakeActive = true;
                    gameState.screenShake = 10;
                    // Create some new openings in walls
                    createEarthquakeCracks();
                    break;

                case 'pizza':
                    // Spawn pizza delivery person at entrance
                    eventEntities.push({
                        type: 'pizza',
                        x: 2 * TILE_SIZE,
                        y: gameState.mapHeight / 2 * TILE_SIZE
                    });
                    // Teachers rush to entrance
                    teachers.forEach(t => {
                        t.rushingToPizza = true;
                        t.pizzaTarget = { x: 3 * TILE_SIZE, y: gameState.mapHeight / 2 * TILE_SIZE };
                    });
                    break;
            }
        }

        function updateCurrentEvent(deltaTime) {
            if (!currentEvent) return;

            switch (currentEvent.id) {
                case 'foodFight':
                    // Spawn food projectiles randomly
                    if (Math.random() < 0.1) {
                        const pos = getRandomFloorPosition();
                        eventEntities.push({
                            type: 'food',
                            x: pos.x,
                            y: pos.y - 200,
                            vy: 300,
                            foodType: ['üçï', 'üçî', 'üå≠', 'ü•™', 'üç©'][Math.floor(Math.random() * 5)]
                        });
                    }
                    break;

                case 'earthquake':
                    if (Math.random() < 0.3) {
                        gameState.screenShake = Math.max(gameState.screenShake, 5);
                    }
                    break;
            }
        }

        function updateEventEntities(deltaTime) {
            const toRemove = [];

            eventEntities.forEach((entity, index) => {
                switch (entity.type) {
                    case 'ufo':
                        // Move UFO across screen
                        entity.x += entity.speed * deltaTime;
                        entity.y += (entity.targetY - entity.y) * 0.02;

                        // Beam logic
                        entity.beamTimer -= deltaTime;
                        if (entity.beamTimer <= 0) {
                            entity.beamActive = !entity.beamActive;
                            entity.beamTimer = entity.beamActive ? 1.5 : 0.5;
                        }

                        // Check beam collision with teachers
                        if (entity.beamActive) {
                            teachers.forEach(teacher => {
                                const dx = teacher.x - entity.x;
                                const dy = teacher.y - entity.y;
                                if (Math.abs(dx) < 60 && dy > 0 && dy < 200) {
                                    teacher.stunned = true;
                                    teacher.stunnedTimer = 2;
                                    teacher.y -= 50 * deltaTime; // Lift up
                                }
                            });
                            // Slow player if in beam
                            const pdx = player.x - entity.x;
                            const pdy = player.y - entity.y;
                            if (Math.abs(pdx) < 60 && pdy > 0 && pdy < 200) {
                                player.vx *= 0.5;
                                player.vy *= 0.5;
                            }
                        }

                        if (entity.x > gameState.mapWidth * TILE_SIZE + 100) {
                            toRemove.push(index);
                        }
                        break;

                    case 'dinosaur':
                        entity.x += entity.speed * deltaTime;

                        // Knock down anyone in path
                        const checkKnockdown = (targetX, targetY, isPlayer) => {
                            const dx = targetX - entity.x;
                            const dy = targetY - entity.y;
                            if (Math.abs(dx) < 40 && Math.abs(dy) < 30) {
                                if (isPlayer && !player.invincible) {
                                    gameState.screenShake = 8;
                                    player.vx = 200;
                                    player.vy = (Math.random() - 0.5) * 200;
                                } else if (!isPlayer) {
                                    return true; // Stun teacher
                                }
                            }
                            return false;
                        };

                        teachers.forEach(teacher => {
                            if (checkKnockdown(teacher.x, teacher.y, false)) {
                                teacher.stunned = true;
                                teacher.stunnedTimer = 3;
                            }
                        });
                        checkKnockdown(player.x, player.y, true);

                        if (entity.x > gameState.mapWidth * TILE_SIZE + 100) {
                            toRemove.push(index);
                        }
                        break;

                    case 'parent':
                        // Wander around slowly
                        entity.wanderAngle += (Math.random() - 0.5) * 0.1;
                        const parentSpeed = 30;
                        const newPX = entity.x + Math.cos(entity.wanderAngle) * parentSpeed * deltaTime;
                        const newPY = entity.y + Math.sin(entity.wanderAngle) * parentSpeed * deltaTime;
                        if (!checkWallCollision(newPX, newPY, 20)) {
                            entity.x = newPX;
                            entity.y = newPY;
                        } else {
                            entity.wanderAngle += Math.PI;
                        }

                        // Distract nearby teachers (slow them down)
                        teachers.forEach(teacher => {
                            const dx = teacher.x - entity.x;
                            const dy = teacher.y - entity.y;
                            if (Math.sqrt(dx*dx + dy*dy) < 150) {
                                teacher.distracted = true;
                            }
                        });
                        break;

                    case 'principal':
                        // Patrol in a circle
                        entity.patrolAngle += deltaTime * 0.5;
                        const radius = 100;
                        const targetX = entity.x + Math.cos(entity.patrolAngle) * radius;
                        const targetY = entity.y + Math.sin(entity.patrolAngle) * radius;
                        entity.displayX = targetX;
                        entity.displayY = targetY;
                        break;

                    case 'ghost':
                        // Float toward wet floors and clean them
                        if (Math.random() < 0.02) {
                            // Find new target (wet floor or random)
                            let foundWetFloor = false;
                            for (let y = 0; y < gameState.mapHeight && !foundWetFloor; y++) {
                                for (let x = 0; x < gameState.mapWidth && !foundWetFloor; x++) {
                                    if (gameState.map[y][x] === TILES.WET_FLOOR) {
                                        entity.targetX = x * TILE_SIZE + TILE_SIZE/2;
                                        entity.targetY = y * TILE_SIZE + TILE_SIZE/2;
                                        foundWetFloor = true;
                                    }
                                }
                            }
                            if (!foundWetFloor) {
                                const pos = getRandomFloorPosition();
                                entity.targetX = pos.x;
                                entity.targetY = pos.y;
                            }
                        }

                        // Move toward target
                        const gdx = entity.targetX - entity.x;
                        const gdy = entity.targetY - entity.y;
                        const gDist = Math.sqrt(gdx*gdx + gdy*gdy);
                        if (gDist > 5) {
                            entity.x += (gdx / gDist) * 80 * deltaTime;
                            entity.y += (gdy / gDist) * 80 * deltaTime;
                        }

                        // Clean wet floor at current position
                        const gTileX = Math.floor(entity.x / TILE_SIZE);
                        const gTileY = Math.floor(entity.y / TILE_SIZE);
                        if (gameState.map[gTileY] && gameState.map[gTileY][gTileX] === TILES.WET_FLOOR) {
                            gameState.map[gTileY][gTileX] = TILES.FLOOR;
                        }

                        // Scare nearby teachers
                        teachers.forEach(teacher => {
                            const dx = teacher.x - entity.x;
                            const dy = teacher.y - entity.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < 100) {
                                // Run away from ghost
                                if (dist > 1) {
                                    teacher.vx = (dx / dist) * teacher.speed * 3;
                                    teacher.vy = (dy / dist) * teacher.speed * 3;
                                } else {
                                    // If too close, pick a random direction
                                    const angle = Math.random() * Math.PI * 2;
                                    teacher.vx = Math.cos(angle) * teacher.speed * 3;
                                    teacher.vy = Math.sin(angle) * teacher.speed * 3;
                                }
                                teacher.scaredTimer = 1;
                            }
                        });

                        entity.alpha = 0.5 + Math.sin(Date.now() / 200) * 0.3;
                        break;

                    case 'food':
                        entity.y += entity.vy * deltaTime;

                        // Check collision with ground/entities
                        const foodTileY = Math.floor(entity.y / TILE_SIZE);
                        if (foodTileY >= 0 && foodTileY < gameState.mapHeight) {
                            // Hit teachers
                            teachers.forEach(teacher => {
                                const dx = teacher.x - entity.x;
                                const dy = teacher.y - entity.y;
                                if (Math.sqrt(dx*dx + dy*dy) < 30) {
                                    teacher.stunned = true;
                                    teacher.stunnedTimer = 2;
                                    toRemove.push(index);
                                }
                            });

                            // Hit player
                            const pdx = player.x - entity.x;
                            const pdy = player.y - entity.y;
                            if (Math.sqrt(pdx*pdx + pdy*pdy) < 25 && !player.invincible) {
                                player.vx += (Math.random() - 0.5) * 100;
                                player.vy += (Math.random() - 0.5) * 100;
                                toRemove.push(index);
                            }

                            // Hit ground
                            if (entity.y > foodTileY * TILE_SIZE + TILE_SIZE) {
                                // Create slippery spot
                                const tileX = Math.floor(entity.x / TILE_SIZE);
                                if (gameState.map[foodTileY] && gameState.map[foodTileY][tileX] === TILES.FLOOR) {
                                    gameState.map[foodTileY][tileX] = TILES.WET_FLOOR;
                                }
                                toRemove.push(index);
                            }
                        }
                        break;

                    case 'pizza':
                        // Just stands there, teachers come to it
                        entity.timer = (entity.timer || 0) + deltaTime;
                        break;
                }
            });

            // Remove entities marked for removal (in reverse order)
            toRemove.sort((a, b) => b - a).forEach(idx => eventEntities.splice(idx, 1));
        }

        function endCurrentEvent() {
            if (!currentEvent) return;

            // Clean up event-specific state
            switch (currentEvent.id) {
                case 'principal':
                case 'timeFreeze':
                    teachers.forEach(t => t.frozen = false);
                    break;

                case 'powerOutage':
                    gameState.powerOutage = false;
                    break;

                case 'fireDrill':
                    gameState.fireDrillActive = false;
                    break;

                case 'foodFight':
                    gameState.foodFightActive = false;
                    break;

                case 'superhero':
                    player.superhero = false;
                    player.canFly = false;
                    break;

                case 'earthquake':
                    gameState.earthquakeActive = false;
                    break;

                case 'pizza':
                    teachers.forEach(t => {
                        t.rushingToPizza = false;
                        t.pizzaTarget = null;
                    });
                    break;

                case 'parents':
                    teachers.forEach(t => t.distracted = false);
                    break;
            }

            eventEntities = [];
            currentEvent = null;
            showMessage(t('eventEnded'));
        }

        function createEarthquakeCracks() {
            // Create 3-5 new openings in walls
            const numCracks = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numCracks; i++) {
                const x = Math.floor(Math.random() * (gameState.mapWidth - 2)) + 1;
                const y = Math.floor(Math.random() * (gameState.mapHeight - 2)) + 1;
                if (gameState.map[y][x] === TILES.WALL) {
                    // Check if it connects two floor tiles
                    const hasFloorNeighbor =
                        (gameState.map[y-1] && gameState.map[y-1][x] === TILES.FLOOR) ||
                        (gameState.map[y+1] && gameState.map[y+1][x] === TILES.FLOOR) ||
                        (gameState.map[y][x-1] === TILES.FLOOR) ||
                        (gameState.map[y][x+1] === TILES.FLOOR);
                    if (hasFloorNeighbor) {
                        gameState.map[y][x] = TILES.FLOOR;
                        spawnParticle(x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2, 'hit');
                    }
                }
            }
        }

        function getRandomFloorPosition() {
            let attempts = 0;
            while (attempts < 100) {
                const x = Math.floor(Math.random() * gameState.mapWidth);
                const y = Math.floor(Math.random() * gameState.mapHeight);
                if (gameState.map[y] && gameState.map[y][x] === TILES.FLOOR) {
                    return { x: x * TILE_SIZE + TILE_SIZE/2, y: y * TILE_SIZE + TILE_SIZE/2 };
                }
                attempts++;
            }
            return { x: player.x, y: player.y };
        }

        function drawEventEntities(ctx) {
            eventEntities.forEach(entity => {
                const screenX = entity.x - gameState.camera.x;
                const screenY = entity.y - gameState.camera.y;

                switch (entity.type) {
                    case 'ufo':
                        // Draw UFO
                        ctx.save();
                        ctx.translate(screenX, screenY);

                        // UFO body
                        ctx.fillStyle = '#888';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 40, 15, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#4af';
                        ctx.beginPath();
                        ctx.ellipse(0, -8, 20, 12, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Beam
                        if (entity.beamActive) {
                            ctx.fillStyle = 'rgba(100, 255, 100, 0.3)';
                            ctx.beginPath();
                            ctx.moveTo(-30, 15);
                            ctx.lineTo(30, 15);
                            ctx.lineTo(60, 200);
                            ctx.lineTo(-60, 200);
                            ctx.closePath();
                            ctx.fill();
                        }
                        ctx.restore();
                        break;

                    case 'dinosaur':
                        ctx.save();
                        ctx.translate(screenX, screenY);
                        ctx.font = entity.variant === 'trex' ? '48px Arial' : '36px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(entity.variant === 'trex' ? 'ü¶ñ' : 'ü¶ï', 0, 0);
                        ctx.restore();
                        break;

                    case 'parent':
                        ctx.save();
                        ctx.translate(screenX, screenY);
                        ctx.font = '32px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üë®‚Äçüë©‚Äçüëß', 0, 0);
                        ctx.restore();
                        break;

                    case 'principal':
                        const dispX = (entity.displayX || entity.x) - gameState.camera.x;
                        const dispY = (entity.displayY || entity.y) - gameState.camera.y;
                        ctx.save();
                        ctx.translate(dispX, dispY);
                        ctx.font = '36px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üé©', 0, -15);
                        ctx.fillText('üëî', 0, 10);
                        ctx.restore();
                        break;

                    case 'ghost':
                        ctx.save();
                        ctx.globalAlpha = entity.alpha || 0.7;
                        ctx.translate(screenX, screenY);
                        ctx.font = '40px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üëª', 0, 0);
                        ctx.restore();
                        break;

                    case 'food':
                        ctx.save();
                        ctx.translate(screenX, screenY);
                        ctx.font = '24px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(entity.foodType, 0, 0);
                        ctx.restore();
                        break;

                    case 'pizza':
                        ctx.save();
                        ctx.translate(screenX, screenY);
                        ctx.font = '36px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üõµ', 0, -10);
                        ctx.fillText('üçï', 15, 5);
                        ctx.restore();
                        break;
                }
            });

            // Draw power outage effect
            if (gameState.powerOutage) {
                ctx.save();
                // Dark overlay with flashlight effect around player
                const playerScreenX = player.x - gameState.camera.x;
                const playerScreenY = player.y - gameState.camera.y;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Flashlight circle
                ctx.globalCompositeOperation = 'destination-out';
                const gradient = ctx.createRadialGradient(playerScreenX, playerScreenY, 0, playerScreenX, playerScreenY, 120);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
                gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(playerScreenX, playerScreenY, 120, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Draw time freeze effect
            if (gameState.timeFreeze) {
                ctx.save();
                ctx.fillStyle = 'rgba(100, 150, 255, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            // Draw fire drill effect (flashing red)
            if (gameState.fireDrillActive && Math.floor(Date.now() / 200) % 2 === 0) {
                ctx.save();
                ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            // Draw current event indicator
            if (currentEvent) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width / 2 - 80, 10, 160, 30);
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${currentEvent.icon} ${Math.ceil(eventTimer)}s`, canvas.width / 2, 30);
                ctx.restore();
            }
        }

        // ============================================
        // MAP GENERATION
        // ============================================

        function generateMap() {
            const sizeConfigs = {
                small: { width: 25, height: 19 },
                medium: { width: 35, height: 27 },
                large: { width: 50, height: 38 }
            };

            const schoolConfigs = {
                elementary: { roomChance: 0.3, obstacleChance: 0.1, corridorWidth: 3 },
                middle: { roomChance: 0.4, obstacleChance: 0.15, corridorWidth: 2 },
                high: { roomChance: 0.5, obstacleChance: 0.2, corridorWidth: 2 },
                university: { roomChance: 0.6, obstacleChance: 0.25, corridorWidth: 2 }
            };

            let size, config, numTeachers, numCollectibles, speedMultiplier;

            if (gameMode === 'campaign') {
                const level = LEVELS[currentLevel];
                size = { width: level.mapSize.w, height: level.mapSize.h };
                config = schoolConfigs[level.schoolType];
                numTeachers = level.teachers;
                numCollectibles = level.collectibles;
                speedMultiplier = level.speed;
                gameState.level = level.id;
            } else {
                size = sizeConfigs[settings.mapSize];
                config = schoolConfigs[settings.schoolType];
                numTeachers = settings.teacherCount;
                numCollectibles = Math.floor(size.width * size.height / 30) + 10;
                speedMultiplier = 1.0;
            }

            // Get map generation settings (applies to both modes)
            const topology = settings.mapTopology;
            const corridorDensity = settings.corridorDensity;
            const roomDensity = settings.roomDensity;

            gameState.mapWidth = size.width;
            gameState.mapHeight = size.height;

            // Initialize map with walls
            gameState.map = Array(size.height).fill(null).map(() =>
                Array(size.width).fill(TILES.WALL)
            );

            // Generate main corridors with topology
            generateCorridors(config.corridorWidth, topology, corridorDensity);

            // Generate rooms with density
            generateRooms(config.roomChance, roomDensity);

            // Add obstacles
            addObstacles(config.obstacleChance);

            // Place exit
            placeExit();

            // Place player start
            placePlayer();

            // Place collectibles
            placeCollectibles(numCollectibles);

            // Place power-ups
            placePowerups();

            // Place teachers
            placeTeachers(numTeachers, speedMultiplier);
        }

        function generateCorridors(width, topology, density) {
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            // Density multipliers for corridor count
            const densityMultipliers = { low: 0.6, medium: 1.0, high: 1.5 };
            const densityMult = densityMultipliers[density] || 1.0;

            switch (topology) {
                case 'labyrinth':
                    generateLabyrinth(width, densityMult);
                    break;
                case 'corridors':
                    generateDenseCorridors(width, densityMult);
                    break;
                case 'openPlan':
                    generateOpenPlan(width, densityMult);
                    break;
                case 'grid':
                default:
                    generateGridCorridors(width, densityMult);
                    break;
            }
        }

        // Classic grid layout with main corridors
        function generateGridCorridors(width, densityMult) {
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            // Main horizontal corridor
            const mainY = Math.floor(mapH / 2);
            for (let x = 1; x < mapW - 1; x++) {
                for (let dy = -Math.floor(width / 2); dy <= Math.floor(width / 2); dy++) {
                    if (mainY + dy > 0 && mainY + dy < mapH - 1) {
                        gameState.map[mainY + dy][x] = TILES.FLOOR;
                    }
                }
            }

            // Vertical corridors - more with higher density
            const baseVertical = Math.floor(mapW / 10) + 1;
            const numVertical = Math.floor(baseVertical * densityMult);
            for (let i = 0; i < numVertical; i++) {
                const x = Math.floor((i + 0.5) * mapW / numVertical);
                for (let y = 1; y < mapH - 1; y++) {
                    for (let dx = -Math.floor(width / 2); dx <= Math.floor(width / 2); dx++) {
                        if (x + dx > 0 && x + dx < mapW - 1) {
                            gameState.map[y][x + dx] = TILES.FLOOR;
                        }
                    }
                }
            }

            // Additional horizontal corridors based on density
            const numHorizontal = Math.floor(Math.max(0, (mapH - 15) / 8) * densityMult);
            for (let i = 0; i < numHorizontal; i++) {
                const y = Math.floor((i + 1) * mapH / (numHorizontal + 2));
                if (Math.abs(y - mainY) > 3) { // Don't overlap with main corridor
                    for (let x = 1; x < mapW - 1; x++) {
                        for (let dy = -Math.floor(width / 2); dy <= Math.floor(width / 2); dy++) {
                            if (y + dy > 0 && y + dy < mapH - 1) {
                                gameState.map[y + dy][x] = TILES.FLOOR;
                            }
                        }
                    }
                }
            }
        }

        // Maze-like labyrinth using recursive backtracking
        function generateLabyrinth(width, densityMult) {
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            // Use a cell-based approach for maze generation
            // Density affects cell size: higher density = smaller cells = more corridors
            const baseCellSize = 3;
            const adjustedCellSize = Math.max(2, Math.floor(baseCellSize / Math.sqrt(densityMult)));
            const cellW = Math.floor((mapW - 2) / adjustedCellSize);
            const cellH = Math.floor((mapH - 2) / adjustedCellSize);

            // Track visited cells
            const visited = Array(cellH).fill(null).map(() => Array(cellW).fill(false));
            const stack = [];

            // Start from center
            let cx = Math.floor(cellW / 2);
            let cy = Math.floor(cellH / 2);
            visited[cy][cx] = true;
            stack.push({ x: cx, y: cy });

            // Carve initial cell
            const halfCell = Math.floor(adjustedCellSize / 2);
            const carveCell = (cellX, cellY) => {
                const px = 1 + cellX * adjustedCellSize + halfCell;
                const py = 1 + cellY * adjustedCellSize + halfCell;
                for (let dy = -halfCell; dy <= halfCell; dy++) {
                    for (let dx = -halfCell; dx <= halfCell; dx++) {
                        if (py + dy > 0 && py + dy < mapH - 1 && px + dx > 0 && px + dx < mapW - 1) {
                            gameState.map[py + dy][px + dx] = TILES.FLOOR;
                        }
                    }
                }
            };

            // Carve passage between cells
            const carvePassage = (x1, y1, x2, y2) => {
                const px1 = 1 + x1 * adjustedCellSize + halfCell;
                const py1 = 1 + y1 * adjustedCellSize + halfCell;
                const px2 = 1 + x2 * adjustedCellSize + halfCell;
                const py2 = 1 + y2 * adjustedCellSize + halfCell;

                const minX = Math.min(px1, px2);
                const maxX = Math.max(px1, px2);
                const minY = Math.min(py1, py2);
                const maxY = Math.max(py1, py2);

                for (let y = minY; y <= maxY; y++) {
                    for (let x = minX; x <= maxX; x++) {
                        if (y > 0 && y < mapH - 1 && x > 0 && x < mapW - 1) {
                            gameState.map[y][x] = TILES.FLOOR;
                        }
                    }
                }
            };

            carveCell(cx, cy);

            // Recursive backtracking
            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];

                const dirs = [
                    { dx: 0, dy: -1 },
                    { dx: 1, dy: 0 },
                    { dx: 0, dy: 1 },
                    { dx: -1, dy: 0 }
                ];

                for (const dir of dirs) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    if (nx >= 0 && nx < cellW && ny >= 0 && ny < cellH && !visited[ny][nx]) {
                        neighbors.push({ x: nx, y: ny });
                    }
                }

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    visited[next.y][next.x] = true;
                    carvePassage(current.x, current.y, next.x, next.y);
                    carveCell(next.x, next.y);
                    stack.push(next);
                } else {
                    stack.pop();
                }
            }

            // Ensure left and right sides are accessible (for player start and exit)
            const midY = Math.floor(mapH / 2);
            for (let x = 1; x < 4; x++) {
                gameState.map[midY][x] = TILES.FLOOR;
                if (midY > 1) gameState.map[midY - 1][x] = TILES.FLOOR;
                if (midY < mapH - 2) gameState.map[midY + 1][x] = TILES.FLOOR;
            }
            for (let x = mapW - 4; x < mapW - 1; x++) {
                gameState.map[midY][x] = TILES.FLOOR;
                if (midY > 1) gameState.map[midY - 1][x] = TILES.FLOOR;
                if (midY < mapH - 2) gameState.map[midY + 1][x] = TILES.FLOOR;
            }
        }

        // Dense network of interconnected corridors
        function generateDenseCorridors(width, densityMult) {
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            // Create many horizontal corridors
            const numHorizontal = Math.floor((mapH / 5) * densityMult) + 2;
            for (let i = 0; i < numHorizontal; i++) {
                const y = Math.floor((i + 0.5) * mapH / numHorizontal);
                const startX = Math.floor(Math.random() * 3) + 1;
                const endX = mapW - Math.floor(Math.random() * 3) - 2;

                for (let x = startX; x <= endX; x++) {
                    for (let dy = -Math.floor(width / 2); dy <= Math.floor(width / 2); dy++) {
                        if (y + dy > 0 && y + dy < mapH - 1) {
                            gameState.map[y + dy][x] = TILES.FLOOR;
                        }
                    }
                }
            }

            // Create many vertical corridors
            const numVertical = Math.floor((mapW / 5) * densityMult) + 2;
            for (let i = 0; i < numVertical; i++) {
                const x = Math.floor((i + 0.5) * mapW / numVertical);
                const startY = Math.floor(Math.random() * 3) + 1;
                const endY = mapH - Math.floor(Math.random() * 3) - 2;

                for (let y = startY; y <= endY; y++) {
                    for (let dx = -Math.floor(width / 2); dx <= Math.floor(width / 2); dx++) {
                        if (x + dx > 0 && x + dx < mapW - 1) {
                            gameState.map[y][x + dx] = TILES.FLOOR;
                        }
                    }
                }
            }

            // Add some diagonal connections for extra complexity
            const numDiagonals = Math.floor(3 * densityMult);
            for (let i = 0; i < numDiagonals; i++) {
                const startX = Math.floor(Math.random() * (mapW - 10)) + 5;
                const startY = Math.floor(Math.random() * (mapH - 10)) + 5;
                const length = Math.floor(Math.random() * 8) + 5;
                const dirX = Math.random() < 0.5 ? 1 : -1;
                const dirY = Math.random() < 0.5 ? 1 : -1;

                for (let step = 0; step < length; step++) {
                    const x = startX + step * dirX;
                    const y = startY + step * dirY;
                    if (x > 0 && x < mapW - 1 && y > 0 && y < mapH - 1) {
                        gameState.map[y][x] = TILES.FLOOR;
                        if (x + 1 < mapW - 1) gameState.map[y][x + 1] = TILES.FLOOR;
                        if (y + 1 < mapH - 1) gameState.map[y + 1][x] = TILES.FLOOR;
                    }
                }
            }
        }

        // Open plan with large open areas and minimal walls
        function generateOpenPlan(width, densityMult) {
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            // Density affects margins: higher density = smaller margins = larger open area
            // and more internal structure (pillars)
            const baseMarginX = Math.floor(mapW * 0.1) + 1;
            const baseMarginY = Math.floor(mapH * 0.1) + 1;
            const marginX = Math.max(1, Math.floor(baseMarginX / densityMult));
            const marginY = Math.max(1, Math.floor(baseMarginY / densityMult));

            for (let y = marginY; y < mapH - marginY; y++) {
                for (let x = marginX; x < mapW - marginX; x++) {
                    gameState.map[y][x] = TILES.FLOOR;
                }
            }

            // Add some structural pillars/walls for visual interest
            // Higher density = more pillars
            const numPillars = Math.floor((mapW * mapH) / 80 * densityMult);
            for (let i = 0; i < numPillars; i++) {
                const px = Math.floor(Math.random() * (mapW - marginX * 2 - 4)) + marginX + 2;
                const py = Math.floor(Math.random() * (mapH - marginY * 2 - 4)) + marginY + 2;
                const pillarSize = Math.floor(Math.random() * 2) + 2;

                for (let dy = 0; dy < pillarSize; dy++) {
                    for (let dx = 0; dx < pillarSize; dx++) {
                        if (py + dy < mapH - marginY && px + dx < mapW - marginX) {
                            gameState.map[py + dy][px + dx] = TILES.WALL;
                        }
                    }
                }
            }

            // Ensure edges are accessible
            const midY = Math.floor(mapH / 2);
            for (let x = 1; x < marginX + 2; x++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (midY + dy > 0 && midY + dy < mapH - 1) {
                        gameState.map[midY + dy][x] = TILES.FLOOR;
                    }
                }
            }
            for (let x = mapW - marginX - 2; x < mapW - 1; x++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (midY + dy > 0 && midY + dy < mapH - 1) {
                        gameState.map[midY + dy][x] = TILES.FLOOR;
                    }
                }
            }
        }

        function generateRooms(roomChance, roomDensity) {
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;
            const roomSizes = [
                { w: 5, h: 4 },
                { w: 6, h: 5 },
                { w: 7, h: 5 },
                { w: 8, h: 6 }
            ];

            // Room density multipliers
            const densityMultipliers = { few: 0.5, normal: 1.0, many: 1.8 };
            const densityMult = densityMultipliers[roomDensity] || 1.0;

            const numRooms = Math.floor(mapW * mapH * roomChance * densityMult / 30);

            for (let i = 0; i < numRooms; i++) {
                const roomSize = roomSizes[Math.floor(Math.random() * roomSizes.length)];
                const roomX = Math.floor(Math.random() * (mapW - roomSize.w - 2)) + 1;
                const roomY = Math.floor(Math.random() * (mapH - roomSize.h - 2)) + 1;

                // Check if room overlaps corridor
                let touchesCorridor = false;
                for (let y = roomY; y < roomY + roomSize.h && !touchesCorridor; y++) {
                    for (let x = roomX; x < roomX + roomSize.w; x++) {
                        if (gameState.map[y][x] === TILES.FLOOR) {
                            touchesCorridor = true;
                            break;
                        }
                    }
                }

                if (touchesCorridor) {
                    // Carve out the room
                    for (let y = roomY; y < roomY + roomSize.h; y++) {
                        for (let x = roomX; x < roomX + roomSize.w; x++) {
                            gameState.map[y][x] = TILES.FLOOR;
                        }
                    }

                    // Add desks in classroom pattern
                    if (Math.random() < 0.7) {
                        for (let y = roomY + 1; y < roomY + roomSize.h - 1; y += 2) {
                            for (let x = roomX + 1; x < roomX + roomSize.w - 1; x += 2) {
                                if (Math.random() < 0.6) {
                                    gameState.map[y][x] = TILES.DESK;
                                }
                            }
                        }
                    }
                }
            }
        }

        function addObstacles(obstacleChance) {
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            for (let y = 1; y < mapH - 1; y++) {
                for (let x = 1; x < mapW - 1; x++) {
                    if (gameState.map[y][x] === TILES.FLOOR && Math.random() < obstacleChance * 0.3) {
                        // Check it's not blocking a corridor completely
                        const neighbors = [
                            gameState.map[y - 1][x],
                            gameState.map[y + 1][x],
                            gameState.map[y][x - 1],
                            gameState.map[y][x + 1]
                        ];
                        const floorNeighbors = neighbors.filter(t => t === TILES.FLOOR || t === TILES.DESK).length;

                        if (floorNeighbors >= 2) {
                            const obstacleType = Math.random();
                            if (obstacleType < 0.4) {
                                gameState.map[y][x] = TILES.LOCKER;
                            } else if (obstacleType < 0.6) {
                                gameState.map[y][x] = TILES.WET_FLOOR;
                            }
                        }
                    }
                }
            }
        }

        function placeExit() {
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            // Place exit on the opposite side from where player will start
            for (let x = mapW - 2; x > mapW / 2; x--) {
                for (let y = 1; y < mapH - 1; y++) {
                    if (gameState.map[y][x] === TILES.FLOOR) {
                        gameState.map[y][x] = TILES.EXIT;
                        return;
                    }
                }
            }
        }

        function placePlayer() {
            const mapH = gameState.mapHeight;

            // Find starting position on left side
            for (let x = 1; x < 5; x++) {
                for (let y = 1; y < mapH - 1; y++) {
                    if (gameState.map[y][x] === TILES.FLOOR) {
                        player.x = x * TILE_SIZE + TILE_SIZE / 2;
                        player.y = y * TILE_SIZE + TILE_SIZE / 2;
                        return;
                    }
                }
            }
        }

        function placeCollectibles(count) {
            gameState.collectibles = [];
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            const numCollectibles = count || Math.floor(mapW * mapH / 30) + 10;

            let placed = 0;
            let attempts = 0;
            while (placed < numCollectibles && attempts < 1000) {
                const x = Math.floor(Math.random() * (mapW - 2)) + 1;
                const y = Math.floor(Math.random() * (mapH - 2)) + 1;

                if (gameState.map[y][x] === TILES.FLOOR) {
                    // Check not too close to player
                    const px = player.x / TILE_SIZE;
                    const py = player.y / TILE_SIZE;
                    if (Math.abs(x - px) + Math.abs(y - py) > 3) {
                        gameState.collectibles.push({
                            id: placed, // ID for multiplayer sync
                            x: x * TILE_SIZE + TILE_SIZE / 2,
                            y: y * TILE_SIZE + TILE_SIZE / 2,
                            collected: false,
                            type: 'homework',
                            animOffset: Math.random() * Math.PI * 2
                        });
                        placed++;
                    }
                }
                attempts++;
            }
        }

        function placePowerups() {
            gameState.powerups = [];
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            const powerupTypes = ['hallpass', 'energydrink', 'stinkbomb', 'skateboard'];
            const numPowerups = Math.floor(mapW * mapH / 80) + 3;

            let placed = 0;
            let attempts = 0;
            while (placed < numPowerups && attempts < 500) {
                const x = Math.floor(Math.random() * (mapW - 2)) + 1;
                const y = Math.floor(Math.random() * (mapH - 2)) + 1;

                if (gameState.map[y][x] === TILES.FLOOR) {
                    gameState.powerups.push({
                        id: placed, // ID for multiplayer sync
                        x: x * TILE_SIZE + TILE_SIZE / 2,
                        y: y * TILE_SIZE + TILE_SIZE / 2,
                        collected: false,
                        type: powerupTypes[Math.floor(Math.random() * powerupTypes.length)],
                        animOffset: Math.random() * Math.PI * 2
                    });
                    placed++;
                }
                attempts++;
            }
        }

        function placeTeachers(count, speedMultiplier = 1.0) {
            teachers = [];
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            const teacherTypes = ['patrol', 'hunter', 'fast'];
            const numTeachers = count || settings.teacherCount;
            gameState.speedMultiplier = speedMultiplier;

            let placed = 0;
            let attempts = 0;
            while (placed < numTeachers && attempts < 500) {
                const x = Math.floor(Math.random() * (mapW - 4)) + 2;
                const y = Math.floor(Math.random() * (mapH - 4)) + 2;

                if (gameState.map[y][x] === TILES.FLOOR) {
                    // Not too close to player start
                    const px = player.x / TILE_SIZE;
                    const py = player.y / TILE_SIZE;
                    if (Math.abs(x - px) + Math.abs(y - py) > 8) {
                        const type = teacherTypes[placed % teacherTypes.length];
                        const teacher = createTeacher(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, type);
                        teacher.id = placed; // ID for multiplayer sync
                        teachers.push(teacher);
                        placed++;
                    }
                }
                attempts++;
            }
        }

        function createTeacher(x, y, type) {
            const baseSpeed = {
                patrol: 2,
                hunter: 2.5,
                fast: 3.5
            };

            const difficultyMultiplier = {
                elementary: 0.7,
                middle: 1,
                high: 1.2,
                university: 1.4
            };

            // Use campaign speed multiplier if in campaign mode
            const campaignMultiplier = gameState.speedMultiplier || 1.0;
            const schoolMultiplier = gameMode === 'campaign' ? 1.0 : difficultyMultiplier[settings.schoolType];

            return {
                x: x,
                y: y,
                vx: 0,
                vy: 0,
                speed: baseSpeed[type] * schoolMultiplier * campaignMultiplier,
                type: type,
                direction: Math.floor(Math.random() * 4),
                patrolTimer: 0,
                chaseTimer: 0,
                stunned: false,
                stunnedTimer: 0,
                seesPlayer: false,
                animFrame: 0,
                patrolPath: generatePatrolPath(x, y)
            };
        }

        function generatePatrolPath(startX, startY) {
            // Simple patrol: move in a square pattern
            const size = (Math.random() * 3 + 2) * TILE_SIZE;
            return [
                { x: startX, y: startY },
                { x: startX + size, y: startY },
                { x: startX + size, y: startY + size },
                { x: startX, y: startY + size }
            ];
        }

        // ============================================
        // GAME LOGIC
        // ============================================

        function update(deltaTime) {
            if (!gameState.running || gameState.paused) return;

            // Update timers
            updateTimers(deltaTime);

            // Update random events
            updateEvents(deltaTime);

            // Update player
            updatePlayer(deltaTime);

            // Update teachers
            updateTeachers(deltaTime);

            // Check collisions
            checkCollisions();

            // Update particles
            updateParticles(deltaTime);

            // Update camera
            updateCamera();

            // Check win condition
            checkWinCondition();

            // Multiplayer updates
            if (mpState.active) {
                updateMyPresence();
                updateMultiplayerHUD();

                // Host broadcasts teacher positions periodically
                if (mpState.isHost) {
                    mpState.teacherBroadcastTimer = (mpState.teacherBroadcastTimer || 0) + deltaTime;
                    if (mpState.teacherBroadcastTimer > 0.1) { // 10 times per second
                        broadcastTeacherPositions();
                        mpState.teacherBroadcastTimer = 0;
                    }
                }
            }
        }

        function updateTimers(deltaTime) {
            // Combo timer
            if (gameState.comboTimer > 0) {
                gameState.comboTimer -= deltaTime;
                if (gameState.comboTimer <= 0) {
                    gameState.combo = 1;
                    updateUI();
                }
            }

            // Screen shake
            if (gameState.screenShake > 0) {
                gameState.screenShake -= deltaTime * 10;
            }

            // Player dash cooldown
            if (player.dashCooldown > 0) {
                player.dashCooldown -= deltaTime;
            }

            // Dash duration
            if (player.isDashing) {
                player.dashTimer -= deltaTime;
                if (player.dashTimer <= 0) {
                    player.isDashing = false;
                }
            }

            // Invincibility
            if (player.invincible) {
                player.invincibleTimer -= deltaTime;
                if (player.invincibleTimer <= 0) {
                    player.invincible = false;
                }
            }

            // Speed boost
            if (player.speedBoost) {
                player.speedBoostTimer -= deltaTime;
                if (player.speedBoostTimer <= 0) {
                    player.speedBoost = false;
                }
            }

            // Active powerups
            gameState.activePowerups = gameState.activePowerups.filter(p => {
                p.timer -= deltaTime;
                return p.timer > 0;
            });
        }

        function updatePlayer(deltaTime) {
            // Get input
            let dx = 0, dy = 0;
            if (keys['ArrowLeft'] || keys['KeyA']) dx -= 1;
            if (keys['ArrowRight'] || keys['KeyD']) dx += 1;
            if (keys['ArrowUp'] || keys['KeyW']) dy -= 1;
            if (keys['ArrowDown'] || keys['KeyS']) dy += 1;

            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }

            // Calculate speed
            let currentSpeed = player.speed;
            if (player.isDashing) currentSpeed *= 2.5;
            if (player.speedBoost) currentSpeed *= 1.5;
            if (player.superhero) currentSpeed *= 2.0; // Superhero speed boost

            // Check for wet floor
            const tileX = Math.floor(player.x / TILE_SIZE);
            const tileY = Math.floor(player.y / TILE_SIZE);
            if (gameState.map[tileY] && gameState.map[tileY][tileX] === TILES.WET_FLOOR) {
                currentSpeed *= 1.3; // Slide faster but less control
                player.vx += dx * currentSpeed * 0.3;
                player.vy += dy * currentSpeed * 0.3;
                player.vx *= 0.95;
                player.vy *= 0.95;
            } else {
                player.vx = dx * currentSpeed;
                player.vy = dy * currentSpeed;
            }

            // Update position with collision
            const newX = player.x + player.vx;
            const newY = player.y + player.vy;

            // Superhero can fly through walls
            if (player.canFly) {
                // Just keep within map bounds
                player.x = Math.max(PLAYER_SIZE, Math.min(newX, gameState.mapWidth * TILE_SIZE - PLAYER_SIZE));
                player.y = Math.max(PLAYER_SIZE, Math.min(newY, gameState.mapHeight * TILE_SIZE - PLAYER_SIZE));
            } else {
                if (!checkWallCollision(newX, player.y, PLAYER_SIZE)) {
                    player.x = newX;
                }
                if (!checkWallCollision(player.x, newY, PLAYER_SIZE)) {
                    player.y = newY;
                }
            }

            // Update direction
            if (dx > 0) player.direction = 0;
            else if (dx < 0) player.direction = 2;
            else if (dy > 0) player.direction = 1;
            else if (dy < 0) player.direction = 3;

            // Animation
            if (dx !== 0 || dy !== 0) {
                player.animFrame += 0.2;
            }

            // Dash particles
            if (player.isDashing) {
                spawnParticle(player.x, player.y, 'dash');
            }
        }

        function updateTeachers(deltaTime) {
            for (const teacher of teachers) {
                // Handle frozen state (from events)
                if (teacher.frozen) {
                    teacher.vx = 0;
                    teacher.vy = 0;
                    continue;
                }

                if (teacher.stunned) {
                    teacher.stunnedTimer -= deltaTime;
                    if (teacher.stunnedTimer <= 0) {
                        teacher.stunned = false;
                    }
                    continue;
                }

                // Handle scared state (from ghost)
                if (teacher.scaredTimer > 0) {
                    teacher.scaredTimer -= deltaTime;
                    // Just run in current direction
                    const newX = teacher.x + teacher.vx * deltaTime * 60;
                    const newY = teacher.y + teacher.vy * deltaTime * 60;
                    if (!checkWallCollision(newX, teacher.y, TEACHER_SIZE)) teacher.x = newX;
                    if (!checkWallCollision(teacher.x, newY, TEACHER_SIZE)) teacher.y = newY;
                    continue;
                }

                // Handle pizza delivery event - rush to pizza
                if (teacher.rushingToPizza && teacher.pizzaTarget) {
                    const pdx = teacher.pizzaTarget.x - teacher.x;
                    const pdy = teacher.pizzaTarget.y - teacher.y;
                    const pDist = Math.sqrt(pdx * pdx + pdy * pdy);
                    if (pDist > 20) {
                        teacher.vx = (pdx / pDist) * teacher.speed * 1.5;
                        teacher.vy = (pdy / pDist) * teacher.speed * 1.5;
                    } else {
                        teacher.vx = 0;
                        teacher.vy = 0;
                    }
                    const newX = teacher.x + teacher.vx;
                    const newY = teacher.y + teacher.vy;
                    if (!checkWallCollision(newX, teacher.y, TEACHER_SIZE)) teacher.x = newX;
                    if (!checkWallCollision(teacher.x, newY, TEACHER_SIZE)) teacher.y = newY;
                    continue;
                }

                // Speed modifier from distraction (parents visiting)
                const speedMod = teacher.distracted ? 0.5 : 1.0;

                // Check if teacher sees player (not during power outage)
                const dx = player.x - teacher.x;
                const dy = player.y - teacher.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const sightRange = teacher.type === 'hunter' ? 200 : 150;

                // Teachers can't see well during power outage
                const effectiveSightRange = gameState.powerOutage ? sightRange * 0.3 : sightRange;

                // Check if player is within the vision cone angle (¬±60¬∞ from facing direction)
                const dirAngles = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
                const faceAngle = dirAngles[teacher.direction];
                const angleToPlayer = Math.atan2(dy, dx);
                let angleDiff = angleToPlayer - faceAngle;
                // Normalize angle difference to [-œÄ, œÄ]
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                const inCone = Math.abs(angleDiff) <= Math.PI / 3;

                const nowSeesPlayer = dist < effectiveSightRange && inCone && hasLineOfSight(teacher.x, teacher.y, player.x, player.y);

                // Play alert sound when teacher first spots player
                if (nowSeesPlayer && !teacher.seesPlayer) {
                    playSound('alert');
                }
                teacher.seesPlayer = nowSeesPlayer;

                // Patrol teacher reports player location to other teachers
                if (teacher.seesPlayer && teacher.type === 'patrol') {
                    gameState.reportedPlayerLocation = {
                        x: player.x,
                        y: player.y,
                        time: Date.now()
                    };
                }

                // Different AI behaviors
                if (teacher.seesPlayer && teacher.type !== 'patrol') {
                    // Chase player
                    teacher.chaseTimer = 3;
                    const angle = Math.atan2(dy, dx);
                    teacher.vx = Math.cos(angle) * teacher.speed * 1.3 * speedMod;
                    teacher.vy = Math.sin(angle) * teacher.speed * 1.3 * speedMod;
                } else if (teacher.chaseTimer > 0) {
                    teacher.chaseTimer -= deltaTime;
                    // Continue moving toward last known position
                } else if (!teacher.seesPlayer && teacher.chaseTimer <= 0 && teacher.type !== 'patrol' && gameState.reportedPlayerLocation) {
                    // Hunter/Fast teachers respond to patrol's reported player location
                    // Only when not currently chasing a player they saw themselves
                    const report = gameState.reportedPlayerLocation;
                    const reportAge = (Date.now() - report.time) / 1000;

                    // Only respond to reports less than 5 seconds old
                    if (reportAge < 5) {
                        const rdx = report.x - teacher.x;
                        const rdy = report.y - teacher.y;
                        const rdist = Math.sqrt(rdx * rdx + rdy * rdy);

                        // Move toward reported location if not already there
                        if (rdist > TILE_SIZE) {
                            const angle = Math.atan2(rdy, rdx);
                            teacher.vx = Math.cos(angle) * teacher.speed * speedMod;
                            teacher.vy = Math.sin(angle) * teacher.speed * speedMod;
                        } else {
                            // Arrived at reported location, patrol normally
                            updatePatrol(teacher, deltaTime);
                            teacher.vx *= speedMod;
                            teacher.vy *= speedMod;
                        }
                    } else {
                        // Report too old, patrol normally
                        updatePatrol(teacher, deltaTime);
                        teacher.vx *= speedMod;
                        teacher.vy *= speedMod;
                    }
                } else {
                    // Patrol behavior
                    updatePatrol(teacher, deltaTime);
                    teacher.vx *= speedMod;
                    teacher.vy *= speedMod;
                }

                // Apply movement with collision
                const newX = teacher.x + teacher.vx;
                const newY = teacher.y + teacher.vy;

                let hitWall = false;
                if (!checkWallCollision(newX, teacher.y, TEACHER_SIZE)) {
                    teacher.x = newX;
                } else {
                    teacher.vx = -teacher.vx;
                    hitWall = true;
                }
                if (!checkWallCollision(teacher.x, newY, TEACHER_SIZE)) {
                    teacher.y = newY;
                } else {
                    teacher.vy = -teacher.vy;
                    hitWall = true;
                }

                // Force direction change on wall collision for patrol teachers
                // This prevents getting stuck when updatePatrol overwrites reversed velocity
                if (hitWall && teacher.chaseTimer <= 0 && !teacher.seesPlayer) {
                    teacher.patrolTimer = 3; // Force immediate direction change next frame
                }

                // Update direction based on velocity (for hunters/fast teachers that chase)
                if (teacher.vx !== 0 || teacher.vy !== 0) {
                    // Face the dominant direction of movement
                    if (Math.abs(teacher.vx) > Math.abs(teacher.vy)) {
                        teacher.direction = teacher.vx > 0 ? 0 : 2; // right or left
                    } else {
                        teacher.direction = teacher.vy > 0 ? 1 : 3; // down or up
                    }
                }

                // Animation
                teacher.animFrame += 0.15;
            }
        }

        function updatePatrol(teacher, deltaTime) {
            teacher.patrolTimer += deltaTime;

            if (teacher.patrolTimer > 2) {
                teacher.patrolTimer = 0;
                teacher.direction = (teacher.direction + 1) % 4;
            }

            const speed = teacher.speed;
            switch (teacher.direction) {
                case 0: teacher.vx = speed; teacher.vy = 0; break;
                case 1: teacher.vx = 0; teacher.vy = speed; break;
                case 2: teacher.vx = -speed; teacher.vy = 0; break;
                case 3: teacher.vx = 0; teacher.vy = -speed; break;
            }
        }

        function hasLineOfSight(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const steps = Math.ceil(dist / TILE_SIZE);

            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = x1 + dx * t;
                const y = y1 + dy * t;
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);

                if (gameState.map[tileY] && gameState.map[tileY][tileX] === TILES.WALL) {
                    return false;
                }
            }
            return true;
        }

        function checkWallCollision(x, y, size) {
            const halfSize = size / 2;
            const corners = [
                { x: x - halfSize, y: y - halfSize },
                { x: x + halfSize, y: y - halfSize },
                { x: x - halfSize, y: y + halfSize },
                { x: x + halfSize, y: y + halfSize }
            ];

            for (const corner of corners) {
                const tileX = Math.floor(corner.x / TILE_SIZE);
                const tileY = Math.floor(corner.y / TILE_SIZE);

                if (tileX < 0 || tileX >= gameState.mapWidth ||
                    tileY < 0 || tileY >= gameState.mapHeight) {
                    return true;
                }

                const tile = gameState.map[tileY][tileX];
                if (tile === TILES.WALL || tile === TILES.LOCKER) {
                    return true;
                }
            }
            return false;
        }

        function checkCollisions() {
            // Collectibles
            for (const item of gameState.collectibles) {
                if (item.collected) continue;

                const dx = player.x - item.x;
                const dy = player.y - item.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < PLAYER_SIZE) {
                    item.collected = true;
                    collectItem(item);
                }
            }

            // Power-ups
            for (const powerup of gameState.powerups) {
                if (powerup.collected) continue;

                const dx = player.x - powerup.x;
                const dy = player.y - powerup.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < PLAYER_SIZE) {
                    powerup.collected = true;
                    collectPowerup(powerup);
                }
            }

            // Teachers (if not invincible)
            if (!player.invincible) {
                for (const teacher of teachers) {
                    if (teacher.stunned) continue;

                    const dx = player.x - teacher.x;
                    const dy = player.y - teacher.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < (PLAYER_SIZE + TEACHER_SIZE) / 2) {
                        playerCaught();
                        break;
                    }
                }
            }
        }

        function collectItem(item) {
            // Broadcast in multiplayer
            if (mpState.active) {
                broadcastCollectiblePickup(item.id);
            }

            // Increase combo
            gameState.combo = Math.min(gameState.combo + 1, 10);
            gameState.comboTimer = 2;

            // Add score
            const points = 100 * gameState.combo;
            gameState.score += points;

            // Play sound with pitch based on combo
            playSound('collect', { combo: gameState.combo });

            // Spawn particles
            for (let i = 0; i < 10; i++) {
                spawnParticle(item.x, item.y, 'collect');
            }

            // Show points
            spawnFloatingText(item.x, item.y, `+${points}`);

            updateUI();
        }

        function collectPowerup(powerup) {
            // Broadcast in multiplayer
            if (mpState.active) {
                broadcastPowerupPickup(powerup.id);
            }

            // Play powerup pickup sound
            playSound('powerup');

            // Find empty slot
            const emptySlot = gameState.playerPowerups.findIndex(p => p === null);
            if (emptySlot !== -1) {
                gameState.playerPowerups[emptySlot] = powerup.type;
                const powerupNames = { hallpass: t('hallPass'), energydrink: t('energyDrink'), stinkbomb: t('stinkBomb'), skateboard: t('skateboard') };
                showMessage(`${t('got')} ${powerupNames[powerup.type]}!`);
            } else {
                // Apply immediately if inventory full
                usePowerup(powerup.type);
            }

            // Particles
            for (let i = 0; i < 15; i++) {
                spawnParticle(powerup.x, powerup.y, 'powerup');
            }

            updateUI();
        }

        function usePowerup(type) {
            // Play activation sound (stink bomb has its own sound)
            if (type !== 'stinkbomb') {
                playSound('powerup_use');
            }

            switch (type) {
                case 'hallpass':
                    player.invincible = true;
                    player.invincibleTimer = 5;
                    showMessage(t('invincible'));
                    break;
                case 'energydrink':
                    player.speedBoost = true;
                    player.speedBoostTimer = 8;
                    showMessage(t('speedBoost'));
                    break;
                case 'stinkbomb':
                    // Play stun sound
                    playSound('stun');
                    // Stun all teachers (in multiplayer, affects everyone)
                    for (const teacher of teachers) {
                        teacher.stunned = true;
                        teacher.stunnedTimer = 4;
                    }
                    showMessage(t('stinkBombMsg'));
                    gameState.screenShake = 5;
                    // Broadcast stink bomb in multiplayer
                    if (mpState.active) {
                        broadcastStinkBomb();
                    }
                    break;
                case 'skateboard':
                    player.speedBoost = true;
                    player.speedBoostTimer = 10;
                    showMessage(t('skateboardMsg'));
                    break;
            }
        }

        function playerCaught() {
            // Play caught sound
            playSound('caught');

            gameState.lives--;
            gameState.combo = 1;
            gameState.screenShake = 10;

            // Spawn particles
            for (let i = 0; i < 20; i++) {
                spawnParticle(player.x, player.y, 'hit');
            }

            if (gameState.lives <= 0) {
                gameOver(false);
            } else {
                // Brief invincibility and reset position
                player.invincible = true;
                player.invincibleTimer = 2;
                showMessage(`${t('caughtMsg')} ${gameState.lives} ${t('livesLeft')}`);
            }

            updateUI();
        }

        function checkWinCondition() {
            // Check if all collectibles collected
            const collected = gameState.collectibles.filter(c => c.collected).length;
            const total = gameState.collectibles.length;

            if (collected === total) {
                // Check if player is at exit
                const tileX = Math.floor(player.x / TILE_SIZE);
                const tileY = Math.floor(player.y / TILE_SIZE);

                if (gameState.map[tileY] && gameState.map[tileY][tileX] === TILES.EXIT) {
                    gameOver(true);
                }
            }
        }

        function gameOver(won) {
            gameState.running = false;
            stopMusic();

            // Play win or lose sound
            playSound(won ? 'win' : 'lose');

            // Add bonus for remaining lives
            if (won) {
                gameState.score += gameState.lives * 500;
            }

            // Get multiplayer scores before showing screens
            const mpScores = mpState.active ? getAllPlayerScores() : null;

            // Broadcast game over to other players in multiplayer
            if (mpState.active && mpState.isHost) {
                broadcastGameOver(won, mpScores);
            }

            // Campaign mode - show level complete screen
            if (gameMode === 'campaign' && won) {
                showLevelCompleteScreen(mpScores);
                return;
            }

            // Free play mode or lost - show game over screen
            showMultiplayerGameOverScreen(won, mpScores);
        }

        // Show game over screen with optional multiplayer scores
        function showMultiplayerGameOverScreen(won, scores) {
            const screen = document.getElementById('game-over-screen');
            const title = screen.querySelector('h2');
            const scoreDisplay = document.getElementById('final-score');
            const statsDisplay = document.getElementById('final-stats');
            const mpScoresContainer = document.getElementById('multiplayer-scores');
            const mpScoresList = document.getElementById('multiplayer-scores-list');

            if (won) {
                title.textContent = t('escaped');
                screen.className = 'menu-screen win';
            } else {
                title.textContent = t('caught');
                screen.className = 'menu-screen lose';
            }

            scoreDisplay.textContent = `${t('score')}: ${gameState.score}`;
            statsDisplay.innerHTML = `
                ${t('itemsCollected')}: ${gameState.collectibles.filter(c => c.collected).length}/${gameState.collectibles.length}<br>
                ${t('livesRemaining')}: ${gameState.lives}
            `;

            // Show multiplayer scores if available
            if (scores && scores.length > 1) {
                mpScoresContainer.style.display = 'block';
                mpScoresList.innerHTML = renderMultiplayerScores(scores);
            } else {
                mpScoresContainer.style.display = 'none';
            }

            screen.classList.remove('hidden');
        }

        // Render multiplayer scores list HTML
        function renderMultiplayerScores(scores) {
            let html = '';
            scores.forEach((player, index) => {
                const rankEmoji = index === 0 ? 'ü•á' : (index === 1 ? 'ü•à' : (index === 2 ? 'ü•â' : ''));
                const selfStyle = player.isSelf ? 'font-weight: bold;' : '';
                html += `
                    <div style="display: flex; align-items: center; gap: 8px; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); ${selfStyle}">
                        <span style="width: 24px; text-align: center;">${rankEmoji || (index + 1)}</span>
                        <div style="width: 12px; height: 12px; background: ${player.color}; border-radius: 50%; border: 1px solid #fff;"></div>
                        <span style="flex: 1; color: ${player.isSelf ? '#4ade80' : '#fff'};">${player.name}${player.isSelf ? ' (you)' : ''}</span>
                        <span style="color: #ffd700;">${player.score}</span>
                    </div>
                `;
            });
            return html;
        }

        // ============================================
        // PARTICLES & EFFECTS
        // ============================================

        function spawnParticle(x, y, type) {
            const colors = {
                collect: ['#ffd700', '#ffec8b', '#fff'],
                powerup: ['#4ade80', '#22d3ee', '#a78bfa'],
                hit: ['#ff6b6b', '#ff0000', '#ff8888'],
                dash: ['#60a5fa', '#3b82f6', '#93c5fd']
            };

            const color = colors[type][Math.floor(Math.random() * colors[type].length)];
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 3 + 1;

            gameState.particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1,
                color: color,
                size: Math.random() * 6 + 2
            });
        }

        function spawnFloatingText(x, y, text) {
            gameState.particles.push({
                x: x,
                y: y,
                vx: 0,
                vy: -2,
                life: 1,
                text: text,
                isText: true
            });
        }

        function updateParticles(deltaTime) {
            gameState.particles = gameState.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= deltaTime * 2;
                if (!p.isText) {
                    p.size *= 0.95;
                }
                return p.life > 0;
            });
        }

        function updateCamera() {
            // Smooth camera follow
            const targetX = player.x - canvas.width / 2;
            const targetY = player.y - canvas.height / 2;

            gameState.camera.x += (targetX - gameState.camera.x) * 0.1;
            gameState.camera.y += (targetY - gameState.camera.y) * 0.1;

            // Clamp to map bounds
            const maxX = gameState.mapWidth * TILE_SIZE - canvas.width;
            const maxY = gameState.mapHeight * TILE_SIZE - canvas.height;

            gameState.camera.x = Math.max(0, Math.min(maxX, gameState.camera.x));
            gameState.camera.y = Math.max(0, Math.min(maxY, gameState.camera.y));
        }

        // ============================================
        // RENDERING
        // ============================================

        function render() {
            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply screen shake
            let shakeX = 0, shakeY = 0;
            if (gameState.screenShake > 0) {
                shakeX = (Math.random() - 0.5) * gameState.screenShake;
                shakeY = (Math.random() - 0.5) * gameState.screenShake;
            }

            ctx.save();
            ctx.translate(-gameState.camera.x + shakeX, -gameState.camera.y + shakeY);

            // Draw map
            drawMap();

            // Draw collectibles
            drawCollectibles();

            // Draw power-ups
            drawPowerups();

            // Draw teachers
            drawTeachers();

            // Draw player
            drawPlayer();

            // Draw other players (multiplayer)
            drawOtherPlayers();

            // Draw particles
            drawParticles();

            // Draw event entities (in world space)
            drawEventEntities(ctx);

            ctx.restore();

            // Draw event effects (in screen space - done inside drawEventEntities)

            // Draw minimap
            drawMinimap();

            requestAnimationFrame(render);
        }

        function drawMap() {
            const startX = Math.floor(gameState.camera.x / TILE_SIZE);
            const startY = Math.floor(gameState.camera.y / TILE_SIZE);
            const endX = Math.min(startX + Math.ceil(canvas.width / TILE_SIZE) + 2, gameState.mapWidth);
            const endY = Math.min(startY + Math.ceil(canvas.height / TILE_SIZE) + 2, gameState.mapHeight);

            for (let y = Math.max(0, startY); y < endY; y++) {
                for (let x = Math.max(0, startX); x < endX; x++) {
                    const tile = gameState.map[y][x];
                    const px = x * TILE_SIZE;
                    const py = y * TILE_SIZE;

                    switch (tile) {
                        case TILES.FLOOR:
                            ctx.fillStyle = '#3d3d5c';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Floor pattern
                            ctx.fillStyle = '#4a4a6a';
                            if ((x + y) % 2 === 0) {
                                ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            }
                            break;

                        case TILES.WALL:
                            // Wall with gradient
                            const gradient = ctx.createLinearGradient(px, py, px, py + TILE_SIZE);
                            gradient.addColorStop(0, '#5c4033');
                            gradient.addColorStop(1, '#3d2817');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Brick pattern
                            ctx.strokeStyle = '#2a1a0a';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(px + 1, py + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                            if (y % 2 === 0) {
                                ctx.beginPath();
                                ctx.moveTo(px + TILE_SIZE / 2, py);
                                ctx.lineTo(px + TILE_SIZE / 2, py + TILE_SIZE);
                                ctx.stroke();
                            }
                            break;

                        case TILES.DESK:
                            // Floor underneath
                            ctx.fillStyle = '#3d3d5c';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Desk
                            ctx.fillStyle = '#8b4513';
                            ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                            ctx.fillStyle = '#a0522d';
                            ctx.fillRect(px + 6, py + 6, TILE_SIZE - 12, TILE_SIZE - 12);
                            break;

                        case TILES.LOCKER:
                            ctx.fillStyle = '#3d3d5c';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Locker
                            ctx.fillStyle = '#4a90a4';
                            ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#5ba3b8';
                            ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, 12);
                            ctx.fillRect(px + 4, py + 18, TILE_SIZE - 8, 12);
                            // Handle
                            ctx.fillStyle = '#333';
                            ctx.fillRect(px + TILE_SIZE - 10, py + 12, 4, 8);
                            break;

                        case TILES.WET_FLOOR:
                            ctx.fillStyle = '#3d3d5c';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Water effect
                            ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Caution pattern
                            ctx.fillStyle = '#ffd700';
                            ctx.beginPath();
                            ctx.moveTo(px + TILE_SIZE / 2, py + 4);
                            ctx.lineTo(px + TILE_SIZE - 4, py + TILE_SIZE - 4);
                            ctx.lineTo(px + 4, py + TILE_SIZE - 4);
                            ctx.closePath();
                            ctx.fill();
                            ctx.fillStyle = '#333';
                            ctx.font = '16px Arial';
                            ctx.fillText('!', px + TILE_SIZE / 2 - 3, py + TILE_SIZE - 8);
                            break;

                        case TILES.EXIT:
                            ctx.fillStyle = '#3d3d5c';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Exit door
                            const allCollected = gameState.collectibles.every(c => c.collected);
                            ctx.fillStyle = allCollected ? '#4ade80' : '#666';
                            ctx.fillRect(px + 4, py + 2, TILE_SIZE - 8, TILE_SIZE - 4);
                            // EXIT sign
                            ctx.fillStyle = allCollected ? '#fff' : '#999';
                            ctx.font = 'bold 10px Arial';
                            ctx.fillText('EXIT', px + 6, py + TILE_SIZE / 2 + 3);
                            // Glow effect if active
                            if (allCollected) {
                                ctx.strokeStyle = '#4ade80';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(px + 2, py, TILE_SIZE - 4, TILE_SIZE);
                            }
                            break;
                    }
                }
            }
        }

        function drawCollectibles() {
            const time = Date.now() / 1000;

            for (const item of gameState.collectibles) {
                if (item.collected) continue;

                const bobY = Math.sin(time * 3 + item.animOffset) * 3;

                // Glow
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(item.x, item.y + bobY, 15, 0, Math.PI * 2);
                ctx.fill();

                // Paper/homework icon
                ctx.fillStyle = '#fff';
                ctx.fillRect(item.x - 8, item.y - 10 + bobY, 16, 20);
                ctx.fillStyle = '#333';
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(item.x - 5, item.y - 6 + i * 5 + bobY, 10, 2);
                }
            }
        }

        function drawPowerups() {
            const time = Date.now() / 1000;

            for (const powerup of gameState.powerups) {
                if (powerup.collected) continue;

                const bobY = Math.sin(time * 2 + powerup.animOffset) * 4;
                const scale = 1 + Math.sin(time * 4) * 0.1;

                ctx.save();
                ctx.translate(powerup.x, powerup.y + bobY);
                ctx.scale(scale, scale);

                // Draw based on type
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                switch (powerup.type) {
                    case 'hallpass':
                        ctx.fillStyle = 'rgba(74, 222, 128, 0.3)';
                        ctx.beginPath();
                        ctx.arc(0, 0, 15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillText('üìú', 0, 0);
                        break;
                    case 'energydrink':
                        ctx.fillStyle = 'rgba(251, 191, 36, 0.3)';
                        ctx.beginPath();
                        ctx.arc(0, 0, 15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillText('‚ö°', 0, 0);
                        break;
                    case 'stinkbomb':
                        ctx.fillStyle = 'rgba(167, 139, 250, 0.3)';
                        ctx.beginPath();
                        ctx.arc(0, 0, 15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillText('üí®', 0, 0);
                        break;
                    case 'skateboard':
                        ctx.fillStyle = 'rgba(96, 165, 250, 0.3)';
                        ctx.beginPath();
                        ctx.arc(0, 0, 15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillText('üõπ', 0, 0);
                        break;
                }

                ctx.restore();
            }
        }

        function drawTeachers() {
            for (const teacher of teachers) {
                const bobY = Math.sin(teacher.animFrame) * 2;

                ctx.save();
                ctx.translate(teacher.x, teacher.y + bobY);

                // Stunned effect
                if (teacher.stunned) {
                    ctx.globalAlpha = 0.5;
                    // Dizzy stars
                    ctx.font = '12px Arial';
                    const starAngle = Date.now() / 200;
                    ctx.fillText('‚≠ê', Math.cos(starAngle) * 15, -20 + Math.sin(starAngle) * 5);
                    ctx.fillText('‚≠ê', Math.cos(starAngle + Math.PI) * 15, -20 + Math.sin(starAngle + Math.PI) * 5);
                }

                // Vision cone / visibility circle
                if (!teacher.stunned) {
                    const sightRange = teacher.type === 'hunter' ? 200 : 150;
                    const dirAngles = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
                    const faceAngle = dirAngles[teacher.direction];

                    // Draw vision cone
                    ctx.save();
                    ctx.globalAlpha = teacher.seesPlayer ? 0.5 : 0.3;

                    // Create cone gradient
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, sightRange);
                    if (teacher.seesPlayer) {
                        gradient.addColorStop(0, 'rgba(255, 0, 0, 0.7)');
                        gradient.addColorStop(1, 'rgba(255, 0, 0, 0.1)');
                    } else {
                        gradient.addColorStop(0, 'rgba(255, 255, 0, 0.6)');
                        gradient.addColorStop(1, 'rgba(255, 255, 0, 0.1)');
                    }

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    // Draw a cone in the facing direction
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, sightRange, faceAngle - Math.PI / 3, faceAngle + Math.PI / 3);
                    ctx.closePath();
                    ctx.fill();

                    // Draw outer edge of vision cone
                    ctx.strokeStyle = teacher.seesPlayer ? 'rgba(255, 0, 0, 0.8)' : 'rgba(255, 255, 0, 0.6)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, sightRange, faceAngle - Math.PI / 3, faceAngle + Math.PI / 3);
                    ctx.stroke();

                    ctx.restore();
                }

                // Alert indicator
                if (teacher.seesPlayer && !teacher.stunned) {
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('!', 0, -25);
                }

                // Teacher colors and styles
                const colors = {
                    patrol: '#4a90a4',    // Blue - calm patrol
                    hunter: '#c0392b',    // Red - aggressive hunter
                    fast: '#9b59b6'       // Purple - speedy
                };

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(0, TEACHER_SIZE / 2 - 5, TEACHER_SIZE / 2, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Body - different shapes for each type
                ctx.fillStyle = colors[teacher.type];
                if (teacher.type === 'patrol') {
                    // Circle body (normal)
                    ctx.beginPath();
                    ctx.arc(0, 0, TEACHER_SIZE / 2, 0, Math.PI * 2);
                    ctx.fill();
                    // Clipboard accessory
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-8, 5, 6, 10);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-7, 6, 4, 8);
                } else if (teacher.type === 'hunter') {
                    // Square-ish body (intimidating)
                    ctx.beginPath();
                    ctx.roundRect(-TEACHER_SIZE / 2, -TEACHER_SIZE / 2, TEACHER_SIZE, TEACHER_SIZE, 6);
                    ctx.fill();
                    // Angry eyebrows
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-6, -8);
                    ctx.lineTo(-2, -5);
                    ctx.moveTo(6, -8);
                    ctx.lineTo(2, -5);
                    ctx.stroke();
                    // Whistle accessory
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(10, 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (teacher.type === 'fast') {
                    // Oval body (aerodynamic)
                    ctx.beginPath();
                    ctx.ellipse(0, 0, TEACHER_SIZE / 2 - 2, TEACHER_SIZE / 2 + 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Speed lines
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-TEACHER_SIZE / 2 - 5, -3);
                    ctx.lineTo(-TEACHER_SIZE / 2 - 12, -3);
                    ctx.moveTo(-TEACHER_SIZE / 2 - 3, 3);
                    ctx.lineTo(-TEACHER_SIZE / 2 - 10, 3);
                    ctx.stroke();
                    // Sneakers (running shoes)
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-5, TEACHER_SIZE / 2 - 2, 10, 4);
                }

                // Face - eyes that look in movement direction
                const dirAngles = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
                const faceAngle = dirAngles[teacher.direction];

                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-4, -2, 5, 0, Math.PI * 2);
                ctx.arc(4, -2, 5, 0, Math.PI * 2);
                ctx.fill();

                // Pupils (look in direction of movement)
                ctx.fillStyle = '#333';
                const pupilOffset = 2;
                ctx.beginPath();
                ctx.arc(-4 + Math.cos(faceAngle) * pupilOffset, -2 + Math.sin(faceAngle) * pupilOffset, 2, 0, Math.PI * 2);
                ctx.arc(4 + Math.cos(faceAngle) * pupilOffset, -2 + Math.sin(faceAngle) * pupilOffset, 2, 0, Math.PI * 2);
                ctx.fill();

                // Type label above head
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = colors[teacher.type];
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                const label = teacher.type === 'patrol' ? t('patrol') : teacher.type === 'hunter' ? t('hunter') : t('fast');
                ctx.strokeText(label, 0, -TEACHER_SIZE / 2 - 5);
                ctx.fillText(label, 0, -TEACHER_SIZE / 2 - 5);

                ctx.restore();
            }
        }

        function drawPlayer() {
            const time = Date.now() / 1000;

            ctx.save();
            ctx.translate(player.x, player.y);

            // Invincibility effect
            if (player.invincible) {
                ctx.globalAlpha = 0.5 + Math.sin(time * 10) * 0.3;
                // Shield effect
                ctx.strokeStyle = '#4ade80';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, PLAYER_SIZE / 2 + 5, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Speed effect
            if (player.speedBoost) {
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.globalAlpha = 0.3 - i * 0.1;
                    ctx.beginPath();
                    ctx.arc(-player.vx * (i + 1) * 2, -player.vy * (i + 1) * 2, PLAYER_SIZE / 2 - i * 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, PLAYER_SIZE / 2 - 3, PLAYER_SIZE / 2, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Player body
            ctx.fillStyle = '#60a5fa';
            ctx.beginPath();
            ctx.arc(0, 0, PLAYER_SIZE / 2, 0, Math.PI * 2);
            ctx.fill();

            // Backpack
            ctx.fillStyle = '#f97316';
            ctx.fillRect(-PLAYER_SIZE / 2 - 3, -5, 6, 14);

            // Face
            const dirAngles = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
            const faceAngle = dirAngles[player.direction];

            // Eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(Math.cos(faceAngle) * 3 - 4, -2, 4, 0, Math.PI * 2);
            ctx.arc(Math.cos(faceAngle) * 3 + 4, -2, 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(Math.cos(faceAngle) * 5 - 4, -2, 2, 0, Math.PI * 2);
            ctx.arc(Math.cos(faceAngle) * 5 + 4, -2, 2, 0, Math.PI * 2);
            ctx.fill();

            // Smile
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 2, 5, 0.2, Math.PI - 0.2);
            ctx.stroke();

            ctx.restore();
        }

        function drawParticles() {
            for (const p of gameState.particles) {
                if (p.isText) {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(p.text, p.x, p.y);
                    ctx.globalAlpha = 1;
                } else {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }
        }

        function drawMinimap() {
            minimapCtx.fillStyle = '#1a1a2e';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            const scaleX = minimapCanvas.width / (gameState.mapWidth * TILE_SIZE);
            const scaleY = minimapCanvas.height / (gameState.mapHeight * TILE_SIZE);

            // Draw map tiles
            for (let y = 0; y < gameState.mapHeight; y++) {
                for (let x = 0; x < gameState.mapWidth; x++) {
                    const tile = gameState.map[y][x];
                    const px = x * TILE_SIZE * scaleX;
                    const py = y * TILE_SIZE * scaleY;
                    const w = TILE_SIZE * scaleX;
                    const h = TILE_SIZE * scaleY;

                    if (tile === TILES.WALL) {
                        minimapCtx.fillStyle = '#5c4033';
                    } else if (tile === TILES.EXIT) {
                        minimapCtx.fillStyle = '#4ade80';
                    } else {
                        minimapCtx.fillStyle = '#3d3d5c';
                    }
                    minimapCtx.fillRect(px, py, w, h);
                }
            }

            // Draw collectibles
            minimapCtx.fillStyle = '#ffd700';
            for (const item of gameState.collectibles) {
                if (!item.collected) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(item.x * scaleX, item.y * scaleY, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            }

            // Draw teachers
            minimapCtx.fillStyle = '#ff6b6b';
            for (const teacher of teachers) {
                minimapCtx.beginPath();
                minimapCtx.arc(teacher.x * scaleX, teacher.y * scaleY, 3, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            // Draw player
            minimapCtx.fillStyle = '#60a5fa';
            minimapCtx.beginPath();
            minimapCtx.arc(player.x * scaleX, player.y * scaleY, 4, 0, Math.PI * 2);
            minimapCtx.fill();

            // Draw viewport
            minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                gameState.camera.x * scaleX,
                gameState.camera.y * scaleY,
                canvas.width * scaleX,
                canvas.height * scaleY
            );
        }

        // ============================================
        // UI & MENUS
        // ============================================

        function updateUI() {
            document.getElementById('score-display').textContent = `${t('score')}: ${gameState.score}`;

            const comboDisplay = document.getElementById('combo-display');
            comboDisplay.textContent = `${t('combo')}: x${gameState.combo}`;
            if (gameState.combo > 1) {
                comboDisplay.classList.add('pulse');
                setTimeout(() => comboDisplay.classList.remove('pulse'), 100);
            }

            if (gameMode === 'campaign') {
                const level = LEVELS[currentLevel];
                document.getElementById('level-display').textContent = t(level.name);
            } else {
                document.getElementById('level-display').textContent = `${t('level')} ${gameState.level}`;
            }

            const collected = gameState.collectibles.filter(c => c.collected).length;
            document.getElementById('items-display').textContent = `${t('items')}: ${collected}/${gameState.collectibles.length}`;

            // Update lives
            const livesContainer = document.getElementById('lives-display');
            livesContainer.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const life = document.createElement('div');
                life.className = 'life-icon' + (i >= gameState.lives ? ' lost' : '');
                livesContainer.appendChild(life);
            }

            // Update powerup slots
            for (let i = 0; i < 3; i++) {
                const slot = document.getElementById(`powerup-${i + 1}`);
                const powerup = gameState.playerPowerups[i];
                slot.className = 'powerup-slot' + (powerup ? ' active' : '');

                if (powerup) {
                    const icons = {
                        hallpass: 'üìú',
                        energydrink: '‚ö°',
                        stinkbomb: 'üí®',
                        skateboard: 'üõπ'
                    };
                    slot.textContent = icons[powerup];
                } else {
                    slot.textContent = '';
                }
            }
        }

        function showMessage(text) {
            const popup = document.getElementById('message-popup');
            popup.textContent = text;
            popup.classList.add('show');
            setTimeout(() => popup.classList.remove('show'), 1500);
        }

        function showMenu(id) {
            document.querySelectorAll('.menu-screen').forEach(m => m.classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
        }

        function hideAllMenus() {
            document.querySelectorAll('.menu-screen').forEach(m => m.classList.add('hidden'));
        }

        // ============================================
        // CAMPAIGN MODE FUNCTIONS
        // ============================================

        function updateCampaignProgress() {
            const level = LEVELS[currentLevel];
            document.getElementById('current-level-text').textContent = `${t('currentLevel')}: ${t(level.name)}`;
            document.getElementById('menu-progress-bar').style.width = `${(currentLevel / LEVELS.length) * 100}%`;
            document.getElementById('menu-progress-text').textContent = `${currentLevel}/${LEVELS.length} ${t('completed')}`;
        }

        function saveCampaignProgress() {
            localStorage.setItem('schoolEscape_currentLevel', currentLevel.toString());
            localStorage.setItem('schoolEscape_totalScore', totalCampaignScore.toString());
        }

        function loadCampaignProgress() {
            const savedLevel = localStorage.getItem('schoolEscape_currentLevel');
            const savedScore = localStorage.getItem('schoolEscape_totalScore');
            if (savedLevel !== null) {
                currentLevel = parseInt(savedLevel);
            }
            if (savedScore !== null) {
                totalCampaignScore = parseInt(savedScore);
            }
        }

        function showLevelCompleteScreen(scores) {
            const level = LEVELS[currentLevel];
            document.getElementById('level-complete-title').textContent = t('levelComplete');
            document.getElementById('level-name-display').textContent = t(level.name);
            document.getElementById('level-score').textContent = `${t('score')}: ${gameState.score}`;

            const progress = ((currentLevel + 1) / LEVELS.length) * 100;
            document.getElementById('progress-bar').style.width = `${progress}%`;
            document.getElementById('progress-text').textContent = `${currentLevel + 1}/${LEVELS.length}`;

            document.getElementById('next-level-button').textContent = t('nextLevel');
            document.getElementById('level-menu-button').textContent = t('mainMenu');

            // Show multiplayer scores if available
            const mpScoresContainer = document.getElementById('level-multiplayer-scores');
            const mpScoresList = document.getElementById('level-multiplayer-scores-list');
            if (scores && scores.length > 1) {
                mpScoresContainer.style.display = 'block';
                mpScoresList.innerHTML = renderMultiplayerScores(scores);
            } else {
                mpScoresContainer.style.display = 'none';
            }

            // Broadcast level complete to other players in multiplayer
            if (mpState.active && mpState.isHost) {
                broadcastLevelComplete(scores);
            }

            // Add score to campaign total
            totalCampaignScore += gameState.score;
            saveCampaignProgress();

            showMenu('level-complete-screen');
        }

        function showGraduationScreen() {
            document.getElementById('graduation-message').textContent = t('graduatedMsg');
            document.getElementById('total-score').textContent = `${t('totalScore')}: ${totalCampaignScore}`;
            document.getElementById('new-game-button').textContent = t('newGame');
            document.getElementById('graduation-menu-button').textContent = t('mainMenu');

            // Reset campaign progress
            currentLevel = 0;
            totalCampaignScore = 0;
            saveCampaignProgress();

            showMenu('graduation-screen');
        }

        // ============================================
        // GAME LOOP & INITIALIZATION
        // ============================================

        let lastTime = 0;

        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            update(Math.min(deltaTime, 0.1)); // Cap delta to prevent physics issues

            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            // Reset game state
            gameState = {
                running: true,
                paused: false,
                score: 0,
                combo: 1,
                comboTimer: 0,
                lives: 3,
                level: 1,
                map: [],
                mapWidth: 0,
                mapHeight: 0,
                collectibles: [],
                powerups: [],
                activePowerups: [],
                playerPowerups: [null, null, null],
                particles: [],
                screenShake: 0,
                camera: { x: 0, y: 0 },
                reportedPlayerLocation: null  // Patrol teachers report player location here
            };

            // Reset player
            player = {
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                speed: 4,
                dashCooldown: 0,
                isDashing: false,
                dashTimer: 0,
                invincible: false,
                invincibleTimer: 0,
                speedBoost: false,
                speedBoostTimer: 0,
                direction: 0,
                animFrame: 0,
                superhero: false,
                canFly: false
            };

            // Reset events
            currentEvent = null;
            eventTimer = 0;
            nextEventTime = 15;
            eventEntities = [];

            // Generate map
            generateMap();

            // Update UI
            updateUI();
            hideAllMenus();

            // Initialize audio and start music
            initAudio();
            startMusic();

            // Start game
            gameState.running = true;
            showMessage(t('escape'));
            playSound('menu_click');
        }

        function init() {
            // Settings controls
            document.getElementById('teacher-count').addEventListener('input', (e) => {
                settings.teacherCount = parseInt(e.target.value);
                document.getElementById('teacher-count-display').textContent = settings.teacherCount;
            });

            document.getElementById('school-type').addEventListener('change', (e) => {
                settings.schoolType = e.target.value;
            });

            document.getElementById('map-size').addEventListener('change', (e) => {
                settings.mapSize = e.target.value;
            });

            document.getElementById('map-topology').addEventListener('change', (e) => {
                settings.mapTopology = e.target.value;
            });

            document.getElementById('corridor-density').addEventListener('change', (e) => {
                settings.corridorDensity = e.target.value;
            });

            document.getElementById('room-density').addEventListener('change', (e) => {
                settings.roomDensity = e.target.value;
            });

            // Menu buttons
            document.getElementById('start-button').addEventListener('click', () => {
                initAudio();
                playSound('menu_click');
                startGame();
            });
            document.getElementById('how-to-play-button').addEventListener('click', () => {
                initAudio();
                playSound('menu_click');
                showMenu('how-to-play-screen');
            });
            document.getElementById('back-to-menu-button').addEventListener('click', () => {
                playSound('menu_click');
                showMenu('main-menu');
            });
            document.getElementById('resume-button').addEventListener('click', () => {
                playSound('menu_click');
                gameState.paused = false;
                hideAllMenus();
                startMusic();
            });
            document.getElementById('quit-button').addEventListener('click', () => {
                playSound('menu_click');
                stopMusic();
                gameState.running = false;
                showMenu('main-menu');
            });
            document.getElementById('retry-button').addEventListener('click', () => {
                playSound('menu_click');
                startGame();
            });
            document.getElementById('menu-button').addEventListener('click', () => {
                playSound('menu_click');
                showMenu('main-menu');
            });

            // Campaign mode button
            document.getElementById('campaign-button').addEventListener('click', () => {
                playSound('menu_click');
                gameMode = 'campaign';
                document.getElementById('campaign-progress-display').style.display = 'block';
                document.getElementById('freeplay-settings').style.display = 'none';
                document.getElementById('start-button').style.display = 'block';
                document.getElementById('campaign-button').style.opacity = '1';
                document.getElementById('freeplay-button').style.opacity = '0.5';
                document.getElementById('multiplayer-button').style.opacity = '0.5';
                updateCampaignProgress();
            });

            // Free play mode button
            document.getElementById('freeplay-button').addEventListener('click', () => {
                playSound('menu_click');
                gameMode = 'freeplay';
                document.getElementById('campaign-progress-display').style.display = 'none';
                document.getElementById('freeplay-settings').style.display = 'block';
                document.getElementById('start-button').style.display = 'block';
                document.getElementById('campaign-button').style.opacity = '0.5';
                document.getElementById('freeplay-button').style.opacity = '1';
                document.getElementById('multiplayer-button').style.opacity = '0.5';
            });

            // Multiplayer button
            document.getElementById('multiplayer-button').addEventListener('click', () => {
                playSound('menu_click');
                document.getElementById('campaign-progress-display').style.display = 'none';
                document.getElementById('freeplay-settings').style.display = 'none';
                document.getElementById('start-button').style.display = 'none';
                document.getElementById('campaign-button').style.opacity = '0.5';
                document.getElementById('freeplay-button').style.opacity = '0.5';
                document.getElementById('multiplayer-button').style.opacity = '1';
                showMenu('multiplayer-menu-screen');
            });

            // Multiplayer - Create Room
            document.getElementById('create-room-button').addEventListener('click', () => {
                playSound('menu_click');
                showMenu('create-room-screen');
                createMultiplayerRoom();
            });

            // Multiplayer - Join Room button
            document.getElementById('join-room-button').addEventListener('click', () => {
                playSound('menu_click');
                showMenu('join-room-screen');
            });

            // Multiplayer - Back from menu
            document.getElementById('mp-back-to-menu').addEventListener('click', () => {
                playSound('menu_click');
                showMenu('main-menu');
            });

            // Multiplayer - Start game (host)
            document.getElementById('mp-start-game').addEventListener('click', () => {
                playSound('menu_click');
                hostStartGame();
            });

            // Multiplayer - Cancel hosting
            document.getElementById('mp-cancel-host').addEventListener('click', () => {
                playSound('menu_click');
                leaveMultiplayerRoom();
                showMenu('multiplayer-menu-screen');
            });

            // Multiplayer - Join room submit
            document.getElementById('mp-join-room').addEventListener('click', () => {
                playSound('menu_click');
                const code = document.getElementById('join-room-code').value.trim();
                if (code.length >= 4) {
                    joinMultiplayerRoom(code);
                }
            });

            // Multiplayer - Cancel join
            document.getElementById('mp-cancel-join').addEventListener('click', () => {
                playSound('menu_click');
                leaveMultiplayerRoom();
                showMenu('multiplayer-menu-screen');
            });

            // Multiplayer - Leave lobby
            document.getElementById('mp-leave-lobby').addEventListener('click', () => {
                playSound('menu_click');
                leaveMultiplayerRoom();
                showMenu('multiplayer-menu-screen');
            });

            // Multiplayer - Teacher count display
            document.getElementById('mp-teacher-count').addEventListener('input', (e) => {
                document.getElementById('mp-teacher-count-display').textContent = e.target.value;
            });

            // Next level button
            document.getElementById('next-level-button').addEventListener('click', () => {
                playSound('menu_click');
                currentLevel++;
                if (currentLevel >= LEVELS.length) {
                    showGraduationScreen();
                } else {
                    hideAllMenus();
                    startGame();
                }
            });

            // Level complete - main menu button
            document.getElementById('level-menu-button').addEventListener('click', () => {
                playSound('menu_click');
                saveCampaignProgress();
                showMenu('main-menu');
            });

            // Graduation - new game button
            document.getElementById('new-game-button').addEventListener('click', () => {
                playSound('menu_click');
                currentLevel = 0;
                totalCampaignScore = 0;
                saveCampaignProgress();
                hideAllMenus();
                startGame();
            });

            // Graduation - main menu button
            document.getElementById('graduation-menu-button').addEventListener('click', () => {
                playSound('menu_click');
                showMenu('main-menu');
            });

            // Load campaign progress on init
            loadCampaignProgress();

            // Keyboard input
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;

                // Dash
                if (e.code === 'Space' && gameState.running && !gameState.paused) {
                    if (player.dashCooldown <= 0 && !player.isDashing) {
                        player.isDashing = true;
                        player.dashTimer = 0.2;
                        player.dashCooldown = 1;
                        gameState.screenShake = 3;
                        playSound('dash');
                    }
                    e.preventDefault();
                }

                // Pause
                if (e.code === 'Escape') {
                    if (gameState.running) {
                        gameState.paused = !gameState.paused;
                        if (gameState.paused) {
                            stopMusic();
                            playSound('menu_click');
                            showMenu('pause-screen');
                        } else {
                            playSound('menu_click');
                            startMusic();
                            hideAllMenus();
                        }
                    }
                }

                // Use powerups (1, 2, 3)
                if (e.code === 'Digit1' || e.code === 'Digit2' || e.code === 'Digit3') {
                    const slot = parseInt(e.code.slice(-1)) - 1;
                    if (gameState.playerPowerups[slot]) {
                        usePowerup(gameState.playerPowerups[slot]);
                        gameState.playerPowerups[slot] = null;
                        updateUI();
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            // Initialize language
            updateLanguage();

            // Start loops
            render();
            requestAnimationFrame(gameLoop);
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
