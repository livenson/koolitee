<!DOCTYPE html>
<!--
    School Escape - Action Arcade Game
    Copyright (c) 2025 Ilja Livenson and Mark Livenson
    All rights reserved.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>School Escape - Action Arcade Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 800px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            color: white;
        }

        #score-display {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #combo-display {
            font-size: 18px;
            color: #ff6b6b;
            transition: transform 0.1s;
        }

        #combo-display.pulse {
            transform: scale(1.3);
            color: #ff0000;
        }

        #lives-display {
            display: flex;
            gap: 5px;
        }

        .life-icon {
            width: 25px;
            height: 25px;
            background: #ff6b6b;
            border-radius: 50%;
            border: 2px solid white;
        }

        .life-icon.lost {
            background: #333;
            opacity: 0.5;
        }

        #powerup-display {
            display: flex;
            gap: 10px;
        }

        .powerup-slot {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .powerup-slot.active {
            border-color: #ffd700;
            box-shadow: 0 0 10px #ffd700;
            animation: glow 0.5s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 10px #ffd700; }
            to { box-shadow: 0 0 20px #ffd700; }
        }

        #game-canvas {
            border: 4px solid #4a4a6a;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5), inset 0 0 50px rgba(0, 0, 0, 0.3);
            background: #2a2a4a;
        }

        #game-footer {
            display: flex;
            justify-content: center;
            gap: 20px;
            color: white;
            font-size: 14px;
            opacity: 0.8;
        }

        .key-hint {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .key {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        /* Menu Screens */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            color: white;
        }

        .menu-screen.hidden {
            display: none;
        }

        #main-menu h1 {
            font-size: 48px;
            color: #ffd700;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            margin-bottom: 10px;
        }

        #main-menu h2 {
            font-size: 24px;
            color: #ff6b6b;
            margin-bottom: 40px;
        }

        .menu-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }

        .menu-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .sound-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            font-size: 14px;
            color: white;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .sound-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .settings-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            min-width: 300px;
        }

        .setting-row label {
            font-size: 16px;
        }

        .setting-row select, .setting-row input {
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
        }

        .setting-row input[type="range"] {
            width: 150px;
        }

        /* Game Over / Win Screen */
        #game-over-screen h2 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        #game-over-screen.win h2 {
            color: #4ade80;
        }

        #game-over-screen.lose h2 {
            color: #ff6b6b;
        }

        #final-score {
            font-size: 36px;
            color: #ffd700;
            margin-bottom: 30px;
        }

        /* Level indicator */
        #level-display {
            font-size: 18px;
            color: #4ade80;
        }

        /* Items remaining */
        #items-display {
            font-size: 16px;
            color: #60a5fa;
        }

        /* Pause Screen */
        #pause-screen {
            background: rgba(0, 0, 0, 0.8);
        }

        #pause-screen h2 {
            font-size: 48px;
            color: #ffd700;
            margin-bottom: 30px;
        }

        /* Message popup */
        #message-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 32px;
            font-weight: bold;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #message-popup.show {
            opacity: 1;
        }

        /* Minimap */
        #minimap {
            position: absolute;
            bottom: 60px;
            right: 10px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-header">
            <div id="score-display">Score: 0</div>
            <div id="combo-display">Combo: x1</div>
            <div id="level-display">Level 1</div>
            <div id="items-display">Items: 0/0</div>
            <div id="powerup-display">
                <div class="powerup-slot" id="powerup-1" title="Hall Pass"></div>
                <div class="powerup-slot" id="powerup-2" title="Energy Drink"></div>
                <div class="powerup-slot" id="powerup-3" title="Stink Bomb"></div>
            </div>
            <div id="lives-display"></div>
        </div>

        <canvas id="game-canvas" width="800" height="600"></canvas>
        <canvas id="minimap" width="150" height="112"></canvas>

        <div id="game-footer">
            <div class="key-hint"><span class="key">WASD</span> or <span class="key">Arrows</span> Move</div>
            <div class="key-hint"><span class="key">SPACE</span> Dash</div>
            <div class="key-hint"><span class="key">1-3</span> Use Power-up</div>
            <div class="key-hint"><span class="key">ESC</span> Pause</div>
        </div>

        <!-- Main Menu -->
        <div id="main-menu" class="menu-screen">
            <h1>SCHOOL ESCAPE</h1>
            <h2>Escape the Teachers!</h2>

            <!-- Game Mode Selection -->
            <div style="display: flex; gap: 20px; margin: 20px 0;">
                <button class="menu-button" id="campaign-button" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">ğŸ“š CAMPAIGN</button>
                <button class="menu-button" id="freeplay-button" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">ğŸ® FREE PLAY</button>
            </div>

            <!-- Campaign Progress Display -->
            <div id="campaign-progress-display" class="settings-panel" style="display: none; text-align: center;">
                <div style="color: #ffd700; font-size: 18px; margin-bottom: 10px;" id="current-level-text">Current Level: Grade 1</div>
                <div style="width: 100%; height: 15px; background: rgba(255,255,255,0.2); border-radius: 8px; overflow: hidden;">
                    <div id="menu-progress-bar" style="height: 100%; background: linear-gradient(90deg, #4ade80, #22d3ee); width: 0%; transition: width 0.3s;"></div>
                </div>
                <div style="color: #aaa; margin-top: 5px;" id="menu-progress-text">0/17 completed</div>
            </div>

            <!-- Free Play Settings -->
            <div id="freeplay-settings" class="settings-panel" style="display: none;">
                <div class="setting-row">
                    <label>School Type:</label>
                    <select id="school-type">
                        <option value="elementary">Elementary (Easy)</option>
                        <option value="middle" selected>Middle School (Medium)</option>
                        <option value="high">High School (Hard)</option>
                        <option value="university">University (Expert)</option>
                    </select>
                </div>
                <div class="setting-row">
                    <label>Map Size:</label>
                    <select id="map-size">
                        <option value="small">Small</option>
                        <option value="medium" selected>Medium</option>
                        <option value="large">Large</option>
                    </select>
                </div>
                <div class="setting-row">
                    <label>Teachers:</label>
                    <input type="range" id="teacher-count" min="2" max="8" value="4">
                    <span id="teacher-count-display">4</span>
                </div>
            </div>

            <!-- Common Settings -->
            <div class="settings-panel">
                <div class="setting-row">
                    <label>Language:</label>
                    <select id="language-select" onchange="setLanguage(this.value)">
                        <option value="en">English</option>
                        <option value="et">Eesti</option>
                        <option value="lv">LatvieÅ¡u</option>
                        <option value="lt">LietuviÅ³</option>
                        <option value="ru">Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
                    </select>
                </div>
                <div class="setting-row" style="justify-content: center; gap: 20px;">
                    <button class="sound-btn" id="sound-toggle" onclick="toggleSound()">ğŸ”Š Sound: ON</button>
                    <button class="sound-btn" id="music-toggle" onclick="toggleMusic()">ğŸµ Music: ON</button>
                </div>
                <div class="setting-row" style="justify-content: center;">
                    <button class="sound-btn" id="events-toggle" onclick="toggleEvents()" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">ğŸ² Random Events: ON</button>
                </div>
            </div>

            <button class="menu-button" id="start-button" style="display: none;">START GAME</button>
            <button class="menu-button" id="how-to-play-button">HOW TO PLAY</button>

            <div style="margin-top: 30px; color: #666; font-size: 12px;">
                Â© 2025 Ilja Livenson and Mark Livenson
            </div>
        </div>

        <!-- How To Play -->
        <div id="how-to-play-screen" class="menu-screen hidden">
            <h2 style="color: #ffd700; margin-bottom: 30px;">HOW TO PLAY</h2>
            <div class="settings-panel" style="max-width: 500px; text-align: left;">
                <p style="margin-bottom: 15px;"><strong style="color: #4ade80;">OBJECTIVE:</strong> Collect all homework pages and reach the exit without getting caught by teachers!</p>

                <p style="margin-bottom: 15px;"><strong style="color: #60a5fa;">CONTROLS:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>WASD or Arrow Keys - Move</li>
                    <li>SPACE - Dash (quick burst of speed)</li>
                    <li>1, 2, 3 - Use collected power-ups</li>
                    <li>ESC - Pause game</li>
                </ul>

                <p style="margin-bottom: 15px;"><strong style="color: #ffd700;">POWER-UPS:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>ğŸ“œ Hall Pass - Temporary invincibility</li>
                    <li>âš¡ Energy Drink - Super speed</li>
                    <li>ğŸ’¨ Stink Bomb - Stuns nearby teachers</li>
                    <li>ğŸ›¹ Skateboard - Fast movement</li>
                </ul>

                <p style="margin-bottom: 15px;"><strong style="color: #ff6b6b;">TEACHERS:</strong></p>
                <ul style="margin-left: 20px;">
                    <li>ğŸ§‘â€ğŸ« Patrol Teacher - Follows set routes</li>
                    <li>ğŸ‘¨â€ğŸ« Hunter Teacher - Actively chases you</li>
                    <li>ğŸ‘©â€ğŸ« Fast Teacher - Quick but predictable</li>
                </ul>
            </div>
            <button class="menu-button" id="back-to-menu-button">BACK TO MENU</button>
        </div>

        <!-- Pause Screen -->
        <div id="pause-screen" class="menu-screen hidden">
            <h2>PAUSED</h2>
            <button class="menu-button" id="resume-button">RESUME</button>
            <button class="menu-button" id="quit-button">QUIT TO MENU</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="menu-screen hidden">
            <h2>GAME OVER</h2>
            <div id="final-score">Score: 0</div>
            <div id="final-stats" style="margin-bottom: 20px; color: #aaa;"></div>
            <button class="menu-button" id="retry-button">PLAY AGAIN</button>
            <button class="menu-button" id="menu-button">MAIN MENU</button>
        </div>

        <!-- Level Complete Screen -->
        <div id="level-complete-screen" class="menu-screen hidden">
            <h2 id="level-complete-title" style="color: #4ade80;">LEVEL COMPLETE!</h2>
            <div id="level-name-display" style="font-size: 28px; color: #ffd700; margin: 10px 0;"></div>
            <div id="level-score" style="font-size: 24px; color: #fff; margin: 10px 0;">Score: 0</div>
            <div id="level-progress" style="margin: 20px 0;">
                <div style="color: #aaa; margin-bottom: 10px;">Progress</div>
                <div id="progress-bar-container" style="width: 300px; height: 20px; background: rgba(255,255,255,0.2); border-radius: 10px; overflow: hidden; margin: 0 auto;">
                    <div id="progress-bar" style="height: 100%; background: linear-gradient(90deg, #4ade80, #22d3ee); width: 0%; transition: width 0.5s;"></div>
                </div>
                <div id="progress-text" style="color: #aaa; margin-top: 5px;">1/17</div>
            </div>
            <button class="menu-button" id="next-level-button">NEXT LEVEL</button>
            <button class="menu-button" id="level-menu-button" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);">MAIN MENU</button>
        </div>

        <!-- Graduation Screen -->
        <div id="graduation-screen" class="menu-screen hidden">
            <h2 style="color: #ffd700; font-size: 48px;">ğŸ“ GRADUATED! ğŸ“</h2>
            <div id="graduation-message" style="font-size: 20px; color: #fff; margin: 20px 0; max-width: 400px;"></div>
            <div id="total-score" style="font-size: 32px; color: #4ade80; margin: 20px 0;">Total Score: 0</div>
            <button class="menu-button" id="new-game-button">NEW GAME</button>
            <button class="menu-button" id="graduation-menu-button" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);">MAIN MENU</button>
        </div>

        <!-- Message Popup -->
        <div id="message-popup"></div>
    </div>

    <script>
        // ============================================
        // SCHOOL ESCAPE - Action Arcade Game
        // ============================================

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        // Game constants
        const TILE_SIZE = 32;
        const PLAYER_SIZE = 24;
        const TEACHER_SIZE = 28;

        // Tile types
        const TILES = {
            FLOOR: 0,
            WALL: 1,
            DESK: 2,
            LOCKER: 3,
            WET_FLOOR: 4,
            EXIT: 5,
            DOOR: 6
        };

        // Game state
        let gameState = {
            running: false,
            paused: false,
            score: 0,
            combo: 1,
            comboTimer: 0,
            lives: 3,
            level: 1,
            map: [],
            mapWidth: 0,
            mapHeight: 0,
            collectibles: [],
            powerups: [],
            activePowerups: [],
            playerPowerups: [null, null, null],
            particles: [],
            screenShake: 0,
            camera: { x: 0, y: 0 }
        };

        // Player object
        let player = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            speed: 4,
            dashCooldown: 0,
            isDashing: false,
            dashTimer: 0,
            invincible: false,
            invincibleTimer: 0,
            speedBoost: false,
            speedBoostTimer: 0,
            direction: 0, // 0: right, 1: down, 2: left, 3: up
            animFrame: 0
        };

        // Teachers array
        let teachers = [];

        // Input state
        const keys = {};

        // Settings
        let settings = {
            schoolType: 'middle',
            mapSize: 'medium',
            teacherCount: 4,
            soundEnabled: true,
            musicEnabled: false,
            language: 'en',
            eventsEnabled: true
        };

        // Random Events System
        const RANDOM_EVENTS = [
            { id: 'ufo', name: 'ufoAbduction', duration: 6, minInterval: 30, icon: 'ğŸ›¸' },
            { id: 'dinosaur', name: 'dinosaurStampede', duration: 8, minInterval: 45, icon: 'ğŸ¦–' },
            { id: 'parents', name: 'parentsVisiting', duration: 15, minInterval: 40, icon: 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§' },
            { id: 'fireDrill', name: 'fireDrill', duration: 12, minInterval: 50, icon: 'ğŸš¨' },
            { id: 'principal', name: 'principalInspection', duration: 10, minInterval: 35, icon: 'ğŸ©' },
            { id: 'powerOutage', name: 'powerOutage', duration: 12, minInterval: 40, icon: 'ğŸ’¡' },
            { id: 'foodFight', name: 'foodFight', duration: 8, minInterval: 35, icon: 'ğŸ•' },
            { id: 'superhero', name: 'superheroStudent', duration: 6, minInterval: 45, icon: 'ğŸ¦¸' },
            { id: 'ghost', name: 'ghostJanitor', duration: 10, minInterval: 40, icon: 'ğŸ‘»' },
            { id: 'timeFreeze', name: 'timeFreeze', duration: 5, minInterval: 50, icon: 'â±ï¸' },
            { id: 'earthquake', name: 'earthquake', duration: 3, minInterval: 60, icon: 'ğŸŒ‹' },
            { id: 'pizza', name: 'pizzaDelivery', duration: 8, minInterval: 35, icon: 'ğŸ•' }
        ];

        let currentEvent = null;
        let eventTimer = 0;
        let nextEventTime = 15; // First event after 15 seconds
        let eventEntities = []; // For UFOs, dinosaurs, etc.

        // Level configuration (17 levels total)
        const LEVELS = [
            // Grades 1-9 (Elementary & Middle School)
            { id: 1,  name: 'grade1',     mapSize: { w: 20, h: 15 }, teachers: 2, speed: 0.6, collectibles: 8,  schoolType: 'elementary' },
            { id: 2,  name: 'grade2',     mapSize: { w: 22, h: 16 }, teachers: 2, speed: 0.65, collectibles: 10, schoolType: 'elementary' },
            { id: 3,  name: 'grade3',     mapSize: { w: 24, h: 17 }, teachers: 3, speed: 0.7, collectibles: 12, schoolType: 'elementary' },
            { id: 4,  name: 'grade4',     mapSize: { w: 26, h: 18 }, teachers: 3, speed: 0.75, collectibles: 14, schoolType: 'elementary' },
            { id: 5,  name: 'grade5',     mapSize: { w: 28, h: 19 }, teachers: 3, speed: 0.8, collectibles: 15, schoolType: 'middle' },
            { id: 6,  name: 'grade6',     mapSize: { w: 30, h: 20 }, teachers: 4, speed: 0.85, collectibles: 16, schoolType: 'middle' },
            { id: 7,  name: 'grade7',     mapSize: { w: 32, h: 22 }, teachers: 4, speed: 0.9, collectibles: 18, schoolType: 'middle' },
            { id: 8,  name: 'grade8',     mapSize: { w: 34, h: 24 }, teachers: 4, speed: 0.95, collectibles: 20, schoolType: 'middle' },
            { id: 9,  name: 'grade9',     mapSize: { w: 36, h: 25 }, teachers: 5, speed: 1.0, collectibles: 22, schoolType: 'middle' },
            // Gymnasium (3 years)
            { id: 10, name: 'gymnasium1', mapSize: { w: 38, h: 26 }, teachers: 5, speed: 1.05, collectibles: 24, schoolType: 'high' },
            { id: 11, name: 'gymnasium2', mapSize: { w: 40, h: 28 }, teachers: 5, speed: 1.1, collectibles: 26, schoolType: 'high' },
            { id: 12, name: 'gymnasium3', mapSize: { w: 42, h: 30 }, teachers: 6, speed: 1.15, collectibles: 28, schoolType: 'high' },
            // Bachelor (3 years)
            { id: 13, name: 'bachelor1',  mapSize: { w: 44, h: 32 }, teachers: 6, speed: 1.2, collectibles: 30, schoolType: 'university' },
            { id: 14, name: 'bachelor2',  mapSize: { w: 46, h: 34 }, teachers: 6, speed: 1.25, collectibles: 32, schoolType: 'university' },
            { id: 15, name: 'bachelor3',  mapSize: { w: 48, h: 36 }, teachers: 7, speed: 1.3, collectibles: 34, schoolType: 'university' },
            // Master (2 years)
            { id: 16, name: 'master1',    mapSize: { w: 50, h: 38 }, teachers: 7, speed: 1.35, collectibles: 36, schoolType: 'university' },
            { id: 17, name: 'master2',    mapSize: { w: 55, h: 40 }, teachers: 8, speed: 1.4, collectibles: 40, schoolType: 'university' }
        ];

        // Game mode
        let gameMode = 'freeplay'; // 'freeplay' or 'campaign'
        let currentLevel = 0; // 0-indexed
        let totalCampaignScore = 0; // Total score across all levels in campaign

        // ============================================
        // TRANSLATIONS
        // ============================================

        const translations = {
            en: {
                // Main Menu
                title: 'SCHOOL ESCAPE',
                subtitle: 'Escape the Teachers!',
                startGame: 'START GAME',
                howToPlay: 'HOW TO PLAY',
                backToMenu: 'BACK TO MENU',

                // Settings
                schoolType: 'School Type:',
                elementary: 'Elementary (Easy)',
                middleSchool: 'Middle School (Medium)',
                highSchool: 'High School (Hard)',
                university: 'University (Expert)',
                mapSize: 'Map Size:',
                small: 'Small',
                medium: 'Medium',
                large: 'Large',
                teachers: 'Teachers:',
                language: 'Language:',
                soundOn: 'ğŸ”Š Sound: ON',
                soundOff: 'ğŸ”‡ Sound: OFF',
                musicOn: 'ğŸµ Music: ON',
                musicOff: 'ğŸµ Music: OFF',

                // Game UI
                score: 'Score',
                combo: 'Combo',
                level: 'Level',
                items: 'Items',
                move: 'Move',
                dash: 'Dash',
                usePowerup: 'Use Power-up',
                pause: 'Pause',

                // Power-ups
                hallPass: 'Hall Pass',
                energyDrink: 'Energy Drink',
                stinkBomb: 'Stink Bomb',
                skateboard: 'Skateboard',

                // How To Play
                objective: 'OBJECTIVE:',
                objectiveText: 'Collect all homework pages and reach the exit without getting caught by teachers!',
                controls: 'CONTROLS:',
                controlMove: 'WASD or Arrow Keys - Move',
                controlDash: 'SPACE - Dash (quick burst of speed)',
                controlPowerup: '1, 2, 3 - Use collected power-ups',
                controlPause: 'ESC - Pause game',
                powerups: 'POWER-UPS:',
                hallPassDesc: 'Hall Pass - Temporary invincibility',
                energyDrinkDesc: 'Energy Drink - Super speed',
                stinkBombDesc: 'Stink Bomb - Stuns nearby teachers',
                skateboardDesc: 'Skateboard - Fast movement',
                teachersTitle: 'TEACHERS:',
                patrolDesc: 'Patrol Teacher - Follows set routes',
                hunterDesc: 'Hunter Teacher - Actively chases you',
                fastDesc: 'Fast Teacher - Quick but predictable',

                // Teacher labels
                patrol: 'PATROL',
                hunter: 'HUNTER',
                fast: 'FAST',

                // Pause Screen
                paused: 'PAUSED',
                resume: 'RESUME',
                quitToMenu: 'QUIT TO MENU',

                // Game Over
                escaped: 'ESCAPED!',
                caught: 'CAUGHT!',
                gameOver: 'GAME OVER',
                playAgain: 'PLAY AGAIN',
                mainMenu: 'MAIN MENU',
                itemsCollected: 'Items',
                livesRemaining: 'Lives remaining',

                // In-game messages
                escape: 'ESCAPE!',
                invincible: 'INVINCIBLE!',
                speedBoost: 'SPEED BOOST!',
                stinkBombMsg: 'STINK BOMB!',
                skateboardMsg: 'SKATEBOARD!',
                caughtMsg: 'CAUGHT!',
                livesLeft: 'lives left',
                got: 'Got',

                // Game modes
                freePlay: 'FREE PLAY',
                campaign: 'CAMPAIGN',
                selectMode: 'Select Mode',
                continueGame: 'CONTINUE',
                newGame: 'NEW GAME',

                // Level names
                grade1: 'Grade 1',
                grade2: 'Grade 2',
                grade3: 'Grade 3',
                grade4: 'Grade 4',
                grade5: 'Grade 5',
                grade6: 'Grade 6',
                grade7: 'Grade 7',
                grade8: 'Grade 8',
                grade9: 'Grade 9',
                gymnasium1: 'Gymnasium I',
                gymnasium2: 'Gymnasium II',
                gymnasium3: 'Gymnasium III',
                bachelor1: 'Bachelor Year 1',
                bachelor2: 'Bachelor Year 2',
                bachelor3: 'Bachelor Year 3',
                master1: 'Master Year 1',
                master2: 'Master Year 2',

                // Level complete
                levelComplete: 'LEVEL COMPLETE!',
                nextLevel: 'NEXT LEVEL',
                graduated: 'GRADUATED!',
                graduatedMsg: 'Congratulations! You have completed all levels!',
                levelProgress: 'Progress',
                currentLevel: 'Current Level',
                completed: 'completed',
                totalScore: 'Total Score',
                campaign: 'CAMPAIGN',
                freePlay: 'FREE PLAY',

                // Random Events
                eventsOn: 'ğŸ² Events: ON',
                eventsOff: 'ğŸ² Events: OFF',
                eventEnded: 'Event ended',
                ufoAbduction: 'UFO Abduction',
                dinosaurStampede: 'Dinosaur Stampede',
                parentsVisiting: 'Parents Visiting',
                fireDrill: 'Fire Drill',
                principalInspection: 'Principal Inspection',
                powerOutage: 'Power Outage',
                foodFight: 'Food Fight',
                superheroStudent: 'Superhero Mode',
                ghostJanitor: 'Ghost Janitor',
                timeFreeze: 'Time Freeze',
                earthquake: 'Earthquake',
                pizzaDelivery: 'Pizza Delivery'
            },

            et: {
                // Main Menu
                title: 'KOOLIST PÃ•GENEMINE',
                subtitle: 'PÃµgene Ãµpetajate eest!',
                startGame: 'ALUSTA MÃ„NGU',
                howToPlay: 'KUIDAS MÃ„NGIDA',
                backToMenu: 'TAGASI MENÃœÃœSSE',

                // Settings
                schoolType: 'Kooli tÃ¼Ã¼p:',
                elementary: 'Algkool (Lihtne)',
                middleSchool: 'PÃµhikool (Keskmine)',
                highSchool: 'GÃ¼mnaasium (Raske)',
                university: 'Ãœlikool (Ekspert)',
                mapSize: 'Kaardi suurus:',
                small: 'VÃ¤ike',
                medium: 'Keskmine',
                large: 'Suur',
                teachers: 'Ã•petajad:',
                language: 'Keel:',
                soundOn: 'ğŸ”Š Heli: SEES',
                soundOff: 'ğŸ”‡ Heli: VÃ„LJAS',
                musicOn: 'ğŸµ Muusika: SEES',
                musicOff: 'ğŸµ Muusika: VÃ„LJAS',

                // Game UI
                score: 'Skoor',
                combo: 'Kombo',
                level: 'Tase',
                items: 'Esemed',
                move: 'Liigu',
                dash: 'Spurdi',
                usePowerup: 'Kasuta vÃµimendust',
                pause: 'Paus',

                // Power-ups
                hallPass: 'Koridoriluba',
                energyDrink: 'Energiajook',
                stinkBomb: 'Haisupomm',
                skateboard: 'Rula',

                // How To Play
                objective: 'EESMÃ„RK:',
                objectiveText: 'Kogu kÃµik kodutÃ¶Ã¶ lehed ja jÃµua vÃ¤ljapÃ¤Ã¤suni ilma Ãµpetajate kÃ¤tte jÃ¤Ã¤mata!',
                controls: 'JUHTIMINE:',
                controlMove: 'WASD vÃµi Nooleklahvid - Liigu',
                controlDash: 'TÃœHIK - Spurdi (kiire kiirendus)',
                controlPowerup: '1, 2, 3 - Kasuta kogutud vÃµimendusi',
                controlPause: 'ESC - Peata mÃ¤ng',
                powerups: 'VÃ•IMENDUSED:',
                hallPassDesc: 'Koridoriluba - Ajutine puutumatus',
                energyDrinkDesc: 'Energiajook - Superkiirus',
                stinkBombDesc: 'Haisupomm - Uimastab lÃ¤hedal olevad Ãµpetajad',
                skateboardDesc: 'Rula - Kiire liikumine',
                teachersTitle: 'Ã•PETAJAD:',
                patrolDesc: 'PatrullÃµpetaja - JÃ¤rgib kindlaid marsruute',
                hunterDesc: 'Jahtija-Ãµpetaja - JÃ¤litab sind aktiivselt',
                fastDesc: 'Kiire Ãµpetaja - Kiire, kuid etteaimatav',

                // Teacher labels
                patrol: 'PATRULL',
                hunter: 'JAHTIJA',
                fast: 'KIIRE',

                // Pause Screen
                paused: 'PEATATUD',
                resume: 'JÃ„TKA',
                quitToMenu: 'TAGASI MENÃœÃœSSE',

                // Game Over
                escaped: 'PÃ•GENESID!',
                caught: 'TABATUD!',
                gameOver: 'MÃ„NG LÃ„BI',
                playAgain: 'MÃ„NGI UUESTI',
                mainMenu: 'PEAMENÃœÃœ',
                itemsCollected: 'Esemed',
                livesRemaining: 'Elusid jÃ¤Ã¤nud',

                // In-game messages
                escape: 'PÃ•GENE!',
                invincible: 'PUUTUMATU!',
                speedBoost: 'KIIRUSE TÃ•US!',
                stinkBombMsg: 'HAISUPOMM!',
                skateboardMsg: 'RULA!',
                caughtMsg: 'TABATUD!',
                livesLeft: 'elu jÃ¤Ã¤nud',
                got: 'Said',

                // Game modes
                freePlay: 'VABAMÃ„NG',
                campaign: 'KAMPAANIA',
                selectMode: 'Vali reÅ¾iim',
                continueGame: 'JÃ„TKA',
                newGame: 'UUS MÃ„NG',

                // Level names
                grade1: '1. klass',
                grade2: '2. klass',
                grade3: '3. klass',
                grade4: '4. klass',
                grade5: '5. klass',
                grade6: '6. klass',
                grade7: '7. klass',
                grade8: '8. klass',
                grade9: '9. klass',
                gymnasium1: 'GÃ¼mnaasium I',
                gymnasium2: 'GÃ¼mnaasium II',
                gymnasium3: 'GÃ¼mnaasium III',
                bachelor1: 'Bakalaureus 1. aasta',
                bachelor2: 'Bakalaureus 2. aasta',
                bachelor3: 'Bakalaureus 3. aasta',
                master1: 'Magister 1. aasta',
                master2: 'Magister 2. aasta',

                // Level complete
                levelComplete: 'TASE LÃ„BITUD!',
                nextLevel: 'JÃ„RGMINE TASE',
                graduated: 'LÃ•PETASID!',
                graduatedMsg: 'Palju Ãµnne! Oled lÃ¤binud kÃµik tasemed!',
                levelProgress: 'Edenemine',
                currentLevel: 'Praegune tase',
                completed: 'lÃ¤bitud',
                totalScore: 'Koguskoor',
                campaign: 'KAMPAANIA',
                freePlay: 'VABAMÃ„NG',

                // Random Events
                eventsOn: 'ğŸ² SÃ¼ndmused: SEES',
                eventsOff: 'ğŸ² SÃ¼ndmused: VÃ„LJAS',
                eventEnded: 'SÃ¼ndmus lÃµppes',
                ufoAbduction: 'UFO rÃ¶Ã¶vimine',
                dinosaurStampede: 'Dinosauruste tormakas',
                parentsVisiting: 'Vanemad kÃ¼lastavad',
                fireDrill: 'TuleÃµppus',
                principalInspection: 'Direktori kontroll',
                powerOutage: 'Elektrikatkestus',
                foodFight: 'Toidulahing',
                superheroStudent: 'Superkangelase reÅ¾iim',
                ghostJanitor: 'Kummituskoristaja',
                timeFreeze: 'Aja peatumine',
                earthquake: 'MaavÃ¤rin',
                pizzaDelivery: 'Pitsakuller'
            },

            lv: {
                // Main Menu
                title: 'BÄ’GÅ ANA NO SKOLAS',
                subtitle: 'IzbÄ“dz no skolotÄjiem!',
                startGame: 'SÄ€KT SPÄ’LI',
                howToPlay: 'KÄ€ SPÄ’LÄ’T',
                backToMenu: 'ATPAKAÄ» UZ IZVÄ’LNI',

                // Settings
                schoolType: 'Skolas tips:',
                elementary: 'Pamatskola (Viegli)',
                middleSchool: 'Vidusskola (VidÄ“ji)',
                highSchool: 'Ä¢imnÄzija (GrÅ«ti)',
                university: 'UniversitÄte (Eksperts)',
                mapSize: 'Kartes izmÄ“rs:',
                small: 'Mazs',
                medium: 'VidÄ“js',
                large: 'Liels',
                teachers: 'SkolotÄji:',
                language: 'Valoda:',
                soundOn: 'ğŸ”Š SkaÅ†a: IESLÄ’GTA',
                soundOff: 'ğŸ”‡ SkaÅ†a: IZSLÄ’GTA',
                musicOn: 'ğŸµ MÅ«zika: IESLÄ’GTA',
                musicOff: 'ğŸµ MÅ«zika: IZSLÄ’GTA',

                // Game UI
                score: 'Punkti',
                combo: 'Kombo',
                level: 'LÄ«menis',
                items: 'PriekÅ¡meti',
                move: 'KustÄ“ties',
                dash: 'Sprints',
                usePowerup: 'Lietot bonusu',
                pause: 'Pauze',

                // Power-ups
                hallPass: 'Koridora caurlaide',
                energyDrink: 'EnerÄ£ijas dzÄ“riens',
                stinkBomb: 'SmirdÄ«gÄ bumba',
                skateboard: 'SkrituÄ¼dÄ“lis',

                // How To Play
                objective: 'MÄ’RÄ¶IS:',
                objectiveText: 'SavÄc visas mÄjasdarbu lapas un aizsniedz izeju, neiekÄ¼Å«stot skolotÄju rokÄs!',
                controls: 'VADÄªBA:',
                controlMove: 'WASD vai BultiÅ†as - KustÄ“ties',
                controlDash: 'ATSTARPE - Sprints (Ätrs Ätruma uzplÅ«ds)',
                controlPowerup: '1, 2, 3 - Lietot savÄktos bonusus',
                controlPause: 'ESC - Pauze',
                powerups: 'BONUSI:',
                hallPassDesc: 'Koridora caurlaide - ÄªslaicÄ«ga neaizskaramÄ«ba',
                energyDrinkDesc: 'EnerÄ£ijas dzÄ“riens - Super Ätrums',
                stinkBombDesc: 'SmirdÄ«gÄ bumba - Apdullina tuvumÄ esoÅ¡os skolotÄjus',
                skateboardDesc: 'SkrituÄ¼dÄ“lis - Ä€tra pÄrvietoÅ¡anÄs',
                teachersTitle: 'SKOLOTÄ€JI:',
                patrolDesc: 'PatruÄ¼as skolotÄjs - Seko noteiktiem marÅ¡rutiem',
                hunterDesc: 'Mednieka skolotÄjs - AktÄ«vi tevi vajÄ',
                fastDesc: 'Ä€trais skolotÄjs - Ä€trs, bet paredzams',

                // Teacher labels
                patrol: 'PATRULA',
                hunter: 'MEDNIEKS',
                fast: 'Ä€TRAIS',

                // Pause Screen
                paused: 'PAUZE',
                resume: 'TURPINÄ€T',
                quitToMenu: 'UZ IZVÄ’LNI',

                // Game Over
                escaped: 'IZBÄ’GI!',
                caught: 'NOÄ¶ERTS!',
                gameOver: 'SPÄ’LE BEIGUSIES',
                playAgain: 'SPÄ’LÄ’T VÄ’LREIZ',
                mainMenu: 'GALVENÄ€ IZVÄ’LNE',
                itemsCollected: 'PriekÅ¡meti',
                livesRemaining: 'AtlikuÅ¡Äs dzÄ«vÄ«bas',

                // In-game messages
                escape: 'BÄ’DZ!',
                invincible: 'NEAIZSKARAMS!',
                speedBoost: 'Ä€TRUMA PALIELINÄ€JUMS!',
                stinkBombMsg: 'SMIRDÄªGÄ€ BUMBA!',
                skateboardMsg: 'SKRITUÄ»DÄ’LIS!',
                caughtMsg: 'NOÄ¶ERTS!',
                livesLeft: 'dzÄ«vÄ«bas atlikuÅ¡as',
                got: 'Ieguvi',

                // Game modes
                freePlay: 'BRÄªVÄ€ SPÄ’LE',
                campaign: 'KAMPAÅ…A',
                selectMode: 'IzvÄ“lies reÅ¾Ä«mu',
                continueGame: 'TURPINÄ€T',
                newGame: 'JAUNA SPÄ’LE',

                // Level names
                grade1: '1. klase',
                grade2: '2. klase',
                grade3: '3. klase',
                grade4: '4. klase',
                grade5: '5. klase',
                grade6: '6. klase',
                grade7: '7. klase',
                grade8: '8. klase',
                grade9: '9. klase',
                gymnasium1: 'Ä¢imnÄzija I',
                gymnasium2: 'Ä¢imnÄzija II',
                gymnasium3: 'Ä¢imnÄzija III',
                bachelor1: 'Bakalaurs 1. gads',
                bachelor2: 'Bakalaurs 2. gads',
                bachelor3: 'Bakalaurs 3. gads',
                master1: 'MaÄ£istrs 1. gads',
                master2: 'MaÄ£istrs 2. gads',

                // Level complete
                levelComplete: 'LÄªMENIS PABEIGTS!',
                nextLevel: 'NÄ€KAMAIS LÄªMENIS',
                graduated: 'ABSOLVÄ’JI!',
                graduatedMsg: 'Apsveicam! Tu esi pabeidzis visus lÄ«meÅ†us!',
                levelProgress: 'Progress',
                currentLevel: 'PaÅ¡reizÄ“jais lÄ«menis',
                completed: 'pabeigts',
                totalScore: 'KopÄ“jie punkti',
                campaign: 'KAMPAÅ…A',
                freePlay: 'BRÄªVÄ€ SPÄ’LE',

                // Random Events
                eventsOn: 'ğŸ² Notikumi: IESL',
                eventsOff: 'ğŸ² Notikumi: IZSL',
                eventEnded: 'Notikums beidzÄs',
                ufoAbduction: 'NLO nolaupÄ«Å¡ana',
                dinosaurStampede: 'Dinozauru stampÄ“de',
                parentsVisiting: 'VecÄku vizÄ«te',
                fireDrill: 'UgunsdzÄ“sÄ«bas mÄcÄ«bas',
                principalInspection: 'Direktora pÄrbaude',
                powerOutage: 'ElektrÄ«bas pÄrtraukums',
                foodFight: 'Ä’diena kauja',
                superheroStudent: 'SupervaroÅ†a reÅ¾Ä«ms',
                ghostJanitor: 'Spoku sÄ“tnieks',
                timeFreeze: 'Laika apstÄÅ¡anÄs',
                earthquake: 'ZemestrÄ«ce',
                pizzaDelivery: 'Picas piegÄde'
            },

            lt: {
                // Main Menu
                title: 'PABÄ–GIMAS IÅ  MOKYKLOS',
                subtitle: 'PabÄ—k nuo mokytojÅ³!',
                startGame: 'PRADÄ–TI Å½AIDIMÄ„',
                howToPlay: 'KAIP Å½AISTI',
                backToMenu: 'GRÄ®Å½TI Ä® MENIU',

                // Settings
                schoolType: 'Mokyklos tipas:',
                elementary: 'PradinÄ— (Lengva)',
                middleSchool: 'PagrindinÄ— (VidutinÄ—)',
                highSchool: 'Gimnazija (Sunki)',
                university: 'Universitetas (Ekspertas)',
                mapSize: 'Å½emÄ—lapio dydis:',
                small: 'MaÅ¾as',
                medium: 'Vidutinis',
                large: 'Didelis',
                teachers: 'Mokytojai:',
                language: 'Kalba:',
                soundOn: 'ğŸ”Š Garsas: Ä®JUNGTAS',
                soundOff: 'ğŸ”‡ Garsas: IÅ JUNGTAS',
                musicOn: 'ğŸµ Muzika: Ä®JUNGTA',
                musicOff: 'ğŸµ Muzika: IÅ JUNGTA',

                // Game UI
                score: 'TaÅ¡kai',
                combo: 'Kombo',
                level: 'Lygis',
                items: 'Daiktai',
                move: 'JudÄ—ti',
                dash: 'Sprintas',
                usePowerup: 'Naudoti galiÄ…',
                pause: 'PauzÄ—',

                // Power-ups
                hallPass: 'Koridoriaus leidimas',
                energyDrink: 'Energinis gÄ—rimas',
                stinkBomb: 'Smirdanti bomba',
                skateboard: 'RiedlentÄ—',

                // How To Play
                objective: 'TIKSLAS:',
                objectiveText: 'Surink visus namÅ³ darbÅ³ lapus ir pasiek iÅ¡Ä—jimÄ… nepakliuvÄ™s mokytojams!',
                controls: 'VALDYMAS:',
                controlMove: 'WASD arba RodyklÄ—s - JudÄ—ti',
                controlDash: 'TARPAS - Sprintas (greitas pagreitis)',
                controlPowerup: '1, 2, 3 - Naudoti surinktus galiÅ³ stiprintuvus',
                controlPause: 'ESC - PauzÄ—',
                powerups: 'GALIÅ² STIPRINTUVAI:',
                hallPassDesc: 'Koridoriaus leidimas - Laikinas nelieÄiamumas',
                energyDrinkDesc: 'Energinis gÄ—rimas - Super greitis',
                stinkBombDesc: 'Smirdanti bomba - Apsvaigia netoliese esanÄius mokytojus',
                skateboardDesc: 'RiedlentÄ— - Greitas judÄ—jimas',
                teachersTitle: 'MOKYTOJAI:',
                patrolDesc: 'Patruliuojantis mokytojas - Seka nustatytus marÅ¡rutus',
                hunterDesc: 'MedÅ¾iotojas mokytojas - Aktyviai tave vejasi',
                fastDesc: 'Greitas mokytojas - Greitas, bet nuspÄ—jamas',

                // Teacher labels
                patrol: 'PATRULÄ–',
                hunter: 'MEDÅ½IOT.',
                fast: 'GREITAS',

                // Pause Screen
                paused: 'PAUZÄ–',
                resume: 'TÄ˜STI',
                quitToMenu: 'Ä® MENIU',

                // Game Over
                escaped: 'PABÄ–GAI!',
                caught: 'PAGAUTAS!',
                gameOver: 'Å½AIDIMAS BAIGTAS',
                playAgain: 'Å½AISTI DAR KARTÄ„',
                mainMenu: 'PAGRINDINIS MENIU',
                itemsCollected: 'Daiktai',
                livesRemaining: 'Likusios gyvybÄ—s',

                // In-game messages
                escape: 'BÄ–KK!',
                invincible: 'NELIEÄŒIAMAS!',
                speedBoost: 'GREIÄŒIO PADIDINIMAS!',
                stinkBombMsg: 'SMIRDANTI BOMBA!',
                skateboardMsg: 'RIEDLENTÄ–!',
                caughtMsg: 'PAGAUTAS!',
                livesLeft: 'gyvybÄ—s liko',
                got: 'Gavai',

                // Game modes
                freePlay: 'LAISVAS Å½AIDIMAS',
                campaign: 'KAMPANIJA',
                selectMode: 'Pasirink reÅ¾imÄ…',
                continueGame: 'TÄ˜STI',
                newGame: 'NAUJAS Å½AIDIMAS',

                // Level names
                grade1: '1 klasÄ—',
                grade2: '2 klasÄ—',
                grade3: '3 klasÄ—',
                grade4: '4 klasÄ—',
                grade5: '5 klasÄ—',
                grade6: '6 klasÄ—',
                grade7: '7 klasÄ—',
                grade8: '8 klasÄ—',
                grade9: '9 klasÄ—',
                gymnasium1: 'Gimnazija I',
                gymnasium2: 'Gimnazija II',
                gymnasium3: 'Gimnazija III',
                bachelor1: 'Bakalauras 1 metai',
                bachelor2: 'Bakalauras 2 metai',
                bachelor3: 'Bakalauras 3 metai',
                master1: 'Magistras 1 metai',
                master2: 'Magistras 2 metai',

                // Level complete
                levelComplete: 'LYGIS BAIGTAS!',
                nextLevel: 'KITAS LYGIS',
                graduated: 'BAIGEI!',
                graduatedMsg: 'Sveikiname! Baigei visus lygius!',
                levelProgress: 'Progresas',
                currentLevel: 'Dabartinis lygis',
                completed: 'baigta',
                totalScore: 'Bendras rezultatas',
                campaign: 'KAMPANIJA',
                freePlay: 'LAISVAS Å½AIDIMAS',

                // Random Events
                eventsOn: 'ğŸ² Ä®vykiai: Ä®J',
                eventsOff: 'ğŸ² Ä®vykiai: IÅ J',
                eventEnded: 'Ä®vykis baigÄ—si',
                ufoAbduction: 'NSO pagrobimas',
                dinosaurStampede: 'DinozaurÅ³ antplÅ«dis',
                parentsVisiting: 'TÄ—vÅ³ vizitas',
                fireDrill: 'GaisrinÄ— treniruotÄ—',
                principalInspection: 'Direktoriaus patikra',
                powerOutage: 'Elektros dingimas',
                foodFight: 'Maisto mÅ«Å¡is',
                superheroStudent: 'Superherojaus reÅ¾imas',
                ghostJanitor: 'Vaiduoklis sargas',
                timeFreeze: 'Laiko sustabdymas',
                earthquake: 'Å½emÄ—s drebÄ—jimas',
                pizzaDelivery: 'Picos pristatymas'
            },

            ru: {
                // Main Menu
                title: 'ĞŸĞĞ‘Ğ•Ğ“ Ğ˜Ğ— Ğ¨ĞšĞĞ›Ğ«',
                subtitle: 'Ğ£Ğ±ĞµĞ³Ğ¸ Ğ¾Ñ‚ ÑƒÑ‡Ğ¸Ñ‚ĞµĞ»ĞµĞ¹!',
                startGame: 'ĞĞĞ§ĞĞ¢Ğ¬ Ğ˜Ğ“Ğ Ğ£',
                howToPlay: 'ĞšĞĞš Ğ˜Ğ“Ğ ĞĞ¢Ğ¬',
                backToMenu: 'ĞĞĞ—ĞĞ” Ğ’ ĞœĞ•ĞĞ®',

                // Settings
                schoolType: 'Ğ¢Ğ¸Ğ¿ ÑˆĞºĞ¾Ğ»Ñ‹:',
                elementary: 'ĞĞ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ°Ñ (Ğ›ĞµĞ³ĞºĞ¾)',
                middleSchool: 'Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ (ĞĞ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾)',
                highSchool: 'Ğ“Ğ¸Ğ¼Ğ½Ğ°Ğ·Ğ¸Ñ (Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾)',
                university: 'Ğ£Ğ½Ğ¸Ğ²ĞµÑ€ÑĞ¸Ñ‚ĞµÑ‚ (Ğ­ĞºÑĞ¿ĞµÑ€Ñ‚)',
                mapSize: 'Ğ Ğ°Ğ·Ğ¼ĞµÑ€ ĞºĞ°Ñ€Ñ‚Ñ‹:',
                small: 'ĞœĞ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ğ¹',
                medium: 'Ğ¡Ñ€ĞµĞ´Ğ½Ğ¸Ğ¹',
                large: 'Ğ‘Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹',
                teachers: 'Ğ£Ñ‡Ğ¸Ñ‚ĞµĞ»Ñ:',
                language: 'Ğ¯Ğ·Ñ‹Ğº:',
                soundOn: 'ğŸ”Š Ğ—Ğ²ÑƒĞº: Ğ’ĞšĞ›',
                soundOff: 'ğŸ”‡ Ğ—Ğ²ÑƒĞº: Ğ’Ğ«ĞšĞ›',
                musicOn: 'ğŸµ ĞœÑƒĞ·Ñ‹ĞºĞ°: Ğ’ĞšĞ›',
                musicOff: 'ğŸµ ĞœÑƒĞ·Ñ‹ĞºĞ°: Ğ’Ğ«ĞšĞ›',

                // Game UI
                score: 'ĞÑ‡ĞºĞ¸',
                combo: 'ĞšĞ¾Ğ¼Ğ±Ğ¾',
                level: 'Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ',
                items: 'ĞŸÑ€ĞµĞ´Ğ¼ĞµÑ‚Ñ‹',

                // How to Play
                objective: 'Ğ¦Ğ•Ğ›Ğ¬:',
                objectiveText: 'Ğ¡Ğ¾Ğ±ĞµÑ€Ğ¸ Ğ²ÑĞµ Ğ´Ğ¾Ğ¼Ğ°ÑˆĞ½Ğ¸Ğµ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¸ Ğ´Ğ¾Ğ±ĞµÑ€Ğ¸ÑÑŒ Ğ´Ğ¾ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ°, Ğ½Ğµ Ğ¿Ğ¾Ğ¿Ğ°Ğ²ÑˆĞ¸ÑÑŒ ÑƒÑ‡Ğ¸Ñ‚ĞµĞ»ÑĞ¼!',
                controls: 'Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ•:',
                moveKeys: 'WASD Ğ¸Ğ»Ğ¸ Ğ¡Ñ‚Ñ€ĞµĞ»ĞºĞ¸ - Ğ”Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ',
                dashKey: 'ĞŸĞ ĞĞ‘Ğ•Ğ› - Ğ Ñ‹Ğ²Ğ¾Ğº',
                powerupKeys: '1, 2, 3 - Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ±Ğ¾Ğ½ÑƒÑ',
                pauseKey: 'ESC - ĞŸĞ°ÑƒĞ·Ğ°',
                powerups: 'Ğ‘ĞĞĞ£Ğ¡Ğ«:',
                hallPass: 'ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞº - Ğ’Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ Ğ½ĞµÑƒÑĞ·Ğ²Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ',
                energyDrink: 'Ğ­Ğ½ĞµÑ€Ğ³ĞµÑ‚Ğ¸Ğº - Ğ¡ÑƒĞ¿ĞµÑ€ ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ',
                stinkBomb: 'Ğ’Ğ¾Ğ½ÑÑ‡Ğ°Ñ Ğ±Ğ¾Ğ¼Ğ±Ğ° - ĞĞ³Ğ»ÑƒÑˆĞ°ĞµÑ‚ ÑƒÑ‡Ğ¸Ñ‚ĞµĞ»ĞµĞ¹',
                skateboard: 'Ğ¡ĞºĞµĞ¹Ñ‚Ğ±Ğ¾Ñ€Ğ´ - Ğ‘Ñ‹ÑÑ‚Ñ€Ğ¾Ğµ Ğ¿ĞµÑ€ĞµĞ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ',
                teacherTypes: 'Ğ£Ğ§Ğ˜Ğ¢Ğ•Ğ›Ğ¯:',
                patrolTeacher: 'ĞŸĞ°Ñ‚Ñ€ÑƒĞ»ÑŒĞ½Ñ‹Ğ¹ - Ğ¥Ğ¾Ğ´Ğ¸Ñ‚ Ğ¿Ğ¾ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ñƒ',
                hunterTeacher: 'ĞÑ…Ğ¾Ñ‚Ğ½Ğ¸Ğº - ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ Ğ¿Ñ€ĞµÑĞ»ĞµĞ´ÑƒĞµÑ‚',
                fastTeacher: 'Ğ‘Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ - Ğ¡ĞºĞ¾Ñ€Ğ¾ÑÑ‚Ğ½Ğ¾Ğ¹, Ğ½Ğ¾ Ğ¿Ñ€ĞµĞ´ÑĞºĞ°Ğ·ÑƒĞµĞ¼Ñ‹Ğ¹',

                // Game Over
                escaped: 'Ğ¡Ğ‘Ğ•Ğ–ĞĞ›!',
                caught: 'ĞŸĞĞ™ĞœĞĞ!',
                playAgain: 'Ğ˜Ğ“Ğ ĞĞ¢Ğ¬ Ğ¡ĞĞĞ’Ğ',
                mainMenu: 'Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ®',
                itemsCollected: 'Ğ¡Ğ¾Ğ±Ñ€Ğ°Ğ½Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ¼ĞµÑ‚Ğ¾Ğ²',
                livesRemaining: 'ĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ Ğ¶Ğ¸Ğ·Ğ½ĞµĞ¹',

                // In-game messages
                escape: 'Ğ‘ĞµĞ³Ğ¸ Ğº Ğ²Ñ‹Ñ…Ğ¾Ğ´Ñƒ!',
                paused: 'ĞŸĞĞ£Ğ—Ğ',
                resume: 'ĞŸĞ ĞĞ”ĞĞ›Ğ–Ğ˜Ğ¢Ğ¬',
                quit: 'Ğ’Ğ«Ğ™Ğ¢Ğ˜ Ğ’ ĞœĞ•ĞĞ®',
                newGame: 'ĞĞĞ’ĞĞ¯ Ğ˜Ğ“Ğ Ğ',

                // Level names
                grade1: '1 ĞšĞ»Ğ°ÑÑ',
                grade2: '2 ĞšĞ»Ğ°ÑÑ',
                grade3: '3 ĞšĞ»Ğ°ÑÑ',
                grade4: '4 ĞšĞ»Ğ°ÑÑ',
                grade5: '5 ĞšĞ»Ğ°ÑÑ',
                grade6: '6 ĞšĞ»Ğ°ÑÑ',
                grade7: '7 ĞšĞ»Ğ°ÑÑ',
                grade8: '8 ĞšĞ»Ğ°ÑÑ',
                grade9: '9 ĞšĞ»Ğ°ÑÑ',
                gymnasium1: 'Ğ“Ğ¸Ğ¼Ğ½Ğ°Ğ·Ğ¸Ñ I',
                gymnasium2: 'Ğ“Ğ¸Ğ¼Ğ½Ğ°Ğ·Ğ¸Ñ II',
                gymnasium3: 'Ğ“Ğ¸Ğ¼Ğ½Ğ°Ğ·Ğ¸Ñ III',
                bachelor1: 'Ğ‘Ğ°ĞºĞ°Ğ»Ğ°Ğ²Ñ€ 1 Ğ³Ğ¾Ğ´',
                bachelor2: 'Ğ‘Ğ°ĞºĞ°Ğ»Ğ°Ğ²Ñ€ 2 Ğ³Ğ¾Ğ´',
                bachelor3: 'Ğ‘Ğ°ĞºĞ°Ğ»Ğ°Ğ²Ñ€ 3 Ğ³Ğ¾Ğ´',
                master1: 'ĞœĞ°Ğ³Ğ¸ÑÑ‚Ñ€ 1 Ğ³Ğ¾Ğ´',
                master2: 'ĞœĞ°Ğ³Ğ¸ÑÑ‚Ñ€ 2 Ğ³Ğ¾Ğ´',

                // Level complete
                levelComplete: 'Ğ£Ğ ĞĞ’Ğ•ĞĞ¬ ĞŸĞ ĞĞ™Ğ”Ğ•Ğ!',
                nextLevel: 'Ğ¡Ğ›Ğ•Ğ”Ğ£Ğ®Ğ©Ğ˜Ğ™ Ğ£Ğ ĞĞ’Ğ•ĞĞ¬',
                graduated: 'Ğ’Ğ«ĞŸĞ£Ğ¡ĞšĞĞ˜Ğš!',
                graduatedMsg: 'ĞŸĞ¾Ğ·Ğ´Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼! Ğ’Ñ‹ Ğ¿Ñ€Ğ¾ÑˆĞ»Ğ¸ Ğ²ÑĞµ ÑƒÑ€Ğ¾Ğ²Ğ½Ğ¸!',
                levelProgress: 'ĞŸÑ€Ğ¾Ğ³Ñ€ĞµÑÑ',
                currentLevel: 'Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ',
                completed: 'Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½Ğ¾',
                totalScore: 'ĞĞ±Ñ‰Ğ¸Ğ¹ ÑÑ‡Ñ‘Ñ‚',
                campaign: 'ĞšĞĞœĞŸĞĞĞ˜Ğ¯',
                freePlay: 'Ğ¡Ğ’ĞĞ‘ĞĞ”ĞĞĞ¯ Ğ˜Ğ“Ğ Ğ',

                // Random Events
                eventsOn: 'ğŸ² Ğ¡Ğ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ: Ğ’ĞšĞ›',
                eventsOff: 'ğŸ² Ğ¡Ğ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ: Ğ’Ğ«ĞšĞ›',
                eventEnded: 'Ğ¡Ğ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾',
                ufoAbduction: 'ĞŸĞ¾Ñ…Ğ¸Ñ‰ĞµĞ½Ğ¸Ğµ ĞĞ›Ğ',
                dinosaurStampede: 'ĞĞ°ÑˆĞµÑÑ‚Ğ²Ğ¸Ğµ Ğ´Ğ¸Ğ½Ğ¾Ğ·Ğ°Ğ²Ñ€Ğ¾Ğ²',
                parentsVisiting: 'Ğ’Ğ¸Ğ·Ğ¸Ñ‚ Ñ€Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ĞµĞ¹',
                fireDrill: 'ĞŸĞ¾Ğ¶Ğ°Ñ€Ğ½Ğ°Ñ Ñ‚Ñ€ĞµĞ²Ğ¾Ğ³Ğ°',
                principalInspection: 'ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ°',
                powerOutage: 'ĞÑ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ²ĞµÑ‚Ğ°',
                foodFight: 'Ğ‘Ğ¸Ñ‚Ğ²Ğ° ĞµĞ´Ğ¾Ğ¹',
                superheroStudent: 'Ğ ĞµĞ¶Ğ¸Ğ¼ ÑÑƒĞ¿ĞµÑ€Ğ³ĞµÑ€Ğ¾Ñ',
                ghostJanitor: 'ĞŸÑ€Ğ¸Ğ·Ñ€Ğ°Ğº ÑƒĞ±Ğ¾Ñ€Ñ‰Ğ¸ĞºĞ°',
                timeFreeze: 'ĞÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸',
                earthquake: 'Ğ—ĞµĞ¼Ğ»ĞµÑ‚Ñ€ÑÑĞµĞ½Ğ¸Ğµ',
                pizzaDelivery: 'Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ¿Ğ¸Ñ†Ñ†Ñ‹'
            }
        };

        function t(key) {
            return translations[settings.language][key] || translations.en[key] || key;
        }

        function updateLanguage() {
            // Update main menu
            document.querySelector('#main-menu h1').textContent = t('title');
            document.querySelector('#main-menu h2').textContent = t('subtitle');
            document.getElementById('start-button').textContent = t('startGame');
            document.getElementById('how-to-play-button').textContent = t('howToPlay');

            // Update settings labels
            const settingLabels = document.querySelectorAll('.setting-row label');
            if (settingLabels[0]) settingLabels[0].textContent = t('schoolType');
            if (settingLabels[1]) settingLabels[1].textContent = t('mapSize');
            if (settingLabels[2]) settingLabels[2].textContent = t('teachers');
            if (settingLabels[3]) settingLabels[3].textContent = t('language');

            // Update school type options
            const schoolTypeSelect = document.getElementById('school-type');
            schoolTypeSelect.options[0].textContent = t('elementary');
            schoolTypeSelect.options[1].textContent = t('middleSchool');
            schoolTypeSelect.options[2].textContent = t('highSchool');
            schoolTypeSelect.options[3].textContent = t('university');

            // Update map size options
            const mapSizeSelect = document.getElementById('map-size');
            mapSizeSelect.options[0].textContent = t('small');
            mapSizeSelect.options[1].textContent = t('medium');
            mapSizeSelect.options[2].textContent = t('large');

            // Update sound buttons
            updateSoundButtons();

            // Update campaign/freeplay buttons
            document.getElementById('campaign-button').innerHTML = `ğŸ“š ${t('campaign')}`;
            document.getElementById('freeplay-button').innerHTML = `ğŸ® ${t('freePlay')}`;

            // Update How To Play screen
            document.querySelector('#how-to-play-screen h2').textContent = t('howToPlay');
            document.getElementById('back-to-menu-button').textContent = t('backToMenu');

            // Update how to play content
            const howToPlayContent = document.querySelector('#how-to-play-screen .settings-panel');
            howToPlayContent.innerHTML = `
                <p style="margin-bottom: 15px;"><strong style="color: #4ade80;">${t('objective')}</strong> ${t('objectiveText')}</p>
                <p style="margin-bottom: 15px;"><strong style="color: #60a5fa;">${t('controls')}</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>${t('controlMove')}</li>
                    <li>${t('controlDash')}</li>
                    <li>${t('controlPowerup')}</li>
                    <li>${t('controlPause')}</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #ffd700;">${t('powerups')}</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>ğŸ“œ ${t('hallPassDesc')}</li>
                    <li>âš¡ ${t('energyDrinkDesc')}</li>
                    <li>ğŸ’¨ ${t('stinkBombDesc')}</li>
                    <li>ğŸ›¹ ${t('skateboardDesc')}</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #ff6b6b;">${t('teachersTitle')}</strong></p>
                <ul style="margin-left: 20px;">
                    <li><span style="display:inline-block;width:16px;height:16px;background:#4a90a4;border-radius:50%;vertical-align:middle;margin-right:5px;"></span> ${t('patrolDesc')}</li>
                    <li><span style="display:inline-block;width:16px;height:16px;background:#c0392b;border-radius:3px;vertical-align:middle;margin-right:5px;"></span> ${t('hunterDesc')}</li>
                    <li><span style="display:inline-block;width:16px;height:12px;background:#9b59b6;border-radius:50%;vertical-align:middle;margin-right:5px;"></span> ${t('fastDesc')}</li>
                </ul>
            `;

            // Update Pause screen
            document.querySelector('#pause-screen h2').textContent = t('paused');
            document.getElementById('resume-button').textContent = t('resume');
            document.getElementById('quit-button').textContent = t('quitToMenu');

            // Update Game Over screen
            document.getElementById('retry-button').textContent = t('playAgain');
            document.getElementById('menu-button').textContent = t('mainMenu');

            // Update footer hints
            const footerHints = document.querySelectorAll('#game-footer .key-hint');
            if (footerHints[0]) footerHints[0].innerHTML = `<span class="key">WASD</span> / <span class="key">â†â†‘â†“â†’</span> ${t('move')}`;
            if (footerHints[1]) footerHints[1].innerHTML = `<span class="key">SPACE</span> ${t('dash')}`;
            if (footerHints[2]) footerHints[2].innerHTML = `<span class="key">1-3</span> ${t('usePowerup')}`;
            if (footerHints[3]) footerHints[3].innerHTML = `<span class="key">ESC</span> ${t('pause')}`;

            // Update power-up slot titles
            document.getElementById('powerup-1').title = t('hallPass');
            document.getElementById('powerup-2').title = t('energyDrink');
            document.getElementById('powerup-3').title = t('stinkBomb');

            // Update UI displays
            updateUI();
        }

        function setLanguage(lang) {
            settings.language = lang;
            updateLanguage();
            playSound('menu_click');
        }

        // ============================================
        // SOUND SYSTEM
        // ============================================

        let audioCtx = null;
        let musicOscillators = [];
        let musicGain = null;

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(type, options = {}) {
            if (!settings.soundEnabled || !audioCtx) return;

            // Resume audio context if suspended (browser autoplay policy)
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            const time = audioCtx.currentTime;

            switch (type) {
                case 'collect':
                    // Cheerful ascending ding
                    playTone(880 + (options.combo || 1) * 50, 0.1, 'sine', 0.3);
                    playTone(1100 + (options.combo || 1) * 50, 0.1, 'sine', 0.25, 0.05);
                    break;

                case 'powerup':
                    // Magical ascending arpeggio
                    playTone(400, 0.15, 'sine', 0.3);
                    playTone(500, 0.15, 'sine', 0.25, 0.08);
                    playTone(600, 0.15, 'sine', 0.2, 0.16);
                    playTone(800, 0.2, 'sine', 0.3, 0.24);
                    break;

                case 'powerup_use':
                    // Activation whoosh
                    playSweep(200, 800, 0.3, 'sawtooth', 0.2);
                    break;

                case 'dash':
                    // Quick whoosh
                    playSweep(300, 150, 0.15, 'sawtooth', 0.15);
                    break;

                case 'caught':
                    // Alarming descending sound
                    playTone(600, 0.15, 'square', 0.3);
                    playTone(400, 0.15, 'square', 0.25, 0.1);
                    playTone(200, 0.3, 'square', 0.2, 0.2);
                    break;

                case 'alert':
                    // Teacher spotted you - quick alarm beep
                    playTone(800, 0.08, 'square', 0.15);
                    playTone(1000, 0.08, 'square', 0.12, 0.1);
                    break;

                case 'stun':
                    // Stink bomb - bubbly explosion
                    playNoise(0.3, 0.4);
                    playSweep(400, 100, 0.4, 'sawtooth', 0.2);
                    break;

                case 'win':
                    // Victory fanfare
                    const notes = [523, 659, 784, 1047]; // C E G C
                    notes.forEach((freq, i) => {
                        playTone(freq, 0.3, 'sine', 0.3, i * 0.15);
                        playTone(freq * 1.5, 0.3, 'sine', 0.15, i * 0.15);
                    });
                    break;

                case 'lose':
                    // Game over descending
                    playTone(400, 0.3, 'sawtooth', 0.25);
                    playTone(350, 0.3, 'sawtooth', 0.2, 0.25);
                    playTone(300, 0.5, 'sawtooth', 0.15, 0.5);
                    break;

                case 'footstep':
                    // Soft footstep
                    playNoise(0.03, 0.05);
                    break;

                case 'slide':
                    // Wet floor sliding
                    playSweep(200, 400, 0.1, 'sine', 0.1);
                    break;

                case 'menu_click':
                    // UI click
                    playTone(600, 0.05, 'sine', 0.2);
                    break;

                case 'menu_hover':
                    // UI hover
                    playTone(400, 0.03, 'sine', 0.1);
                    break;
            }
        }

        function playTone(frequency, duration, waveType = 'sine', volume = 0.3, delay = 0) {
            if (!audioCtx) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = waveType;
            oscillator.frequency.value = frequency;

            const startTime = audioCtx.currentTime + delay;
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(volume, startTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

            oscillator.start(startTime);
            oscillator.stop(startTime + duration + 0.1);
        }

        function playSweep(startFreq, endFreq, duration, waveType = 'sine', volume = 0.3) {
            if (!audioCtx) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = waveType;
            oscillator.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(endFreq, audioCtx.currentTime + duration);

            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + duration + 0.1);
        }

        function playNoise(duration, volume = 0.3) {
            if (!audioCtx) return;

            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * volume;
            }

            const noise = audioCtx.createBufferSource();
            const gainNode = audioCtx.createGain();

            noise.buffer = buffer;
            noise.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);

            noise.start();
        }

        // Background music using simple procedural generation
        function startMusic() {
            if (!settings.musicEnabled || !audioCtx) return;
            stopMusic();

            // Resume AudioContext if suspended (browser autoplay policy)
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    actuallyStartMusic();
                });
            } else {
                actuallyStartMusic();
            }
        }

        function actuallyStartMusic() {
            if (!audioCtx || musicOscillators.length > 0) return;

            musicGain = audioCtx.createGain();
            musicGain.gain.value = 0.25; // Increased from 0.08
            musicGain.connect(audioCtx.destination);

            // Create a simple bass line
            const bassNotes = [130.81, 146.83, 164.81, 146.83]; // C3, D3, E3, D3
            let noteIndex = 0;

            function playNextNote() {
                if (!settings.musicEnabled || musicOscillators.length === 0 || !audioCtx) return;

                const osc = audioCtx.createOscillator();
                const noteGain = audioCtx.createGain();

                osc.connect(noteGain);
                noteGain.connect(musicGain);

                osc.type = 'triangle';
                osc.frequency.value = bassNotes[noteIndex];

                noteGain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                noteGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);

                osc.start();
                osc.stop(audioCtx.currentTime + 0.5);

                noteIndex = (noteIndex + 1) % bassNotes.length;
            }

            // Start the loop
            const musicInterval = setInterval(() => {
                if (settings.musicEnabled && gameState.running && !gameState.paused && musicOscillators.length > 0) {
                    playNextNote();
                }
            }, 500);

            musicOscillators.push({ interval: musicInterval });

            // Add ambient pad
            const padOsc = audioCtx.createOscillator();
            const padGain = audioCtx.createGain();
            const padFilter = audioCtx.createBiquadFilter();

            padOsc.connect(padFilter);
            padFilter.connect(padGain);
            padGain.connect(musicGain);

            padOsc.type = 'sawtooth';
            padOsc.frequency.value = 65.41; // C2
            padFilter.type = 'lowpass';
            padFilter.frequency.value = 300; // Increased from 200 for more presence
            padGain.gain.value = 0.3; // Increased from 0.15

            padOsc.start();
            musicOscillators.push({ osc: padOsc, gain: padGain });
        }

        function stopMusic() {
            musicOscillators.forEach(item => {
                if (item.interval) clearInterval(item.interval);
                if (item.osc) {
                    try {
                        item.osc.stop();
                    } catch (e) {}
                }
            });
            musicOscillators = [];
        }

        function toggleSound() {
            settings.soundEnabled = !settings.soundEnabled;
            updateSoundButtons();
            if (settings.soundEnabled) {
                playSound('menu_click');
            }
        }

        function toggleMusic() {
            settings.musicEnabled = !settings.musicEnabled;
            updateSoundButtons();
            if (settings.musicEnabled && gameState.running) {
                startMusic();
            } else {
                stopMusic();
            }
        }

        function toggleEvents() {
            settings.eventsEnabled = !settings.eventsEnabled;
            updateSoundButtons();
            playSound('menu_click');
        }

        function updateSoundButtons() {
            const soundBtn = document.getElementById('sound-toggle');
            const musicBtn = document.getElementById('music-toggle');
            const eventsBtn = document.getElementById('events-toggle');
            if (soundBtn) soundBtn.textContent = settings.soundEnabled ? t('soundOn') : t('soundOff');
            if (musicBtn) musicBtn.textContent = settings.musicEnabled ? t('musicOn') : t('musicOff');
            if (eventsBtn) eventsBtn.textContent = settings.eventsEnabled ? t('eventsOn') : t('eventsOff');
        }

        // ============================================
        // RANDOM EVENTS SYSTEM
        // ============================================

        function updateEvents(deltaTime) {
            if (!settings.eventsEnabled || !gameState.running || gameState.paused) return;

            // Update current event
            if (currentEvent) {
                eventTimer -= deltaTime;
                updateCurrentEvent(deltaTime);
                if (eventTimer <= 0) {
                    endCurrentEvent();
                }
            } else {
                // Check if it's time for a new event
                nextEventTime -= deltaTime;
                if (nextEventTime <= 0) {
                    triggerRandomEvent();
                }
            }

            // Update event entities
            updateEventEntities(deltaTime);
        }

        function triggerRandomEvent() {
            const event = RANDOM_EVENTS[Math.floor(Math.random() * RANDOM_EVENTS.length)];
            currentEvent = { ...event };
            eventTimer = event.duration;
            nextEventTime = event.minInterval + Math.random() * 20;

            // Show event announcement
            showMessage(`${event.icon} ${t(event.name)}!`);
            playSound('powerup');

            // Initialize event-specific state
            initEventState(event.id);
        }

        function initEventState(eventId) {
            eventEntities = [];

            switch (eventId) {
                case 'ufo':
                    // Create UFO that moves across the map
                    eventEntities.push({
                        type: 'ufo',
                        x: -100,
                        y: Math.random() * gameState.mapHeight * TILE_SIZE,
                        targetY: Math.random() * gameState.mapHeight * TILE_SIZE,
                        speed: 150,
                        beamActive: false,
                        beamTimer: 0
                    });
                    break;

                case 'dinosaur':
                    // Create dinosaurs running through
                    const numDinos = 3 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < numDinos; i++) {
                        eventEntities.push({
                            type: 'dinosaur',
                            x: -50 - i * 80,
                            y: (Math.random() * 0.6 + 0.2) * gameState.mapHeight * TILE_SIZE,
                            speed: 200 + Math.random() * 100,
                            variant: Math.random() < 0.3 ? 'trex' : 'raptor'
                        });
                    }
                    break;

                case 'parents':
                    // Spawn parent figures around the map
                    for (let i = 0; i < 4; i++) {
                        const pos = getRandomFloorPosition();
                        eventEntities.push({
                            type: 'parent',
                            x: pos.x,
                            y: pos.y,
                            wanderAngle: Math.random() * Math.PI * 2
                        });
                    }
                    break;

                case 'fireDrill':
                    // Find exit position for all characters to move toward
                    gameState.fireDrillActive = true;
                    break;

                case 'principal':
                    // Spawn principal
                    const principalPos = getRandomFloorPosition();
                    eventEntities.push({
                        type: 'principal',
                        x: principalPos.x,
                        y: principalPos.y,
                        patrolAngle: 0
                    });
                    // Freeze all teachers
                    teachers.forEach(t => t.frozen = true);
                    break;

                case 'powerOutage':
                    gameState.powerOutage = true;
                    break;

                case 'foodFight':
                    // Spawn flying food projectiles periodically
                    gameState.foodFightActive = true;
                    break;

                case 'superhero':
                    // Give player temporary powers
                    player.superhero = true;
                    player.canFly = true;
                    break;

                case 'ghost':
                    // Spawn ghost janitor
                    const ghostPos = getRandomFloorPosition();
                    eventEntities.push({
                        type: 'ghost',
                        x: ghostPos.x,
                        y: ghostPos.y,
                        targetX: ghostPos.x,
                        targetY: ghostPos.y,
                        alpha: 0.7
                    });
                    break;

                case 'timeFreeze':
                    gameState.timeFreeze = true;
                    teachers.forEach(t => t.frozen = true);
                    break;

                case 'earthquake':
                    gameState.earthquakeActive = true;
                    gameState.screenShake = 10;
                    // Create some new openings in walls
                    createEarthquakeCracks();
                    break;

                case 'pizza':
                    // Spawn pizza delivery person at entrance
                    eventEntities.push({
                        type: 'pizza',
                        x: 2 * TILE_SIZE,
                        y: gameState.mapHeight / 2 * TILE_SIZE
                    });
                    // Teachers rush to entrance
                    teachers.forEach(t => {
                        t.rushingToPizza = true;
                        t.pizzaTarget = { x: 3 * TILE_SIZE, y: gameState.mapHeight / 2 * TILE_SIZE };
                    });
                    break;
            }
        }

        function updateCurrentEvent(deltaTime) {
            if (!currentEvent) return;

            switch (currentEvent.id) {
                case 'foodFight':
                    // Spawn food projectiles randomly
                    if (Math.random() < 0.1) {
                        const pos = getRandomFloorPosition();
                        eventEntities.push({
                            type: 'food',
                            x: pos.x,
                            y: pos.y - 200,
                            vy: 300,
                            foodType: ['ğŸ•', 'ğŸ”', 'ğŸŒ­', 'ğŸ¥ª', 'ğŸ©'][Math.floor(Math.random() * 5)]
                        });
                    }
                    break;

                case 'earthquake':
                    if (Math.random() < 0.3) {
                        gameState.screenShake = Math.max(gameState.screenShake, 5);
                    }
                    break;
            }
        }

        function updateEventEntities(deltaTime) {
            const toRemove = [];

            eventEntities.forEach((entity, index) => {
                switch (entity.type) {
                    case 'ufo':
                        // Move UFO across screen
                        entity.x += entity.speed * deltaTime;
                        entity.y += (entity.targetY - entity.y) * 0.02;

                        // Beam logic
                        entity.beamTimer -= deltaTime;
                        if (entity.beamTimer <= 0) {
                            entity.beamActive = !entity.beamActive;
                            entity.beamTimer = entity.beamActive ? 1.5 : 0.5;
                        }

                        // Check beam collision with teachers
                        if (entity.beamActive) {
                            teachers.forEach(teacher => {
                                const dx = teacher.x - entity.x;
                                const dy = teacher.y - entity.y;
                                if (Math.abs(dx) < 60 && dy > 0 && dy < 200) {
                                    teacher.stunned = true;
                                    teacher.stunnedTimer = 2;
                                    teacher.y -= 50 * deltaTime; // Lift up
                                }
                            });
                            // Slow player if in beam
                            const pdx = player.x - entity.x;
                            const pdy = player.y - entity.y;
                            if (Math.abs(pdx) < 60 && pdy > 0 && pdy < 200) {
                                player.vx *= 0.5;
                                player.vy *= 0.5;
                            }
                        }

                        if (entity.x > gameState.mapWidth * TILE_SIZE + 100) {
                            toRemove.push(index);
                        }
                        break;

                    case 'dinosaur':
                        entity.x += entity.speed * deltaTime;

                        // Knock down anyone in path
                        const checkKnockdown = (targetX, targetY, isPlayer) => {
                            const dx = targetX - entity.x;
                            const dy = targetY - entity.y;
                            if (Math.abs(dx) < 40 && Math.abs(dy) < 30) {
                                if (isPlayer && !player.invincible) {
                                    gameState.screenShake = 8;
                                    player.vx = 200;
                                    player.vy = (Math.random() - 0.5) * 200;
                                } else if (!isPlayer) {
                                    return true; // Stun teacher
                                }
                            }
                            return false;
                        };

                        teachers.forEach(teacher => {
                            if (checkKnockdown(teacher.x, teacher.y, false)) {
                                teacher.stunned = true;
                                teacher.stunnedTimer = 3;
                            }
                        });
                        checkKnockdown(player.x, player.y, true);

                        if (entity.x > gameState.mapWidth * TILE_SIZE + 100) {
                            toRemove.push(index);
                        }
                        break;

                    case 'parent':
                        // Wander around slowly
                        entity.wanderAngle += (Math.random() - 0.5) * 0.1;
                        const parentSpeed = 30;
                        const newPX = entity.x + Math.cos(entity.wanderAngle) * parentSpeed * deltaTime;
                        const newPY = entity.y + Math.sin(entity.wanderAngle) * parentSpeed * deltaTime;
                        if (!checkWallCollision(newPX, newPY, 20)) {
                            entity.x = newPX;
                            entity.y = newPY;
                        } else {
                            entity.wanderAngle += Math.PI;
                        }

                        // Distract nearby teachers (slow them down)
                        teachers.forEach(teacher => {
                            const dx = teacher.x - entity.x;
                            const dy = teacher.y - entity.y;
                            if (Math.sqrt(dx*dx + dy*dy) < 150) {
                                teacher.distracted = true;
                            }
                        });
                        break;

                    case 'principal':
                        // Patrol in a circle
                        entity.patrolAngle += deltaTime * 0.5;
                        const radius = 100;
                        const targetX = entity.x + Math.cos(entity.patrolAngle) * radius;
                        const targetY = entity.y + Math.sin(entity.patrolAngle) * radius;
                        entity.displayX = targetX;
                        entity.displayY = targetY;
                        break;

                    case 'ghost':
                        // Float toward wet floors and clean them
                        if (Math.random() < 0.02) {
                            // Find new target (wet floor or random)
                            let foundWetFloor = false;
                            for (let y = 0; y < gameState.mapHeight && !foundWetFloor; y++) {
                                for (let x = 0; x < gameState.mapWidth && !foundWetFloor; x++) {
                                    if (gameState.map[y][x] === TILES.WET_FLOOR) {
                                        entity.targetX = x * TILE_SIZE + TILE_SIZE/2;
                                        entity.targetY = y * TILE_SIZE + TILE_SIZE/2;
                                        foundWetFloor = true;
                                    }
                                }
                            }
                            if (!foundWetFloor) {
                                const pos = getRandomFloorPosition();
                                entity.targetX = pos.x;
                                entity.targetY = pos.y;
                            }
                        }

                        // Move toward target
                        const gdx = entity.targetX - entity.x;
                        const gdy = entity.targetY - entity.y;
                        const gDist = Math.sqrt(gdx*gdx + gdy*gdy);
                        if (gDist > 5) {
                            entity.x += (gdx / gDist) * 80 * deltaTime;
                            entity.y += (gdy / gDist) * 80 * deltaTime;
                        }

                        // Clean wet floor at current position
                        const gTileX = Math.floor(entity.x / TILE_SIZE);
                        const gTileY = Math.floor(entity.y / TILE_SIZE);
                        if (gameState.map[gTileY] && gameState.map[gTileY][gTileX] === TILES.WET_FLOOR) {
                            gameState.map[gTileY][gTileX] = TILES.FLOOR;
                        }

                        // Scare nearby teachers
                        teachers.forEach(teacher => {
                            const dx = teacher.x - entity.x;
                            const dy = teacher.y - entity.y;
                            if (Math.sqrt(dx*dx + dy*dy) < 100) {
                                // Run away from ghost
                                teacher.vx = dx * 2;
                                teacher.vy = dy * 2;
                                teacher.scaredTimer = 1;
                            }
                        });

                        entity.alpha = 0.5 + Math.sin(Date.now() / 200) * 0.3;
                        break;

                    case 'food':
                        entity.y += entity.vy * deltaTime;

                        // Check collision with ground/entities
                        const foodTileY = Math.floor(entity.y / TILE_SIZE);
                        if (foodTileY >= 0 && foodTileY < gameState.mapHeight) {
                            // Hit teachers
                            teachers.forEach(teacher => {
                                const dx = teacher.x - entity.x;
                                const dy = teacher.y - entity.y;
                                if (Math.sqrt(dx*dx + dy*dy) < 30) {
                                    teacher.stunned = true;
                                    teacher.stunnedTimer = 2;
                                    toRemove.push(index);
                                }
                            });

                            // Hit player
                            const pdx = player.x - entity.x;
                            const pdy = player.y - entity.y;
                            if (Math.sqrt(pdx*pdx + pdy*pdy) < 25 && !player.invincible) {
                                player.vx += (Math.random() - 0.5) * 100;
                                player.vy += (Math.random() - 0.5) * 100;
                                toRemove.push(index);
                            }

                            // Hit ground
                            if (entity.y > foodTileY * TILE_SIZE + TILE_SIZE) {
                                // Create slippery spot
                                const tileX = Math.floor(entity.x / TILE_SIZE);
                                if (gameState.map[foodTileY] && gameState.map[foodTileY][tileX] === TILES.FLOOR) {
                                    gameState.map[foodTileY][tileX] = TILES.WET_FLOOR;
                                }
                                toRemove.push(index);
                            }
                        }
                        break;

                    case 'pizza':
                        // Just stands there, teachers come to it
                        entity.timer = (entity.timer || 0) + deltaTime;
                        break;
                }
            });

            // Remove entities marked for removal (in reverse order)
            toRemove.sort((a, b) => b - a).forEach(idx => eventEntities.splice(idx, 1));
        }

        function endCurrentEvent() {
            if (!currentEvent) return;

            // Clean up event-specific state
            switch (currentEvent.id) {
                case 'principal':
                case 'timeFreeze':
                    teachers.forEach(t => t.frozen = false);
                    break;

                case 'powerOutage':
                    gameState.powerOutage = false;
                    break;

                case 'fireDrill':
                    gameState.fireDrillActive = false;
                    break;

                case 'foodFight':
                    gameState.foodFightActive = false;
                    break;

                case 'superhero':
                    player.superhero = false;
                    player.canFly = false;
                    break;

                case 'earthquake':
                    gameState.earthquakeActive = false;
                    break;

                case 'pizza':
                    teachers.forEach(t => {
                        t.rushingToPizza = false;
                        t.pizzaTarget = null;
                    });
                    break;

                case 'parents':
                    teachers.forEach(t => t.distracted = false);
                    break;
            }

            eventEntities = [];
            currentEvent = null;
            showMessage(t('eventEnded'));
        }

        function createEarthquakeCracks() {
            // Create 3-5 new openings in walls
            const numCracks = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numCracks; i++) {
                const x = Math.floor(Math.random() * (gameState.mapWidth - 2)) + 1;
                const y = Math.floor(Math.random() * (gameState.mapHeight - 2)) + 1;
                if (gameState.map[y][x] === TILES.WALL) {
                    // Check if it connects two floor tiles
                    const hasFloorNeighbor =
                        (gameState.map[y-1] && gameState.map[y-1][x] === TILES.FLOOR) ||
                        (gameState.map[y+1] && gameState.map[y+1][x] === TILES.FLOOR) ||
                        (gameState.map[y][x-1] === TILES.FLOOR) ||
                        (gameState.map[y][x+1] === TILES.FLOOR);
                    if (hasFloorNeighbor) {
                        gameState.map[y][x] = TILES.FLOOR;
                        spawnParticle(x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2, 'hit');
                    }
                }
            }
        }

        function getRandomFloorPosition() {
            let attempts = 0;
            while (attempts < 100) {
                const x = Math.floor(Math.random() * gameState.mapWidth);
                const y = Math.floor(Math.random() * gameState.mapHeight);
                if (gameState.map[y] && gameState.map[y][x] === TILES.FLOOR) {
                    return { x: x * TILE_SIZE + TILE_SIZE/2, y: y * TILE_SIZE + TILE_SIZE/2 };
                }
                attempts++;
            }
            return { x: player.x, y: player.y };
        }

        function drawEventEntities(ctx) {
            eventEntities.forEach(entity => {
                const screenX = entity.x - gameState.camera.x;
                const screenY = entity.y - gameState.camera.y;

                switch (entity.type) {
                    case 'ufo':
                        // Draw UFO
                        ctx.save();
                        ctx.translate(screenX, screenY);

                        // UFO body
                        ctx.fillStyle = '#888';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 40, 15, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#4af';
                        ctx.beginPath();
                        ctx.ellipse(0, -8, 20, 12, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Beam
                        if (entity.beamActive) {
                            ctx.fillStyle = 'rgba(100, 255, 100, 0.3)';
                            ctx.beginPath();
                            ctx.moveTo(-30, 15);
                            ctx.lineTo(30, 15);
                            ctx.lineTo(60, 200);
                            ctx.lineTo(-60, 200);
                            ctx.closePath();
                            ctx.fill();
                        }
                        ctx.restore();
                        break;

                    case 'dinosaur':
                        ctx.save();
                        ctx.translate(screenX, screenY);
                        ctx.font = entity.variant === 'trex' ? '48px Arial' : '36px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(entity.variant === 'trex' ? 'ğŸ¦–' : 'ğŸ¦•', 0, 0);
                        ctx.restore();
                        break;

                    case 'parent':
                        ctx.save();
                        ctx.translate(screenX, screenY);
                        ctx.font = '32px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('ğŸ‘¨â€ğŸ‘©â€ğŸ‘§', 0, 0);
                        ctx.restore();
                        break;

                    case 'principal':
                        const dispX = (entity.displayX || entity.x) - gameState.camera.x;
                        const dispY = (entity.displayY || entity.y) - gameState.camera.y;
                        ctx.save();
                        ctx.translate(dispX, dispY);
                        ctx.font = '36px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('ğŸ©', 0, -15);
                        ctx.fillText('ğŸ‘”', 0, 10);
                        ctx.restore();
                        break;

                    case 'ghost':
                        ctx.save();
                        ctx.globalAlpha = entity.alpha || 0.7;
                        ctx.translate(screenX, screenY);
                        ctx.font = '40px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('ğŸ‘»', 0, 0);
                        ctx.restore();
                        break;

                    case 'food':
                        ctx.save();
                        ctx.translate(screenX, screenY);
                        ctx.font = '24px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(entity.foodType, 0, 0);
                        ctx.restore();
                        break;

                    case 'pizza':
                        ctx.save();
                        ctx.translate(screenX, screenY);
                        ctx.font = '36px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('ğŸ›µ', 0, -10);
                        ctx.fillText('ğŸ•', 15, 5);
                        ctx.restore();
                        break;
                }
            });

            // Draw power outage effect
            if (gameState.powerOutage) {
                ctx.save();
                // Dark overlay with flashlight effect around player
                const playerScreenX = player.x - gameState.camera.x;
                const playerScreenY = player.y - gameState.camera.y;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Flashlight circle
                ctx.globalCompositeOperation = 'destination-out';
                const gradient = ctx.createRadialGradient(playerScreenX, playerScreenY, 0, playerScreenX, playerScreenY, 120);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
                gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(playerScreenX, playerScreenY, 120, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Draw time freeze effect
            if (gameState.timeFreeze) {
                ctx.save();
                ctx.fillStyle = 'rgba(100, 150, 255, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            // Draw fire drill effect (flashing red)
            if (gameState.fireDrillActive && Math.floor(Date.now() / 200) % 2 === 0) {
                ctx.save();
                ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            // Draw current event indicator
            if (currentEvent) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width / 2 - 80, 10, 160, 30);
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${currentEvent.icon} ${Math.ceil(eventTimer)}s`, canvas.width / 2, 30);
                ctx.restore();
            }
        }

        // ============================================
        // MAP GENERATION
        // ============================================

        function generateMap() {
            const sizeConfigs = {
                small: { width: 25, height: 19 },
                medium: { width: 35, height: 27 },
                large: { width: 50, height: 38 }
            };

            const schoolConfigs = {
                elementary: { roomChance: 0.3, obstacleChance: 0.1, corridorWidth: 3 },
                middle: { roomChance: 0.4, obstacleChance: 0.15, corridorWidth: 2 },
                high: { roomChance: 0.5, obstacleChance: 0.2, corridorWidth: 2 },
                university: { roomChance: 0.6, obstacleChance: 0.25, corridorWidth: 2 }
            };

            let size, config, numTeachers, numCollectibles, speedMultiplier;

            if (gameMode === 'campaign') {
                const level = LEVELS[currentLevel];
                size = { width: level.mapSize.w, height: level.mapSize.h };
                config = schoolConfigs[level.schoolType];
                numTeachers = level.teachers;
                numCollectibles = level.collectibles;
                speedMultiplier = level.speed;
                gameState.level = level.id;
            } else {
                size = sizeConfigs[settings.mapSize];
                config = schoolConfigs[settings.schoolType];
                numTeachers = settings.teacherCount;
                numCollectibles = Math.floor(size.width * size.height / 30) + 10;
                speedMultiplier = 1.0;
            }

            gameState.mapWidth = size.width;
            gameState.mapHeight = size.height;

            // Initialize map with walls
            gameState.map = Array(size.height).fill(null).map(() =>
                Array(size.width).fill(TILES.WALL)
            );

            // Generate main corridors
            generateCorridors(config.corridorWidth);

            // Generate rooms
            generateRooms(config.roomChance);

            // Add obstacles
            addObstacles(config.obstacleChance);

            // Place exit
            placeExit();

            // Place player start
            placePlayer();

            // Place collectibles
            placeCollectibles(numCollectibles);

            // Place power-ups
            placePowerups();

            // Place teachers
            placeTeachers(numTeachers, speedMultiplier);
        }

        function generateCorridors(width) {
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            // Main horizontal corridor
            const mainY = Math.floor(mapH / 2);
            for (let x = 1; x < mapW - 1; x++) {
                for (let dy = -Math.floor(width / 2); dy <= Math.floor(width / 2); dy++) {
                    if (mainY + dy > 0 && mainY + dy < mapH - 1) {
                        gameState.map[mainY + dy][x] = TILES.FLOOR;
                    }
                }
            }

            // Vertical corridors
            const numVertical = Math.floor(mapW / 10) + 1;
            for (let i = 0; i < numVertical; i++) {
                const x = Math.floor((i + 0.5) * mapW / numVertical);
                for (let y = 1; y < mapH - 1; y++) {
                    for (let dx = -Math.floor(width / 2); dx <= Math.floor(width / 2); dx++) {
                        if (x + dx > 0 && x + dx < mapW - 1) {
                            gameState.map[y][x + dx] = TILES.FLOOR;
                        }
                    }
                }
            }

            // Additional horizontal corridors for larger maps
            if (mapH > 20) {
                const extraCorridors = [Math.floor(mapH / 4), Math.floor(3 * mapH / 4)];
                for (const y of extraCorridors) {
                    for (let x = 1; x < mapW - 1; x++) {
                        for (let dy = -Math.floor(width / 2); dy <= Math.floor(width / 2); dy++) {
                            if (y + dy > 0 && y + dy < mapH - 1) {
                                gameState.map[y + dy][x] = TILES.FLOOR;
                            }
                        }
                    }
                }
            }
        }

        function generateRooms(roomChance) {
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;
            const roomSizes = [
                { w: 5, h: 4 },
                { w: 6, h: 5 },
                { w: 7, h: 5 },
                { w: 8, h: 6 }
            ];

            const numRooms = Math.floor(mapW * mapH * roomChance / 30);

            for (let i = 0; i < numRooms; i++) {
                const roomSize = roomSizes[Math.floor(Math.random() * roomSizes.length)];
                const roomX = Math.floor(Math.random() * (mapW - roomSize.w - 2)) + 1;
                const roomY = Math.floor(Math.random() * (mapH - roomSize.h - 2)) + 1;

                // Check if room overlaps corridor
                let touchesCorridor = false;
                for (let y = roomY; y < roomY + roomSize.h && !touchesCorridor; y++) {
                    for (let x = roomX; x < roomX + roomSize.w; x++) {
                        if (gameState.map[y][x] === TILES.FLOOR) {
                            touchesCorridor = true;
                            break;
                        }
                    }
                }

                if (touchesCorridor) {
                    // Carve out the room
                    for (let y = roomY; y < roomY + roomSize.h; y++) {
                        for (let x = roomX; x < roomX + roomSize.w; x++) {
                            gameState.map[y][x] = TILES.FLOOR;
                        }
                    }

                    // Add desks in classroom pattern
                    if (Math.random() < 0.7) {
                        for (let y = roomY + 1; y < roomY + roomSize.h - 1; y += 2) {
                            for (let x = roomX + 1; x < roomX + roomSize.w - 1; x += 2) {
                                if (Math.random() < 0.6) {
                                    gameState.map[y][x] = TILES.DESK;
                                }
                            }
                        }
                    }
                }
            }
        }

        function addObstacles(obstacleChance) {
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            for (let y = 1; y < mapH - 1; y++) {
                for (let x = 1; x < mapW - 1; x++) {
                    if (gameState.map[y][x] === TILES.FLOOR && Math.random() < obstacleChance * 0.3) {
                        // Check it's not blocking a corridor completely
                        const neighbors = [
                            gameState.map[y - 1][x],
                            gameState.map[y + 1][x],
                            gameState.map[y][x - 1],
                            gameState.map[y][x + 1]
                        ];
                        const floorNeighbors = neighbors.filter(t => t === TILES.FLOOR || t === TILES.DESK).length;

                        if (floorNeighbors >= 2) {
                            const obstacleType = Math.random();
                            if (obstacleType < 0.4) {
                                gameState.map[y][x] = TILES.LOCKER;
                            } else if (obstacleType < 0.6) {
                                gameState.map[y][x] = TILES.WET_FLOOR;
                            }
                        }
                    }
                }
            }
        }

        function placeExit() {
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            // Place exit on the opposite side from where player will start
            for (let x = mapW - 2; x > mapW / 2; x--) {
                for (let y = 1; y < mapH - 1; y++) {
                    if (gameState.map[y][x] === TILES.FLOOR) {
                        gameState.map[y][x] = TILES.EXIT;
                        return;
                    }
                }
            }
        }

        function placePlayer() {
            const mapH = gameState.mapHeight;

            // Find starting position on left side
            for (let x = 1; x < 5; x++) {
                for (let y = 1; y < mapH - 1; y++) {
                    if (gameState.map[y][x] === TILES.FLOOR) {
                        player.x = x * TILE_SIZE + TILE_SIZE / 2;
                        player.y = y * TILE_SIZE + TILE_SIZE / 2;
                        return;
                    }
                }
            }
        }

        function placeCollectibles(count) {
            gameState.collectibles = [];
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            const numCollectibles = count || Math.floor(mapW * mapH / 30) + 10;

            let placed = 0;
            let attempts = 0;
            while (placed < numCollectibles && attempts < 1000) {
                const x = Math.floor(Math.random() * (mapW - 2)) + 1;
                const y = Math.floor(Math.random() * (mapH - 2)) + 1;

                if (gameState.map[y][x] === TILES.FLOOR) {
                    // Check not too close to player
                    const px = player.x / TILE_SIZE;
                    const py = player.y / TILE_SIZE;
                    if (Math.abs(x - px) + Math.abs(y - py) > 3) {
                        gameState.collectibles.push({
                            x: x * TILE_SIZE + TILE_SIZE / 2,
                            y: y * TILE_SIZE + TILE_SIZE / 2,
                            collected: false,
                            type: 'homework',
                            animOffset: Math.random() * Math.PI * 2
                        });
                        placed++;
                    }
                }
                attempts++;
            }
        }

        function placePowerups() {
            gameState.powerups = [];
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            const powerupTypes = ['hallpass', 'energydrink', 'stinkbomb', 'skateboard'];
            const numPowerups = Math.floor(mapW * mapH / 80) + 3;

            let placed = 0;
            let attempts = 0;
            while (placed < numPowerups && attempts < 500) {
                const x = Math.floor(Math.random() * (mapW - 2)) + 1;
                const y = Math.floor(Math.random() * (mapH - 2)) + 1;

                if (gameState.map[y][x] === TILES.FLOOR) {
                    gameState.powerups.push({
                        x: x * TILE_SIZE + TILE_SIZE / 2,
                        y: y * TILE_SIZE + TILE_SIZE / 2,
                        collected: false,
                        type: powerupTypes[Math.floor(Math.random() * powerupTypes.length)],
                        animOffset: Math.random() * Math.PI * 2
                    });
                    placed++;
                }
                attempts++;
            }
        }

        function placeTeachers(count, speedMultiplier = 1.0) {
            teachers = [];
            const mapW = gameState.mapWidth;
            const mapH = gameState.mapHeight;

            const teacherTypes = ['patrol', 'hunter', 'fast'];
            const numTeachers = count || settings.teacherCount;
            gameState.speedMultiplier = speedMultiplier;

            let placed = 0;
            let attempts = 0;
            while (placed < numTeachers && attempts < 500) {
                const x = Math.floor(Math.random() * (mapW - 4)) + 2;
                const y = Math.floor(Math.random() * (mapH - 4)) + 2;

                if (gameState.map[y][x] === TILES.FLOOR) {
                    // Not too close to player start
                    const px = player.x / TILE_SIZE;
                    const py = player.y / TILE_SIZE;
                    if (Math.abs(x - px) + Math.abs(y - py) > 8) {
                        const type = teacherTypes[placed % teacherTypes.length];
                        teachers.push(createTeacher(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, type));
                        placed++;
                    }
                }
                attempts++;
            }
        }

        function createTeacher(x, y, type) {
            const baseSpeed = {
                patrol: 2,
                hunter: 2.5,
                fast: 3.5
            };

            const difficultyMultiplier = {
                elementary: 0.7,
                middle: 1,
                high: 1.2,
                university: 1.4
            };

            // Use campaign speed multiplier if in campaign mode
            const campaignMultiplier = gameState.speedMultiplier || 1.0;
            const schoolMultiplier = gameMode === 'campaign' ? 1.0 : difficultyMultiplier[settings.schoolType];

            return {
                x: x,
                y: y,
                vx: 0,
                vy: 0,
                speed: baseSpeed[type] * schoolMultiplier * campaignMultiplier,
                type: type,
                direction: Math.floor(Math.random() * 4),
                patrolTimer: 0,
                chaseTimer: 0,
                stunned: false,
                stunnedTimer: 0,
                seesPlayer: false,
                animFrame: 0,
                patrolPath: generatePatrolPath(x, y)
            };
        }

        function generatePatrolPath(startX, startY) {
            // Simple patrol: move in a square pattern
            const size = (Math.random() * 3 + 2) * TILE_SIZE;
            return [
                { x: startX, y: startY },
                { x: startX + size, y: startY },
                { x: startX + size, y: startY + size },
                { x: startX, y: startY + size }
            ];
        }

        // ============================================
        // GAME LOGIC
        // ============================================

        function update(deltaTime) {
            if (!gameState.running || gameState.paused) return;

            // Update timers
            updateTimers(deltaTime);

            // Update random events
            updateEvents(deltaTime);

            // Update player
            updatePlayer(deltaTime);

            // Update teachers
            updateTeachers(deltaTime);

            // Check collisions
            checkCollisions();

            // Update particles
            updateParticles(deltaTime);

            // Update camera
            updateCamera();

            // Check win condition
            checkWinCondition();
        }

        function updateTimers(deltaTime) {
            // Combo timer
            if (gameState.comboTimer > 0) {
                gameState.comboTimer -= deltaTime;
                if (gameState.comboTimer <= 0) {
                    gameState.combo = 1;
                    updateUI();
                }
            }

            // Screen shake
            if (gameState.screenShake > 0) {
                gameState.screenShake -= deltaTime * 10;
            }

            // Player dash cooldown
            if (player.dashCooldown > 0) {
                player.dashCooldown -= deltaTime;
            }

            // Dash duration
            if (player.isDashing) {
                player.dashTimer -= deltaTime;
                if (player.dashTimer <= 0) {
                    player.isDashing = false;
                }
            }

            // Invincibility
            if (player.invincible) {
                player.invincibleTimer -= deltaTime;
                if (player.invincibleTimer <= 0) {
                    player.invincible = false;
                }
            }

            // Speed boost
            if (player.speedBoost) {
                player.speedBoostTimer -= deltaTime;
                if (player.speedBoostTimer <= 0) {
                    player.speedBoost = false;
                }
            }

            // Active powerups
            gameState.activePowerups = gameState.activePowerups.filter(p => {
                p.timer -= deltaTime;
                return p.timer > 0;
            });
        }

        function updatePlayer(deltaTime) {
            // Get input
            let dx = 0, dy = 0;
            if (keys['ArrowLeft'] || keys['KeyA']) dx -= 1;
            if (keys['ArrowRight'] || keys['KeyD']) dx += 1;
            if (keys['ArrowUp'] || keys['KeyW']) dy -= 1;
            if (keys['ArrowDown'] || keys['KeyS']) dy += 1;

            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }

            // Calculate speed
            let currentSpeed = player.speed;
            if (player.isDashing) currentSpeed *= 2.5;
            if (player.speedBoost) currentSpeed *= 1.5;
            if (player.superhero) currentSpeed *= 2.0; // Superhero speed boost

            // Check for wet floor
            const tileX = Math.floor(player.x / TILE_SIZE);
            const tileY = Math.floor(player.y / TILE_SIZE);
            if (gameState.map[tileY] && gameState.map[tileY][tileX] === TILES.WET_FLOOR) {
                currentSpeed *= 1.3; // Slide faster but less control
                player.vx += dx * currentSpeed * 0.3;
                player.vy += dy * currentSpeed * 0.3;
                player.vx *= 0.95;
                player.vy *= 0.95;
            } else {
                player.vx = dx * currentSpeed;
                player.vy = dy * currentSpeed;
            }

            // Update position with collision
            const newX = player.x + player.vx;
            const newY = player.y + player.vy;

            // Superhero can fly through walls
            if (player.canFly) {
                // Just keep within map bounds
                player.x = Math.max(PLAYER_SIZE, Math.min(newX, gameState.mapWidth * TILE_SIZE - PLAYER_SIZE));
                player.y = Math.max(PLAYER_SIZE, Math.min(newY, gameState.mapHeight * TILE_SIZE - PLAYER_SIZE));
            } else {
                if (!checkWallCollision(newX, player.y, PLAYER_SIZE)) {
                    player.x = newX;
                }
                if (!checkWallCollision(player.x, newY, PLAYER_SIZE)) {
                    player.y = newY;
                }
            }

            // Update direction
            if (dx > 0) player.direction = 0;
            else if (dx < 0) player.direction = 2;
            else if (dy > 0) player.direction = 1;
            else if (dy < 0) player.direction = 3;

            // Animation
            if (dx !== 0 || dy !== 0) {
                player.animFrame += 0.2;
            }

            // Dash particles
            if (player.isDashing) {
                spawnParticle(player.x, player.y, 'dash');
            }
        }

        function updateTeachers(deltaTime) {
            for (const teacher of teachers) {
                // Handle frozen state (from events)
                if (teacher.frozen) {
                    teacher.vx = 0;
                    teacher.vy = 0;
                    continue;
                }

                if (teacher.stunned) {
                    teacher.stunnedTimer -= deltaTime;
                    if (teacher.stunnedTimer <= 0) {
                        teacher.stunned = false;
                    }
                    continue;
                }

                // Handle scared state (from ghost)
                if (teacher.scaredTimer > 0) {
                    teacher.scaredTimer -= deltaTime;
                    // Just run in current direction
                    const newX = teacher.x + teacher.vx * deltaTime * 60;
                    const newY = teacher.y + teacher.vy * deltaTime * 60;
                    if (!checkWallCollision(newX, teacher.y, TEACHER_SIZE)) teacher.x = newX;
                    if (!checkWallCollision(teacher.x, newY, TEACHER_SIZE)) teacher.y = newY;
                    continue;
                }

                // Handle pizza delivery event - rush to pizza
                if (teacher.rushingToPizza && teacher.pizzaTarget) {
                    const pdx = teacher.pizzaTarget.x - teacher.x;
                    const pdy = teacher.pizzaTarget.y - teacher.y;
                    const pDist = Math.sqrt(pdx * pdx + pdy * pdy);
                    if (pDist > 20) {
                        teacher.vx = (pdx / pDist) * teacher.speed * 1.5;
                        teacher.vy = (pdy / pDist) * teacher.speed * 1.5;
                    } else {
                        teacher.vx = 0;
                        teacher.vy = 0;
                    }
                    const newX = teacher.x + teacher.vx;
                    const newY = teacher.y + teacher.vy;
                    if (!checkWallCollision(newX, teacher.y, TEACHER_SIZE)) teacher.x = newX;
                    if (!checkWallCollision(teacher.x, newY, TEACHER_SIZE)) teacher.y = newY;
                    continue;
                }

                // Speed modifier from distraction (parents visiting)
                const speedMod = teacher.distracted ? 0.5 : 1.0;

                // Check if teacher sees player (not during power outage)
                const dx = player.x - teacher.x;
                const dy = player.y - teacher.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const sightRange = teacher.type === 'hunter' ? 200 : 150;

                // Teachers can't see well during power outage
                const effectiveSightRange = gameState.powerOutage ? sightRange * 0.3 : sightRange;
                const nowSeesPlayer = dist < effectiveSightRange && hasLineOfSight(teacher.x, teacher.y, player.x, player.y);

                // Play alert sound when teacher first spots player
                if (nowSeesPlayer && !teacher.seesPlayer) {
                    playSound('alert');
                }
                teacher.seesPlayer = nowSeesPlayer;

                // Different AI behaviors
                if (teacher.seesPlayer && teacher.type !== 'patrol') {
                    // Chase player
                    teacher.chaseTimer = 3;
                    const angle = Math.atan2(dy, dx);
                    teacher.vx = Math.cos(angle) * teacher.speed * 1.3 * speedMod;
                    teacher.vy = Math.sin(angle) * teacher.speed * 1.3 * speedMod;
                } else if (teacher.chaseTimer > 0) {
                    teacher.chaseTimer -= deltaTime;
                    // Continue moving toward last known position
                } else {
                    // Patrol behavior
                    updatePatrol(teacher, deltaTime);
                    teacher.vx *= speedMod;
                    teacher.vy *= speedMod;
                }

                // Apply movement with collision
                const newX = teacher.x + teacher.vx;
                const newY = teacher.y + teacher.vy;

                if (!checkWallCollision(newX, teacher.y, TEACHER_SIZE)) {
                    teacher.x = newX;
                } else {
                    teacher.vx = -teacher.vx;
                }
                if (!checkWallCollision(teacher.x, newY, TEACHER_SIZE)) {
                    teacher.y = newY;
                } else {
                    teacher.vy = -teacher.vy;
                }

                // Animation
                teacher.animFrame += 0.15;
            }
        }

        function updatePatrol(teacher, deltaTime) {
            teacher.patrolTimer += deltaTime;

            if (teacher.patrolTimer > 2) {
                teacher.patrolTimer = 0;
                teacher.direction = (teacher.direction + 1) % 4;
            }

            const speed = teacher.speed;
            switch (teacher.direction) {
                case 0: teacher.vx = speed; teacher.vy = 0; break;
                case 1: teacher.vx = 0; teacher.vy = speed; break;
                case 2: teacher.vx = -speed; teacher.vy = 0; break;
                case 3: teacher.vx = 0; teacher.vy = -speed; break;
            }
        }

        function hasLineOfSight(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const steps = Math.ceil(dist / TILE_SIZE);

            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = x1 + dx * t;
                const y = y1 + dy * t;
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);

                if (gameState.map[tileY] && gameState.map[tileY][tileX] === TILES.WALL) {
                    return false;
                }
            }
            return true;
        }

        function checkWallCollision(x, y, size) {
            const halfSize = size / 2;
            const corners = [
                { x: x - halfSize, y: y - halfSize },
                { x: x + halfSize, y: y - halfSize },
                { x: x - halfSize, y: y + halfSize },
                { x: x + halfSize, y: y + halfSize }
            ];

            for (const corner of corners) {
                const tileX = Math.floor(corner.x / TILE_SIZE);
                const tileY = Math.floor(corner.y / TILE_SIZE);

                if (tileX < 0 || tileX >= gameState.mapWidth ||
                    tileY < 0 || tileY >= gameState.mapHeight) {
                    return true;
                }

                const tile = gameState.map[tileY][tileX];
                if (tile === TILES.WALL || tile === TILES.LOCKER) {
                    return true;
                }
            }
            return false;
        }

        function checkCollisions() {
            // Collectibles
            for (const item of gameState.collectibles) {
                if (item.collected) continue;

                const dx = player.x - item.x;
                const dy = player.y - item.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < PLAYER_SIZE) {
                    item.collected = true;
                    collectItem(item);
                }
            }

            // Power-ups
            for (const powerup of gameState.powerups) {
                if (powerup.collected) continue;

                const dx = player.x - powerup.x;
                const dy = player.y - powerup.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < PLAYER_SIZE) {
                    powerup.collected = true;
                    collectPowerup(powerup);
                }
            }

            // Teachers (if not invincible)
            if (!player.invincible) {
                for (const teacher of teachers) {
                    if (teacher.stunned) continue;

                    const dx = player.x - teacher.x;
                    const dy = player.y - teacher.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < (PLAYER_SIZE + TEACHER_SIZE) / 2) {
                        playerCaught();
                        break;
                    }
                }
            }
        }

        function collectItem(item) {
            // Increase combo
            gameState.combo = Math.min(gameState.combo + 1, 10);
            gameState.comboTimer = 2;

            // Add score
            const points = 100 * gameState.combo;
            gameState.score += points;

            // Play sound with pitch based on combo
            playSound('collect', { combo: gameState.combo });

            // Spawn particles
            for (let i = 0; i < 10; i++) {
                spawnParticle(item.x, item.y, 'collect');
            }

            // Show points
            spawnFloatingText(item.x, item.y, `+${points}`);

            updateUI();
        }

        function collectPowerup(powerup) {
            // Play powerup pickup sound
            playSound('powerup');

            // Find empty slot
            const emptySlot = gameState.playerPowerups.findIndex(p => p === null);
            if (emptySlot !== -1) {
                gameState.playerPowerups[emptySlot] = powerup.type;
                const powerupNames = { hallpass: t('hallPass'), energydrink: t('energyDrink'), stinkbomb: t('stinkBomb'), skateboard: t('skateboard') };
                showMessage(`${t('got')} ${powerupNames[powerup.type]}!`);
            } else {
                // Apply immediately if inventory full
                usePowerup(powerup.type);
            }

            // Particles
            for (let i = 0; i < 15; i++) {
                spawnParticle(powerup.x, powerup.y, 'powerup');
            }

            updateUI();
        }

        function usePowerup(type) {
            // Play activation sound (stink bomb has its own sound)
            if (type !== 'stinkbomb') {
                playSound('powerup_use');
            }

            switch (type) {
                case 'hallpass':
                    player.invincible = true;
                    player.invincibleTimer = 5;
                    showMessage(t('invincible'));
                    break;
                case 'energydrink':
                    player.speedBoost = true;
                    player.speedBoostTimer = 8;
                    showMessage(t('speedBoost'));
                    break;
                case 'stinkbomb':
                    // Play stun sound
                    playSound('stun');
                    // Stun nearby teachers
                    for (const teacher of teachers) {
                        const dx = player.x - teacher.x;
                        const dy = player.y - teacher.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 150) {
                            teacher.stunned = true;
                            teacher.stunnedTimer = 4;
                        }
                    }
                    showMessage(t('stinkBombMsg'));
                    gameState.screenShake = 5;
                    break;
                case 'skateboard':
                    player.speedBoost = true;
                    player.speedBoostTimer = 10;
                    showMessage(t('skateboardMsg'));
                    break;
            }
        }

        function playerCaught() {
            // Play caught sound
            playSound('caught');

            gameState.lives--;
            gameState.combo = 1;
            gameState.screenShake = 10;

            // Spawn particles
            for (let i = 0; i < 20; i++) {
                spawnParticle(player.x, player.y, 'hit');
            }

            if (gameState.lives <= 0) {
                gameOver(false);
            } else {
                // Brief invincibility and reset position
                player.invincible = true;
                player.invincibleTimer = 2;
                showMessage(`${t('caughtMsg')} ${gameState.lives} ${t('livesLeft')}`);
            }

            updateUI();
        }

        function checkWinCondition() {
            // Check if all collectibles collected
            const collected = gameState.collectibles.filter(c => c.collected).length;
            const total = gameState.collectibles.length;

            if (collected === total) {
                // Check if player is at exit
                const tileX = Math.floor(player.x / TILE_SIZE);
                const tileY = Math.floor(player.y / TILE_SIZE);

                if (gameState.map[tileY] && gameState.map[tileY][tileX] === TILES.EXIT) {
                    gameOver(true);
                }
            }
        }

        function gameOver(won) {
            gameState.running = false;
            stopMusic();

            // Play win or lose sound
            playSound(won ? 'win' : 'lose');

            // Add bonus for remaining lives
            if (won) {
                gameState.score += gameState.lives * 500;
            }

            // Campaign mode - show level complete screen
            if (gameMode === 'campaign' && won) {
                showLevelCompleteScreen();
                return;
            }

            // Free play mode or lost - show game over screen
            const screen = document.getElementById('game-over-screen');
            const title = screen.querySelector('h2');
            const scoreDisplay = document.getElementById('final-score');
            const statsDisplay = document.getElementById('final-stats');

            if (won) {
                title.textContent = t('escaped');
                screen.className = 'menu-screen win';
            } else {
                title.textContent = t('caught');
                screen.className = 'menu-screen lose';
            }

            scoreDisplay.textContent = `${t('score')}: ${gameState.score}`;
            statsDisplay.innerHTML = `
                ${t('itemsCollected')}: ${gameState.collectibles.filter(c => c.collected).length}/${gameState.collectibles.length}<br>
                ${t('livesRemaining')}: ${gameState.lives}
            `;

            screen.classList.remove('hidden');
        }

        // ============================================
        // PARTICLES & EFFECTS
        // ============================================

        function spawnParticle(x, y, type) {
            const colors = {
                collect: ['#ffd700', '#ffec8b', '#fff'],
                powerup: ['#4ade80', '#22d3ee', '#a78bfa'],
                hit: ['#ff6b6b', '#ff0000', '#ff8888'],
                dash: ['#60a5fa', '#3b82f6', '#93c5fd']
            };

            const color = colors[type][Math.floor(Math.random() * colors[type].length)];
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 3 + 1;

            gameState.particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1,
                color: color,
                size: Math.random() * 6 + 2
            });
        }

        function spawnFloatingText(x, y, text) {
            gameState.particles.push({
                x: x,
                y: y,
                vx: 0,
                vy: -2,
                life: 1,
                text: text,
                isText: true
            });
        }

        function updateParticles(deltaTime) {
            gameState.particles = gameState.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= deltaTime * 2;
                if (!p.isText) {
                    p.size *= 0.95;
                }
                return p.life > 0;
            });
        }

        function updateCamera() {
            // Smooth camera follow
            const targetX = player.x - canvas.width / 2;
            const targetY = player.y - canvas.height / 2;

            gameState.camera.x += (targetX - gameState.camera.x) * 0.1;
            gameState.camera.y += (targetY - gameState.camera.y) * 0.1;

            // Clamp to map bounds
            const maxX = gameState.mapWidth * TILE_SIZE - canvas.width;
            const maxY = gameState.mapHeight * TILE_SIZE - canvas.height;

            gameState.camera.x = Math.max(0, Math.min(maxX, gameState.camera.x));
            gameState.camera.y = Math.max(0, Math.min(maxY, gameState.camera.y));
        }

        // ============================================
        // RENDERING
        // ============================================

        function render() {
            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply screen shake
            let shakeX = 0, shakeY = 0;
            if (gameState.screenShake > 0) {
                shakeX = (Math.random() - 0.5) * gameState.screenShake;
                shakeY = (Math.random() - 0.5) * gameState.screenShake;
            }

            ctx.save();
            ctx.translate(-gameState.camera.x + shakeX, -gameState.camera.y + shakeY);

            // Draw map
            drawMap();

            // Draw collectibles
            drawCollectibles();

            // Draw power-ups
            drawPowerups();

            // Draw teachers
            drawTeachers();

            // Draw player
            drawPlayer();

            // Draw particles
            drawParticles();

            // Draw event entities (in world space)
            drawEventEntities(ctx);

            ctx.restore();

            // Draw event effects (in screen space - done inside drawEventEntities)

            // Draw minimap
            drawMinimap();

            requestAnimationFrame(render);
        }

        function drawMap() {
            const startX = Math.floor(gameState.camera.x / TILE_SIZE);
            const startY = Math.floor(gameState.camera.y / TILE_SIZE);
            const endX = Math.min(startX + Math.ceil(canvas.width / TILE_SIZE) + 2, gameState.mapWidth);
            const endY = Math.min(startY + Math.ceil(canvas.height / TILE_SIZE) + 2, gameState.mapHeight);

            for (let y = Math.max(0, startY); y < endY; y++) {
                for (let x = Math.max(0, startX); x < endX; x++) {
                    const tile = gameState.map[y][x];
                    const px = x * TILE_SIZE;
                    const py = y * TILE_SIZE;

                    switch (tile) {
                        case TILES.FLOOR:
                            ctx.fillStyle = '#3d3d5c';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Floor pattern
                            ctx.fillStyle = '#4a4a6a';
                            if ((x + y) % 2 === 0) {
                                ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            }
                            break;

                        case TILES.WALL:
                            // Wall with gradient
                            const gradient = ctx.createLinearGradient(px, py, px, py + TILE_SIZE);
                            gradient.addColorStop(0, '#5c4033');
                            gradient.addColorStop(1, '#3d2817');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Brick pattern
                            ctx.strokeStyle = '#2a1a0a';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(px + 1, py + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                            if (y % 2 === 0) {
                                ctx.beginPath();
                                ctx.moveTo(px + TILE_SIZE / 2, py);
                                ctx.lineTo(px + TILE_SIZE / 2, py + TILE_SIZE);
                                ctx.stroke();
                            }
                            break;

                        case TILES.DESK:
                            // Floor underneath
                            ctx.fillStyle = '#3d3d5c';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Desk
                            ctx.fillStyle = '#8b4513';
                            ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                            ctx.fillStyle = '#a0522d';
                            ctx.fillRect(px + 6, py + 6, TILE_SIZE - 12, TILE_SIZE - 12);
                            break;

                        case TILES.LOCKER:
                            ctx.fillStyle = '#3d3d5c';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Locker
                            ctx.fillStyle = '#4a90a4';
                            ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.fillStyle = '#5ba3b8';
                            ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, 12);
                            ctx.fillRect(px + 4, py + 18, TILE_SIZE - 8, 12);
                            // Handle
                            ctx.fillStyle = '#333';
                            ctx.fillRect(px + TILE_SIZE - 10, py + 12, 4, 8);
                            break;

                        case TILES.WET_FLOOR:
                            ctx.fillStyle = '#3d3d5c';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Water effect
                            ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Caution pattern
                            ctx.fillStyle = '#ffd700';
                            ctx.beginPath();
                            ctx.moveTo(px + TILE_SIZE / 2, py + 4);
                            ctx.lineTo(px + TILE_SIZE - 4, py + TILE_SIZE - 4);
                            ctx.lineTo(px + 4, py + TILE_SIZE - 4);
                            ctx.closePath();
                            ctx.fill();
                            ctx.fillStyle = '#333';
                            ctx.font = '16px Arial';
                            ctx.fillText('!', px + TILE_SIZE / 2 - 3, py + TILE_SIZE - 8);
                            break;

                        case TILES.EXIT:
                            ctx.fillStyle = '#3d3d5c';
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Exit door
                            const allCollected = gameState.collectibles.every(c => c.collected);
                            ctx.fillStyle = allCollected ? '#4ade80' : '#666';
                            ctx.fillRect(px + 4, py + 2, TILE_SIZE - 8, TILE_SIZE - 4);
                            // EXIT sign
                            ctx.fillStyle = allCollected ? '#fff' : '#999';
                            ctx.font = 'bold 10px Arial';
                            ctx.fillText('EXIT', px + 6, py + TILE_SIZE / 2 + 3);
                            // Glow effect if active
                            if (allCollected) {
                                ctx.strokeStyle = '#4ade80';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(px + 2, py, TILE_SIZE - 4, TILE_SIZE);
                            }
                            break;
                    }
                }
            }
        }

        function drawCollectibles() {
            const time = Date.now() / 1000;

            for (const item of gameState.collectibles) {
                if (item.collected) continue;

                const bobY = Math.sin(time * 3 + item.animOffset) * 3;

                // Glow
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(item.x, item.y + bobY, 15, 0, Math.PI * 2);
                ctx.fill();

                // Paper/homework icon
                ctx.fillStyle = '#fff';
                ctx.fillRect(item.x - 8, item.y - 10 + bobY, 16, 20);
                ctx.fillStyle = '#333';
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(item.x - 5, item.y - 6 + i * 5 + bobY, 10, 2);
                }
            }
        }

        function drawPowerups() {
            const time = Date.now() / 1000;

            for (const powerup of gameState.powerups) {
                if (powerup.collected) continue;

                const bobY = Math.sin(time * 2 + powerup.animOffset) * 4;
                const scale = 1 + Math.sin(time * 4) * 0.1;

                ctx.save();
                ctx.translate(powerup.x, powerup.y + bobY);
                ctx.scale(scale, scale);

                // Draw based on type
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                switch (powerup.type) {
                    case 'hallpass':
                        ctx.fillStyle = 'rgba(74, 222, 128, 0.3)';
                        ctx.beginPath();
                        ctx.arc(0, 0, 15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillText('ğŸ“œ', 0, 0);
                        break;
                    case 'energydrink':
                        ctx.fillStyle = 'rgba(251, 191, 36, 0.3)';
                        ctx.beginPath();
                        ctx.arc(0, 0, 15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillText('âš¡', 0, 0);
                        break;
                    case 'stinkbomb':
                        ctx.fillStyle = 'rgba(167, 139, 250, 0.3)';
                        ctx.beginPath();
                        ctx.arc(0, 0, 15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillText('ğŸ’¨', 0, 0);
                        break;
                    case 'skateboard':
                        ctx.fillStyle = 'rgba(96, 165, 250, 0.3)';
                        ctx.beginPath();
                        ctx.arc(0, 0, 15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillText('ğŸ›¹', 0, 0);
                        break;
                }

                ctx.restore();
            }
        }

        function drawTeachers() {
            for (const teacher of teachers) {
                const bobY = Math.sin(teacher.animFrame) * 2;

                ctx.save();
                ctx.translate(teacher.x, teacher.y + bobY);

                // Stunned effect
                if (teacher.stunned) {
                    ctx.globalAlpha = 0.5;
                    // Dizzy stars
                    ctx.font = '12px Arial';
                    const starAngle = Date.now() / 200;
                    ctx.fillText('â­', Math.cos(starAngle) * 15, -20 + Math.sin(starAngle) * 5);
                    ctx.fillText('â­', Math.cos(starAngle + Math.PI) * 15, -20 + Math.sin(starAngle + Math.PI) * 5);
                }

                // Vision cone / visibility circle
                if (!teacher.stunned) {
                    const sightRange = teacher.type === 'hunter' ? 200 : 150;
                    const dirAngles = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
                    const faceAngle = dirAngles[teacher.direction];

                    // Draw vision cone
                    ctx.save();
                    ctx.globalAlpha = teacher.seesPlayer ? 0.25 : 0.1;

                    // Create cone gradient
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, sightRange);
                    if (teacher.seesPlayer) {
                        gradient.addColorStop(0, 'rgba(255, 0, 0, 0.4)');
                        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    } else {
                        gradient.addColorStop(0, 'rgba(255, 255, 0, 0.3)');
                        gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                    }

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    // Draw a cone in the facing direction
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, sightRange, faceAngle - Math.PI / 3, faceAngle + Math.PI / 3);
                    ctx.closePath();
                    ctx.fill();

                    // Draw outer edge of vision cone
                    ctx.strokeStyle = teacher.seesPlayer ? 'rgba(255, 0, 0, 0.5)' : 'rgba(255, 255, 0, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, sightRange, faceAngle - Math.PI / 3, faceAngle + Math.PI / 3);
                    ctx.stroke();

                    ctx.restore();
                }

                // Alert indicator
                if (teacher.seesPlayer && !teacher.stunned) {
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText('!', 0, -25);
                }

                // Teacher colors and styles
                const colors = {
                    patrol: '#4a90a4',    // Blue - calm patrol
                    hunter: '#c0392b',    // Red - aggressive hunter
                    fast: '#9b59b6'       // Purple - speedy
                };

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(0, TEACHER_SIZE / 2 - 5, TEACHER_SIZE / 2, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Body - different shapes for each type
                ctx.fillStyle = colors[teacher.type];
                if (teacher.type === 'patrol') {
                    // Circle body (normal)
                    ctx.beginPath();
                    ctx.arc(0, 0, TEACHER_SIZE / 2, 0, Math.PI * 2);
                    ctx.fill();
                    // Clipboard accessory
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-8, 5, 6, 10);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-7, 6, 4, 8);
                } else if (teacher.type === 'hunter') {
                    // Square-ish body (intimidating)
                    ctx.beginPath();
                    ctx.roundRect(-TEACHER_SIZE / 2, -TEACHER_SIZE / 2, TEACHER_SIZE, TEACHER_SIZE, 6);
                    ctx.fill();
                    // Angry eyebrows
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-6, -8);
                    ctx.lineTo(-2, -5);
                    ctx.moveTo(6, -8);
                    ctx.lineTo(2, -5);
                    ctx.stroke();
                    // Whistle accessory
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(10, 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (teacher.type === 'fast') {
                    // Oval body (aerodynamic)
                    ctx.beginPath();
                    ctx.ellipse(0, 0, TEACHER_SIZE / 2 - 2, TEACHER_SIZE / 2 + 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Speed lines
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-TEACHER_SIZE / 2 - 5, -3);
                    ctx.lineTo(-TEACHER_SIZE / 2 - 12, -3);
                    ctx.moveTo(-TEACHER_SIZE / 2 - 3, 3);
                    ctx.lineTo(-TEACHER_SIZE / 2 - 10, 3);
                    ctx.stroke();
                    // Sneakers (running shoes)
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-5, TEACHER_SIZE / 2 - 2, 10, 4);
                }

                // Face - eyes that look in movement direction
                const dirAngles = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
                const faceAngle = dirAngles[teacher.direction];

                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-4, -2, 5, 0, Math.PI * 2);
                ctx.arc(4, -2, 5, 0, Math.PI * 2);
                ctx.fill();

                // Pupils (look in direction of movement)
                ctx.fillStyle = '#333';
                const pupilOffset = 2;
                ctx.beginPath();
                ctx.arc(-4 + Math.cos(faceAngle) * pupilOffset, -2 + Math.sin(faceAngle) * pupilOffset, 2, 0, Math.PI * 2);
                ctx.arc(4 + Math.cos(faceAngle) * pupilOffset, -2 + Math.sin(faceAngle) * pupilOffset, 2, 0, Math.PI * 2);
                ctx.fill();

                // Type label above head
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = colors[teacher.type];
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                const label = teacher.type === 'patrol' ? t('patrol') : teacher.type === 'hunter' ? t('hunter') : t('fast');
                ctx.strokeText(label, 0, -TEACHER_SIZE / 2 - 5);
                ctx.fillText(label, 0, -TEACHER_SIZE / 2 - 5);

                ctx.restore();
            }
        }

        function drawPlayer() {
            const time = Date.now() / 1000;

            ctx.save();
            ctx.translate(player.x, player.y);

            // Invincibility effect
            if (player.invincible) {
                ctx.globalAlpha = 0.5 + Math.sin(time * 10) * 0.3;
                // Shield effect
                ctx.strokeStyle = '#4ade80';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, PLAYER_SIZE / 2 + 5, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Speed effect
            if (player.speedBoost) {
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.globalAlpha = 0.3 - i * 0.1;
                    ctx.beginPath();
                    ctx.arc(-player.vx * (i + 1) * 2, -player.vy * (i + 1) * 2, PLAYER_SIZE / 2 - i * 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, PLAYER_SIZE / 2 - 3, PLAYER_SIZE / 2, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Player body
            ctx.fillStyle = '#60a5fa';
            ctx.beginPath();
            ctx.arc(0, 0, PLAYER_SIZE / 2, 0, Math.PI * 2);
            ctx.fill();

            // Backpack
            ctx.fillStyle = '#f97316';
            ctx.fillRect(-PLAYER_SIZE / 2 - 3, -5, 6, 14);

            // Face
            const dirAngles = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
            const faceAngle = dirAngles[player.direction];

            // Eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(Math.cos(faceAngle) * 3 - 4, -2, 4, 0, Math.PI * 2);
            ctx.arc(Math.cos(faceAngle) * 3 + 4, -2, 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(Math.cos(faceAngle) * 5 - 4, -2, 2, 0, Math.PI * 2);
            ctx.arc(Math.cos(faceAngle) * 5 + 4, -2, 2, 0, Math.PI * 2);
            ctx.fill();

            // Smile
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 2, 5, 0.2, Math.PI - 0.2);
            ctx.stroke();

            ctx.restore();
        }

        function drawParticles() {
            for (const p of gameState.particles) {
                if (p.isText) {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(p.text, p.x, p.y);
                    ctx.globalAlpha = 1;
                } else {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }
        }

        function drawMinimap() {
            minimapCtx.fillStyle = '#1a1a2e';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            const scaleX = minimapCanvas.width / (gameState.mapWidth * TILE_SIZE);
            const scaleY = minimapCanvas.height / (gameState.mapHeight * TILE_SIZE);

            // Draw map tiles
            for (let y = 0; y < gameState.mapHeight; y++) {
                for (let x = 0; x < gameState.mapWidth; x++) {
                    const tile = gameState.map[y][x];
                    const px = x * TILE_SIZE * scaleX;
                    const py = y * TILE_SIZE * scaleY;
                    const w = TILE_SIZE * scaleX;
                    const h = TILE_SIZE * scaleY;

                    if (tile === TILES.WALL) {
                        minimapCtx.fillStyle = '#5c4033';
                    } else if (tile === TILES.EXIT) {
                        minimapCtx.fillStyle = '#4ade80';
                    } else {
                        minimapCtx.fillStyle = '#3d3d5c';
                    }
                    minimapCtx.fillRect(px, py, w, h);
                }
            }

            // Draw collectibles
            minimapCtx.fillStyle = '#ffd700';
            for (const item of gameState.collectibles) {
                if (!item.collected) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(item.x * scaleX, item.y * scaleY, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            }

            // Draw teachers
            minimapCtx.fillStyle = '#ff6b6b';
            for (const teacher of teachers) {
                minimapCtx.beginPath();
                minimapCtx.arc(teacher.x * scaleX, teacher.y * scaleY, 3, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            // Draw player
            minimapCtx.fillStyle = '#60a5fa';
            minimapCtx.beginPath();
            minimapCtx.arc(player.x * scaleX, player.y * scaleY, 4, 0, Math.PI * 2);
            minimapCtx.fill();

            // Draw viewport
            minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                gameState.camera.x * scaleX,
                gameState.camera.y * scaleY,
                canvas.width * scaleX,
                canvas.height * scaleY
            );
        }

        // ============================================
        // UI & MENUS
        // ============================================

        function updateUI() {
            document.getElementById('score-display').textContent = `${t('score')}: ${gameState.score}`;

            const comboDisplay = document.getElementById('combo-display');
            comboDisplay.textContent = `${t('combo')}: x${gameState.combo}`;
            if (gameState.combo > 1) {
                comboDisplay.classList.add('pulse');
                setTimeout(() => comboDisplay.classList.remove('pulse'), 100);
            }

            if (gameMode === 'campaign') {
                const level = LEVELS[currentLevel];
                document.getElementById('level-display').textContent = t(level.name);
            } else {
                document.getElementById('level-display').textContent = `${t('level')} ${gameState.level}`;
            }

            const collected = gameState.collectibles.filter(c => c.collected).length;
            document.getElementById('items-display').textContent = `${t('items')}: ${collected}/${gameState.collectibles.length}`;

            // Update lives
            const livesContainer = document.getElementById('lives-display');
            livesContainer.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const life = document.createElement('div');
                life.className = 'life-icon' + (i >= gameState.lives ? ' lost' : '');
                livesContainer.appendChild(life);
            }

            // Update powerup slots
            for (let i = 0; i < 3; i++) {
                const slot = document.getElementById(`powerup-${i + 1}`);
                const powerup = gameState.playerPowerups[i];
                slot.className = 'powerup-slot' + (powerup ? ' active' : '');

                if (powerup) {
                    const icons = {
                        hallpass: 'ğŸ“œ',
                        energydrink: 'âš¡',
                        stinkbomb: 'ğŸ’¨',
                        skateboard: 'ğŸ›¹'
                    };
                    slot.textContent = icons[powerup];
                } else {
                    slot.textContent = '';
                }
            }
        }

        function showMessage(text) {
            const popup = document.getElementById('message-popup');
            popup.textContent = text;
            popup.classList.add('show');
            setTimeout(() => popup.classList.remove('show'), 1500);
        }

        function showMenu(id) {
            document.querySelectorAll('.menu-screen').forEach(m => m.classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
        }

        function hideAllMenus() {
            document.querySelectorAll('.menu-screen').forEach(m => m.classList.add('hidden'));
        }

        // ============================================
        // CAMPAIGN MODE FUNCTIONS
        // ============================================

        function updateCampaignProgress() {
            const level = LEVELS[currentLevel];
            document.getElementById('current-level-text').textContent = `${t('currentLevel')}: ${t(level.name)}`;
            document.getElementById('menu-progress-bar').style.width = `${(currentLevel / LEVELS.length) * 100}%`;
            document.getElementById('menu-progress-text').textContent = `${currentLevel}/${LEVELS.length} ${t('completed')}`;
        }

        function saveCampaignProgress() {
            localStorage.setItem('schoolEscape_currentLevel', currentLevel.toString());
            localStorage.setItem('schoolEscape_totalScore', totalCampaignScore.toString());
        }

        function loadCampaignProgress() {
            const savedLevel = localStorage.getItem('schoolEscape_currentLevel');
            const savedScore = localStorage.getItem('schoolEscape_totalScore');
            if (savedLevel !== null) {
                currentLevel = parseInt(savedLevel);
            }
            if (savedScore !== null) {
                totalCampaignScore = parseInt(savedScore);
            }
        }

        function showLevelCompleteScreen() {
            const level = LEVELS[currentLevel];
            document.getElementById('level-complete-title').textContent = t('levelComplete');
            document.getElementById('level-name-display').textContent = t(level.name);
            document.getElementById('level-score').textContent = `${t('score')}: ${gameState.score}`;

            const progress = ((currentLevel + 1) / LEVELS.length) * 100;
            document.getElementById('progress-bar').style.width = `${progress}%`;
            document.getElementById('progress-text').textContent = `${currentLevel + 1}/${LEVELS.length}`;

            document.getElementById('next-level-button').textContent = t('nextLevel');
            document.getElementById('level-menu-button').textContent = t('mainMenu');

            // Add score to campaign total
            totalCampaignScore += gameState.score;
            saveCampaignProgress();

            showMenu('level-complete-screen');
        }

        function showGraduationScreen() {
            document.getElementById('graduation-message').textContent = t('graduatedMsg');
            document.getElementById('total-score').textContent = `${t('totalScore')}: ${totalCampaignScore}`;
            document.getElementById('new-game-button').textContent = t('newGame');
            document.getElementById('graduation-menu-button').textContent = t('mainMenu');

            // Reset campaign progress
            currentLevel = 0;
            totalCampaignScore = 0;
            saveCampaignProgress();

            showMenu('graduation-screen');
        }

        // ============================================
        // GAME LOOP & INITIALIZATION
        // ============================================

        let lastTime = 0;

        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            update(Math.min(deltaTime, 0.1)); // Cap delta to prevent physics issues

            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            // Reset game state
            gameState = {
                running: true,
                paused: false,
                score: 0,
                combo: 1,
                comboTimer: 0,
                lives: 3,
                level: 1,
                map: [],
                mapWidth: 0,
                mapHeight: 0,
                collectibles: [],
                powerups: [],
                activePowerups: [],
                playerPowerups: [null, null, null],
                particles: [],
                screenShake: 0,
                camera: { x: 0, y: 0 }
            };

            // Reset player
            player = {
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                speed: 4,
                dashCooldown: 0,
                isDashing: false,
                dashTimer: 0,
                invincible: false,
                invincibleTimer: 0,
                speedBoost: false,
                speedBoostTimer: 0,
                direction: 0,
                animFrame: 0,
                superhero: false,
                canFly: false
            };

            // Reset events
            currentEvent = null;
            eventTimer = 0;
            nextEventTime = 15;
            eventEntities = [];

            // Generate map
            generateMap();

            // Update UI
            updateUI();
            hideAllMenus();

            // Initialize audio and start music
            initAudio();
            startMusic();

            // Start game
            gameState.running = true;
            showMessage(t('escape'));
            playSound('menu_click');
        }

        function init() {
            // Settings controls
            document.getElementById('teacher-count').addEventListener('input', (e) => {
                settings.teacherCount = parseInt(e.target.value);
                document.getElementById('teacher-count-display').textContent = settings.teacherCount;
            });

            document.getElementById('school-type').addEventListener('change', (e) => {
                settings.schoolType = e.target.value;
            });

            document.getElementById('map-size').addEventListener('change', (e) => {
                settings.mapSize = e.target.value;
            });

            // Menu buttons
            document.getElementById('start-button').addEventListener('click', () => {
                initAudio();
                playSound('menu_click');
                startGame();
            });
            document.getElementById('how-to-play-button').addEventListener('click', () => {
                initAudio();
                playSound('menu_click');
                showMenu('how-to-play-screen');
            });
            document.getElementById('back-to-menu-button').addEventListener('click', () => {
                playSound('menu_click');
                showMenu('main-menu');
            });
            document.getElementById('resume-button').addEventListener('click', () => {
                playSound('menu_click');
                gameState.paused = false;
                hideAllMenus();
                startMusic();
            });
            document.getElementById('quit-button').addEventListener('click', () => {
                playSound('menu_click');
                stopMusic();
                gameState.running = false;
                showMenu('main-menu');
            });
            document.getElementById('retry-button').addEventListener('click', () => {
                playSound('menu_click');
                startGame();
            });
            document.getElementById('menu-button').addEventListener('click', () => {
                playSound('menu_click');
                showMenu('main-menu');
            });

            // Campaign mode button
            document.getElementById('campaign-button').addEventListener('click', () => {
                playSound('menu_click');
                gameMode = 'campaign';
                document.getElementById('campaign-progress-display').style.display = 'block';
                document.getElementById('freeplay-settings').style.display = 'none';
                document.getElementById('start-button').style.display = 'block';
                document.getElementById('campaign-button').style.opacity = '1';
                document.getElementById('freeplay-button').style.opacity = '0.5';
                updateCampaignProgress();
            });

            // Free play mode button
            document.getElementById('freeplay-button').addEventListener('click', () => {
                playSound('menu_click');
                gameMode = 'freeplay';
                document.getElementById('campaign-progress-display').style.display = 'none';
                document.getElementById('freeplay-settings').style.display = 'block';
                document.getElementById('start-button').style.display = 'block';
                document.getElementById('campaign-button').style.opacity = '0.5';
                document.getElementById('freeplay-button').style.opacity = '1';
            });

            // Next level button
            document.getElementById('next-level-button').addEventListener('click', () => {
                playSound('menu_click');
                currentLevel++;
                if (currentLevel >= LEVELS.length) {
                    showGraduationScreen();
                } else {
                    hideAllMenus();
                    startGame();
                }
            });

            // Level complete - main menu button
            document.getElementById('level-menu-button').addEventListener('click', () => {
                playSound('menu_click');
                saveCampaignProgress();
                showMenu('main-menu');
            });

            // Graduation - new game button
            document.getElementById('new-game-button').addEventListener('click', () => {
                playSound('menu_click');
                currentLevel = 0;
                totalCampaignScore = 0;
                saveCampaignProgress();
                hideAllMenus();
                startGame();
            });

            // Graduation - main menu button
            document.getElementById('graduation-menu-button').addEventListener('click', () => {
                playSound('menu_click');
                showMenu('main-menu');
            });

            // Load campaign progress on init
            loadCampaignProgress();

            // Keyboard input
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;

                // Dash
                if (e.code === 'Space' && gameState.running && !gameState.paused) {
                    if (player.dashCooldown <= 0 && !player.isDashing) {
                        player.isDashing = true;
                        player.dashTimer = 0.2;
                        player.dashCooldown = 1;
                        gameState.screenShake = 3;
                        playSound('dash');
                    }
                    e.preventDefault();
                }

                // Pause
                if (e.code === 'Escape') {
                    if (gameState.running) {
                        gameState.paused = !gameState.paused;
                        if (gameState.paused) {
                            stopMusic();
                            playSound('menu_click');
                            showMenu('pause-screen');
                        } else {
                            playSound('menu_click');
                            startMusic();
                            hideAllMenus();
                        }
                    }
                }

                // Use powerups (1, 2, 3)
                if (e.code === 'Digit1' || e.code === 'Digit2' || e.code === 'Digit3') {
                    const slot = parseInt(e.code.slice(-1)) - 1;
                    if (gameState.playerPowerups[slot]) {
                        usePowerup(gameState.playerPowerups[slot]);
                        gameState.playerPowerups[slot] = null;
                        updateUI();
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            // Initialize language
            updateLanguage();

            // Start loops
            render();
            requestAnimationFrame(gameLoop);
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
